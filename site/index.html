<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pattern Constellations</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
       
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            color: #333333;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .comment-marker {
            position: relative;
            display: inline-block;
        }

        .comment-marker .comment-tooltip {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: #fff;
            border: 1px solid #fafcee;
            border-radius: 4px;
            padding: 4px;
            z-index: 1000;
            white-space: nowrap;
            pointer-events: auto;  /* allow clicks */
        }

        .comment-marker:hover .comment-tooltip {
            display: block;
        }
       
        /* Header */
        .header {
            background: #f8f9fa;
            border-bottom: 2px solid #dee2e6;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
       
        .header h1 {
            font-size: 18px;
            color: #495057;
        }
       
        .header-actions {
            display: flex;
            gap: 15px;
        }
       
        .btn-overview {
            padding: 8px 16px;
            background: #0066cc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
       
        .btn-overview:hover {
            background: #0052a3;
        }
       
        /* Main layout */
        .main-container {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
       
        /* Left panel - Documents */
        .left-panel {
            width: 25%;
            background: #f8f9fa;
            border-right: 1px solid #dee2e6;
            overflow-y: auto;
            padding: 15px;
        }
       
        .lens-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
            border-bottom: 1px solid #dee2e6;
        }
       
        .lens-tab {
            padding: 8px 12px;
            background: transparent;
            border: none;
            cursor: pointer;
            color: #6c757d;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }
       
        .lens-tab.active {
            color: #0066cc;
            border-bottom-color: #0066cc;
        }
       
        .doc-category {
            margin-bottom: 20px;
        }
       
        .doc-category h3 {
            font-size: 12px;
            text-transform: uppercase;
            color: #6c757d;
            margin-bottom: 8px;
            font-weight: 600;
        }
       
        .document-item {
            background: white;
            padding: 10px;
            margin-bottom: 5px;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid transparent;
            transition: all 0.2s;
        }
       
        .document-item:hover {
            border-color: #0066cc;
        }
       
        .document-item.active {
            background: #e7f3ff;
            border-color: #0066cc;
        }
       
        /* Center - Main content */
        .center-panel {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            background: white;
            position: relative;
        }
       
        /* Right panel - Messages */
        .right-panel {
            width: 30%;
            background: #f8f9fa;
            border-left: 1px solid #dee2e6;
            display: flex;
            flex-direction: column;
        }
       
        .messages-header {
            padding: 15px;
            background: white;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
       
        .messages-header h3 {
            font-size: 14px;
            font-weight: 600;
            color: #495057;
        }
       
        .new-thread-btn {
            padding: 6px 12px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
       
        .topic-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 10px 15px;
            border-bottom: 1px solid #dee2e6;
        }
       
        .topic-pill {
            padding: 4px 10px;
            background: #f0f0f0;
            color: #666;
            border-radius: 12px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
       
        .topic-pill.active {
            background: #0066cc;
            color: white;
        }
       
        .messages-list {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }
       
        .message-thread {
            background: white;
            border-radius: 8px;
            margin-bottom: 10px;
            padding: 12px;
            cursor: pointer;
            border: 1px solid #e9ecef;
            transition: all 0.2s;
        }
       
        .message-thread:hover {
            border-color: #0066cc;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
       
        .message-thread.active {
            background: #e7f3ff;
            border-color: #0066cc;
        }
       
        .message-pills {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }
       
        .pill {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
        }
       
        .pill-subject {
            background: #e7f3ff;
            color: #0066cc;
        }
       
        .pill-topic {
            background: #f0f0f0;
            color: #666;
        }
       
        .pill-date {
            background: #fff3cd;
            color: #856404;
        }
       
        .pill-new {
            background: #dc3545;
            color: white;
        }
       
        .message-preview {
            font-size: 13px;
            color: #6c757d;
            margin-top: 5px;
        }
       
        .message-replies {
            font-size: 11px;
            color: #28a745;
            margin-top: 5px;
            font-weight: 500;
        }
       
        /* Thread view styles */
        .thread-messages {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
       
        .thread-message {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #dee2e6;
        }
       
        .reply-form {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
       
        .reply-form textarea {
            padding: 8px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            resize: vertical;
            min-height: 60px;
        }
       
        .reply-form button {
            align-self: flex-start;
            padding: 6px 12px;
            background: #0066cc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
       
        /* Comment Menu - VERTICAL */
        .comment-menu {
            position: absolute;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 8px;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            min-width: 180px;
        }
       
        .comment-menu.show {
            display: block;
        }
       
        .comment-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.2s;
            font-size: 14px;
            color: #495057;
        }
       
        .comment-option:hover {
            background: #f8f9fa;
        }
       
        .comment-option-icon {
            font-size: 18px;
            width: 24px;
            text-align: center;
        }
       
        .comment-option-text {
            flex: 1;
        }
       
        /* Overview Modal */
        .overview-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
        }
       
        .overview-modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }
       
        .overview-content {
            background: white;
            border-radius: 8px;
            width: 90%;
            height: 80%;
            padding: 30px;
            position: relative;
            overflow: auto;
        }
       
        .overview-close {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 24px;
            cursor: pointer;
            color: #6c757d;
        }
       
        .overview-graph {
            display: flex;
            flex-direction: column;
            gap: 30px;
            margin-top: 20px;
        }
       
        .overview-section {
            border-left: 3px solid #0066cc;
            padding-left: 20px;
        }
       
        .overview-section h3 {
            color: #0066cc;
            margin-bottom: 10px;
        }
       
        .overview-items {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
       
        .overview-item {
            padding: 8px 15px;
            background: #f8f9fa;
            border-radius: 4px;
            font-size: 13px;
            border: 1px solid #dee2e6;
        }
       
        .overview-item.stable {
            background: #d4edda;
            border-color: #28a745;
        }
       
        .overview-item.developing {
            background: #cce5ff;
            border-color: #0066cc;
        }
       
        .overview-item.draft {
            background: #fff3cd;
            border-color: #ffc107;
        }
       
        /* New thread form */
        .new-thread-form {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            z-index: 3000;
            display: none;
            width: 400px;
        }
       
        .new-thread-form.show {
            display: block;
        }
       
        .form-group {
            margin-bottom: 15px;
        }
       
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            color: #495057;
        }
       
        .form-group input, .form-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-size: 14px;
        }
       
        .form-group textarea {
            resize: vertical;
            min-height: 100px;
        }
       
        .form-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
       
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
       
        .btn-primary {
            background: #0066cc;
            color: white;
        }
       
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <h1>Pattern Constellations Research</h1>
        <div class="header-actions">
            <button class="btn-overview" onclick="showOverview()">üìä Project Overview</button>
        </div>
    </div>
   
    <!-- Main container -->
    <div class="main-container">
        <!-- Left Panel - Documents -->
        <div class="left-panel">
            <div class="lens-tabs">
                <button class="lens-tab active" data-lens="all">All</button>
                <button class="lens-tab" data-lens="philosophy">Philosophy</button>
                <button class="lens-tab" data-lens="cognition">Cognition</button>
                <button class="lens-tab" data-lens="cs-math">CS/Math</button>
            </div>
            <!-- Categories will be added dynamically -->
        </div>
       
        <!-- Center - Main content -->
        <div class="center-panel" id="center-panel">
            <div style="max-width: 700px;">
                <div style="text-align: center; padding: 60px; color: #6c757d;">
                    <h2 style="color: #495057; margin-bottom: 10px;">Select a document to begin</h2>
                    <p>Choose a document from the left panel</p>
                </div>
            </div>
        </div>
       
        <!-- Right Panel - Messages -->
        <div class="right-panel">
            <div class="messages-header">
                <h3>Discussion Threads</h3>
                <button class="new-thread-btn" onclick="showNewThreadForm()">+ New Thread</button>
            </div>
            <div class="topic-filters" id="topic-filters">
                <!-- Pills will be added here dynamically -->
            </div>
            <div class="messages-list" id="messages-list">
                <!-- Threads will be added dynamically -->
            </div>
        </div>
    </div>
   
    <!-- Comment Menu - VERTICAL with TEXT -->
    <div class="comment-menu" id="comment-menu">
        <div class="comment-option" data-type="question">
            <span class="comment-option-icon">‚ùì</span>
            <span class="comment-option-text">Ask question</span>
        </div>
        <div class="comment-option" data-type="clarification">
            <span class="comment-option-icon">‚ùó</span>
            <span class="comment-option-text">Needs clarification</span>
        </div>
        <div class="comment-option" data-type="approved">
            <span class="comment-option-icon">‚úÖ</span>
            <span class="comment-option-text">Approved / Keep</span>
        </div>
    </div>
   
    <!-- Overview Modal -->
    <div class="overview-modal" id="overview-modal">
        <div class="overview-content">
            <span class="overview-close" onclick="hideOverview()">√ó</span>
            <h2>Project Overview - Pattern Recognition Identity</h2>
           
            <div class="overview-graph">
                <div class="overview-section">
                    <h3>üéØ Core Theory</h3>
                    <div class="overview-items">
                        <div class="overview-item developing">PRI Main Thesis</div>
                        <div class="overview-item developing">Pattern-Recognition Unity</div>
                        <div class="overview-item draft">Consciousness as Reflexive PR</div>
                    </div>
                </div>
               
                <div class="overview-section">
                    <h3>üí° Problem Dissolutions</h3>
                    <div class="overview-items">
                        <div class="overview-item stable">Hard Problem</div>
                        <div class="overview-item developing">Symbol Grounding</div>
                        <div class="overview-item draft">Quantum Measurement</div>
                        <div class="overview-item draft">Causation Problem</div>
                    </div>
                </div>
               
                <div class="overview-section">
                    <h3>üìä Empirical Evidence</h3>
                    <div class="overview-items">
                        <div class="overview-item developing">Semantic Embeddings</div>
                        <div class="overview-item developing">Rod-Cap Structure</div>
                        <div class="overview-item draft">LLM Analysis</div>
                    </div>
                </div>
               
                <div class="overview-section">
                    <h3>üîó Connections</h3>
                    <div class="overview-items">
                        <div class="overview-item stable">Eastern Philosophy</div>
                        <div class="overview-item developing">Transformer Architecture</div>
                        <div class="overview-item draft">Hopfield Networks</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
   
    <!-- New Thread Form -->
    <div class="new-thread-form" id="new-thread-form">
        <h3 style="margin-bottom: 20px;">Start New Discussion Thread</h3>
        <div class="form-group">
            <label>Subject</label>
            <input type="text" id="thread-subject" placeholder="Brief topic...">
        </div>
        <div class="form-group">
            <label>Topic Category</label>
            <input type="text" id="thread-topic" placeholder="e.g., Core Theory, Evidence, Questions...">
        </div>
        <div class="form-group">
            <label>Message</label>
            <textarea id="thread-message" placeholder="Your thoughts..."></textarea>
        </div>
        <div class="form-actions">
            <button class="btn btn-secondary" onclick="hideNewThreadForm()">Cancel</button>
            <button class="btn btn-primary" onclick="createThread()">Create Thread</button>
        </div>
    </div>
   
    <script>
        // User email (in real deployment, fetch from API)
        let userEmail = 'you@example.com';
        
        async function fetchUserEmail() {
            try {
                const res = await fetch('/api/user');
                const data = await res.json();
                userEmail = data.email || 'anonymous';
            } catch {
                userEmail = 'anonymous';
            }
        }
        fetchUserEmail();

        // Sample document content
        const documentContent = {
            'pattern-recognition-identity': {
                title: 'Pattern Recognition Identity',
                content: `
# Pattern Recognition Identity

Pattern Recognition Identity (PRI) proposes a radical reconceptualization of consciousness and identity grounded in the fundamental process of pattern recognition.

## Core Thesis

The central thesis of PRI is that what we experience as consciousness, identity, and subjective experience emerges from recursive pattern recognition processes. Rather than consciousness being something that recognizes patterns, consciousness *is* pattern recognition recognizing itself.

## Theoretical Framework

### Primary Principles

1. **Pattern Recognition as Fundamental**: All cognitive processes, from perception to abstract reasoning, operate through pattern recognition mechanisms.

2. **Recursive Self-Recognition**: Consciousness emerges when pattern recognition systems recognize their own pattern recognition processes - a recursive loop of recognition recognizing recognition.

3. **Identity as Pattern Constellation**: Personal identity is not a fixed entity but a dynamic constellation of interconnected patterns that maintain coherence through ongoing pattern recognition processes.

### Implications

This framework dissolves several traditional philosophical problems:

- **The Hard Problem of Consciousness**: Experience is not separate from information processing but emerges from the recursive recognition of pattern recognition itself.

- **The Symbol Grounding Problem**: Symbols ground themselves through pattern recognition processes that connect abstract representations to embodied pattern recognition systems.

- **The Unity of Consciousness**: Unity emerges from the integrative nature of pattern recognition systems that can recognize patterns across multiple domains simultaneously.

## Empirical Connections

Current evidence supporting PRI includes:

- Semantic embedding structures in neural networks mirror conceptual organization in human cognition
- Transformer architectures demonstrate emergent properties through attention mechanisms that resemble recursive pattern recognition
- Neuroscientific evidence for predictive processing and pattern completion in cortical circuits

## Future Directions

Research priorities include:

1. Developing computational models that implement recursive pattern recognition
2. Testing empirical predictions about consciousness and identity
3. Exploring connections to phenomenology and subjective experience
4. Investigating therapeutic applications for understanding mental disorders

*Last updated: [Date]*
                `.trim()
            }
        };

        // Thread data with better timestamp management
        const threads = {
            'Eastern Philosophy Connection': {
                topic: 'Core Theory',
                timestamp: Date.now() - 86400000 * 2,
                lastActivity: Date.now() - 7200000,
                messages: [
                    {text: "I've been thinking about how PRI relates to Buddhist dependent origination. The recursive self-recognition aspect seems to mirror the Buddhist understanding of consciousness as a process rather than a thing.", timestamp: Date.now() - 86400000 * 2, user: 'supervisor@example.com'},
                    {text: 'That\'s a compelling connection. The madhyamaka analysis of dependent origination might provide insights into how pattern recognition avoids the infinite regress problem.', timestamp: Date.now() - 7200000, user: 'you@example.com'},
                    {text: 'Exactly. And the yogƒÅcƒÅra school\'s analysis of consciousness (vij√±ƒÅna) as transformative recognition could be directly relevant to our recursive model.', timestamp: Date.now() - 3600000, user: 'supervisor@example.com'},
                    {text: 'We should explore whether ƒÅlaya-vij√±ƒÅna (store consciousness) maps onto the pattern constellation structure we\'re proposing.', timestamp: Date.now() - 1800000, user: 'you@example.com'}
                ]
            },
            'Symbol Grounding Dissolution': {
                topic: 'Problems',
                timestamp: Date.now() - 86400000 * 3,
                lastActivity: Date.now() - 86400000,
                messages: [
                    {text: "The dissolution seems compelling but I'm not sure about the linguistic aspects. How does pattern recognition ground arbitrary symbols like words?", timestamp: Date.now() - 86400000 * 3, user: 'you@example.com'},
                    {text: 'The key insight is that symbols don\'t need external grounding - they ground through recognition patterns that connect them to embodied recognition systems.', timestamp: Date.now() - 86400000 * 2, user: 'supervisor@example.com'},
                    {text: 'But what about truly abstract concepts that seem divorced from embodied experience?', timestamp: Date.now() - 86400000 * 2, user: 'you@example.com'},
                    {text: 'Even abstract concepts emerge from pattern recognition operating on other patterns. Mathematical concepts, for instance, recognize structural patterns that can exist independently of specific instantiations.', timestamp: Date.now() - 86400000, user: 'supervisor@example.com'},
                    {text: 'So abstraction is pattern recognition operating on increasingly general pattern types rather than specific content?', timestamp: Date.now() - 86400000, user: 'you@example.com'}
                ]
            },
            'Meeting Notes': {
                topic: 'Admin',
                timestamp: Date.now() - 86400000 * 7,
                lastActivity: Date.now() - 86400000 * 6,
                messages: [
                    {text: "Summary of our discussion about the empirical evidence section. We agreed to focus on three main areas: semantic embeddings, transformer architectures, and predictive processing research.", timestamp: Date.now() - 86400000 * 7, user: 'supervisor@example.com'},
                    {text: 'I\'ll start working on the semantic embeddings analysis this week.', timestamp: Date.now() - 86400000 * 6, user: 'you@example.com'}
                ]
            }
        };

        // LocalStorage keys
        const COMMENTS_KEY = 'doc_comments';
        const READ_STATUS_KEY = 'thread_read_status_' + userEmail.replace('@', '_').replace('.', '_');

        // Document metadata
        const categoryMap = {
            "core": "Core Theory",
            "evidence": "Evidence",
            "references": "References"
        };
        
        const statusColors = {
            "developing": "#28a745",
            "draft": "#ffc107", 
            "stable": "#0066cc"
        };
        
        const docs = [
            {title: "Pattern Recognition Identity", slug: "pattern-recognition-identity", category: "core", lenses: "philosophy cognition", status: "developing"},
            {title: "Empirical Evidence Review", slug: "empirical-evidence", category: "evidence", lenses: "cognition cs-math", status: "draft"},
            {title: "Related Work", slug: "related-work", category: "references", lenses: "philosophy", status: "stable"}
        ];

        // Utility functions
        function slugify(str) {
            return str.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
        }

        function parseFrontmatter(text) {
            if (!text.startsWith('---')) return {meta: {}, content: text};
            const end = text.indexOf('---', 3);
            if (end === -1) return {meta: {}, content: text};
            const yamlText = text.substring(3, end).trim();
            const meta = {};
            yamlText.split('\n').forEach(line => {
                const colon = line.indexOf(':');
                if (colon > 0) {
                    const key = line.substring(0, colon).trim();
                    let val = line.substring(colon + 1).trim();
                    if (val.startsWith('[')) {
                        try {
                            val = JSON.parse(val.replace(/'/g, '"'));
                        } catch {
                            val = val.replace(/[\[\]"]/g, '').split(',').map(s => s.trim());
                        }
                    } else if (val.startsWith('"')) {
                        val = val.replace(/"/g, '');
                    }
                    meta[key] = val;
                }
            });
            const content = text.substring(end + 3).trim();
            return {meta, content};
        }

        // Comment management
        function getStoredComments() {
            const stored = localStorage.getItem(COMMENTS_KEY);
            return stored ? JSON.parse(stored) : {};
        }

        function saveComments(comments) {
            localStorage.setItem(COMMENTS_KEY, JSON.stringify(comments));
        }

        // Read status management - FIXED
        function getReadStatus() {
            const stored = localStorage.getItem(READ_STATUS_KEY);
            return stored ? JSON.parse(stored) : {};
        }

        function saveReadStatus(status) {
            localStorage.setItem(READ_STATUS_KEY, JSON.stringify(status));
        }

        function markThreadAsRead(subject) {
            const status = getReadStatus();
            status[subject] = Date.now();
            saveReadStatus(status);
            
            // Remove NEW pill immediately
            const threadElem = [...document.querySelectorAll('.message-thread')].find(t => 
                t.querySelector('.pill-subject')?.textContent === subject
            );
            if (threadElem) {
                const newPill = threadElem.querySelector('.pill-new');
                if (newPill) {
                    newPill.remove();
                }
            }
        }

        function isThreadNew(subject) {
            const threadData = threads[subject];
            if (!threadData) return false;
            
            const readStatus = getReadStatus();
            const lastReadTime = readStatus[subject] || 0;
            const lastActivity = threadData.lastActivity || threadData.timestamp;
            
            return lastActivity > lastReadTime;
        }

        // Build left panel
        // Add this new function to load a manifest of markdown docs from /content/manifest.json
        async function loadMarkdownManifest() {
            try {
                const res = await fetch('/content/manifest.json');
                const docsFromManifest = await res.json(); // Expected to be an array of objects with at least: { title, slug, category, lenses, status }
                return docsFromManifest;
            } catch (err) {
                console.error('Error loading markdown manifest:', err);
                return [];
            }
        }

        // Replace your buildLeftPanel() function with this version that loads the manifest dynamically.
        // New function to load documents from documents.json
async function loadDocuments() {
    try {
        // Note the updated path: /data/documents.json
        const res = await fetch('/data/documents.json');
        const data = await res.json();
        // Return an array of document objects from the "documents" property.
        return Object.values(data.documents || {});
    } catch (err) {
        console.error('Error loading documents.json:', err);
        return [];
    }
}

// Updated buildLeftPanel that groups documents by frontmatter.category
async function buildLeftPanel() {
    const leftPanel = document.querySelector('.left-panel');
    // Remove any existing categories (leaving lens tabs intact)
    leftPanel.querySelectorAll('.doc-category').forEach(cat => cat.remove());
    
    const docsArray = await loadDocuments();
    // Group docs by frontmatter.category; default to 'uncategorized'
    const categories = {};
    docsArray.forEach(doc => {
        const cat = (doc.frontmatter && doc.frontmatter.category) ? doc.frontmatter.category : 'uncategorized';
        categories[cat] = categories[cat] || [];
        categories[cat].push(doc);
    });
    
    // For each category, create a section in the left panel
    Object.keys(categories).sort().forEach(cat => {
        const categoryDiv = document.createElement('div');
        categoryDiv.className = 'doc-category';
        
        const h3 = document.createElement('h3');
        h3.textContent = cat.toUpperCase();
        categoryDiv.appendChild(h3);
        
        const docsDiv = document.createElement('div');
        docsDiv.id = cat + '-docs';
        
        categories[cat].forEach(doc => {
            const item = document.createElement('div');
            item.className = 'document-item';
            // Use only the document from loadDocuments(), not the local fallback
            item.dataset.id = doc.id;
            item.dataset.lenses = doc.lens ? doc.lens.join(' ') : '';
            item.innerHTML = `
                <div>${doc.frontmatter.title}</div>
                <span style="font-size: 11px; color: #6c757d;">‚óè ${doc.status}</span>
            `;
            docsDiv.appendChild(item);
    
            // Pass the entire doc object to loadDocContent
            item.addEventListener('click', () => {
                document.querySelectorAll('.document-item, .message-thread').forEach(i => i.classList.remove('active'));
                item.classList.add('active');
                loadDocContent(doc);
            });
        });
            
            item.addEventListener('click', () => {
                document.querySelectorAll('.document-item, .message-thread').forEach(i => i.classList.remove('active'));
                item.classList.add('active');
                // Use the document id to fetch the markdown file from the content folder
                loadDocContent(doc.frontmatter.title, doc.id);
            });
        });
        
        categoryDiv.appendChild(docsDiv);
        leftPanel.appendChild(categoryDiv);
    });
    
    // Optionally load the first document automatically, if any exist:
    const firstItem = document.querySelector('.document-item');
    if (firstItem) firstItem.click();
}

        // Initialize topic filters
        function initTopicFilters() {
            const filters = document.getElementById('topic-filters');
            filters.innerHTML = '';
            
            const allPill = document.createElement('span');
            allPill.className = 'topic-pill active';
            allPill.textContent = 'All';
            allPill.dataset.topic = 'all';
            filters.appendChild(allPill);

            const uniqueTopics = new Set(Object.values(threads).map(t => t.topic));
            uniqueTopics.forEach(topic => {
                const pill = document.createElement('span');
                pill.className = 'topic-pill';
                pill.textContent = topic;
                pill.dataset.topic = topic;
                filters.appendChild(pill);
            });

            // Add click listeners
            filters.querySelectorAll('.topic-pill').forEach(pill => {
                pill.addEventListener('click', () => {
                    filters.querySelectorAll('.topic-pill').forEach(p => p.classList.remove('active'));
                    pill.classList.add('active');
                    const selected = pill.dataset.topic;
                    document.querySelectorAll('.message-thread').forEach(thread => {
                        thread.style.display = (selected === 'all' || thread.dataset.topic === selected) ? 'block' : 'none';
                    });
                });
            });
        }

        // Build thread list
        function buildThreadList() {
            const messagesList = document.getElementById('messages-list');
            messagesList.innerHTML = '';

            Object.keys(threads).forEach(subject => {
                const data = threads[subject];
                const threadElem = document.createElement('div');
                threadElem.className = 'message-thread';
                threadElem.dataset.topic = data.topic;
                
                const repliesCount = data.messages.length - 1;
                const lastActivity = new Date(data.lastActivity || data.timestamp);
                const isNew = isThreadNew(subject);
                
                threadElem.innerHTML = `
                    <div class="message-pills">
                        <span class="pill pill-subject">${subject}</span>
                        <span class="pill pill-topic">${data.topic}</span>
                        <span class="pill pill-date">${new Date(data.timestamp).toLocaleDateString()}</span>
                        ${isNew ? '<span class="pill pill-new">new</span>' : ''}
                    </div>
                    <div class="message-preview">${data.messages[0].text.substring(0, 100)}${data.messages[0].text.length > 100 ? '...' : ''}</div>
                    <div class="message-replies">${repliesCount} repl${repliesCount === 1 ? 'y' : 'ies'} ¬∑ Last: ${lastActivity.toLocaleString()}</div>
                `;
                
                messagesList.appendChild(threadElem);
            });

            attachThreadListeners();
        }

        // FIXED: Load document content properly
        async function loadDocContent(doc) {
            try {
                // Use the pre-built fullContent from documents.json if available
                let text = doc.fullContent;
                if (!text) {
                    // Fallback if fullContent is missing (this may fetch index.html on Cloudflare Pages)
                    const res = await fetch(`/content/${doc.id}`);
                    text = await res.text();
                }
                const { meta, content } = parseFrontmatter(text);
                    
                // Convert markdown content to HTML.
                // For simplicity, we'll only wrap paragraphs that aren't headings.
                let html = `<div style="max-width: 700px;">`;
                const lines = content.split('\n');
                let inParagraph = false;
                let paragraphIndex = 0;
                
                lines.forEach(line => {
                    line = line.trim();
                    if (!line) {
                        if (inParagraph) { 
                            html += '</p>'; 
                            inParagraph = false; 
                        }
                        return;
                    }
                    if (line.startsWith('# ')) {
                        if (inParagraph) { 
                            html += '</p>'; 
                            inParagraph = false; 
                        }
                        html += `<h1>${line.substring(2)}</h1>`;
                    } else if (line.startsWith('## ')) {
                        if (inParagraph) { 
                            html += '</p>'; 
                            inParagraph = false; 
                        }
                        html += `<h2>${line.substring(3)}</h2>`;
                    } else if (line.startsWith('### ')) {
                        if (inParagraph) {
                            html += '</p>';
                            inParagraph = false;
                        }
                        html += `<h3>${line.substring(4)}</h3>`;
                    } else {
                        if (!inParagraph) {
                            html += `<p class="commentable" data-para-index="${paragraphIndex}">`;
                            inParagraph = true;
                            paragraphIndex++;
                        } else {
                            html += ' ';
                        }
                        html += line;
                    }
                });
                if (inParagraph) html += '</p>';
                html += '</div>';
                
                // Optionally prepend metadata from YAML frontmatter
                let metaHtml = '';
                if (meta && Object.keys(meta).length) {
                    metaHtml = '<div style="font-size:12px; color:#666; margin-bottom:10px;">';
                    Object.keys(meta).forEach(key => {
                        metaHtml += `<strong>${key}:</strong> ${meta[key]} &nbsp;&nbsp;`;
                    });
                    metaHtml += '</div>';
                }
                
                document.getElementById('center-panel').innerHTML = metaHtml + html;
                restoreComments(doc.frontmatter.title);
                attachCommentListeners();
            } catch (e) {
                console.error('Error loading document:', e);
                document.getElementById('center-panel').innerHTML = `<div style="max-width: 700px;"><h2>${doc.frontmatter.title}</h2><p style="color: #dc3545;">Error loading document: ${e.message}</p></div>`;
            }
        }

        // Replace the restoreComments() part with the updated code below
        function restoreComments(title) {
            const comments = getStoredComments()[title];
            if (!comments) return;
            Object.keys(comments).forEach(paraIndex => {
                const paragraph = document.querySelector(`[data-para-index="${paraIndex}"]`);
                if (!paragraph) return;
                comments[paraIndex].forEach(comment => {
                    const commentSpan = document.createElement('span');
                    commentSpan.className = 'comment-marker';
                    commentSpan.dataset.commentId = comment.timestamp;
                    commentSpan.style.marginLeft = '5px';
                    commentSpan.style.cursor = 'pointer';
            
                    const iconSpan = document.createElement('span');
                    iconSpan.textContent = comment.marker;
                    iconSpan.style.fontWeight = 'bold';
            
                    // Create excerpt from stored text (first 5‚Äì7 words)
                    let excerpt = '';
                    if (comment.text && comment.text.trim()) {
                        const words = comment.text.trim().split(' ');
                        excerpt = words.slice(0, Math.min(7, words.length)).join(' ');
                    }
                    const excerptSpan = document.createElement('span');
                    excerptSpan.style.fontSize = '0.8em';
                    excerptSpan.style.marginLeft = '3px';
                    if (comment.marker === '‚úì') {
                        excerptSpan.style.background = 'rgba(244,236,221,0.8)';
                        excerptSpan.style.borderRadius = '4px';
                        excerptSpan.style.padding = '1px 3px';
                    }
                    excerptSpan.textContent = excerpt;
            
                    commentSpan.appendChild(iconSpan);
                    commentSpan.appendChild(excerptSpan);
            
                    const tooltip = document.createElement('div');
                    tooltip.className = 'comment-tooltip';
                    tooltip.style.fontSize = '10px';
                    tooltip.style.marginTop = '4px';
                    const dateStr = new Date(comment.timestamp).toLocaleDateString();
                    tooltip.innerHTML = `<button onclick="editComment(${comment.timestamp})" style="margin-right: 5px;">Edit</button>
                                        <button onclick="deleteComment(${comment.timestamp})">Delete</button>
                                        <div style="font-size:11px; opacity:0.8;">By ${comment.user} on ${dateStr}</div>`;
            
                    commentSpan.appendChild(tooltip);
                    paragraph.appendChild(commentSpan);
                });
            });
        }

        // Load thread content
        function loadThreadContent(subject) {
            const data = threads[subject];
            if (!data) return;

            let html = `
                <div style="max-width: 700px;">
                    <h2>${subject}</h2>
                    <div class="thread-messages">
            `;
            
            data.messages.forEach(msg => {
                const dateStr = new Date(msg.timestamp).toLocaleString();
                const isCurrentUser = msg.user === userEmail;
                html += `
                    <div class="thread-message" style="${isCurrentUser ? 'margin-left: 20px; background: #e7f3ff;' : ''}">
                        <p>${msg.text}</p>
                        <small style="color: #6c757d;">By ${msg.user} at ${dateStr}</small>
                    </div>
                `;
            });
            
            html += `
                    </div>
                    <div class="reply-form">
                        <textarea id="reply-text" placeholder="Add a reply..."></textarea>
                        <button onclick="addReply('${subject}')">Reply</button>
                    </div>
                </div>
            `;
            
            const center = document.getElementById('center-panel');
            center.innerHTML = html;
        }

        // Add reply
        function addReply(subject) {
            const textarea = document.getElementById('reply-text');
            const text = textarea.value.trim();
            if (!text) return;

            const now = Date.now();
            const data = threads[subject];
            
            data.messages.push({
                text: text,
                timestamp: now,
                user: userEmail
            });
            
            data.lastActivity = now;
            textarea.value = '';
            
            loadThreadContent(subject);
            buildThreadList(); // Rebuild to update previews
        }

        // Lens tab switching
        document.querySelectorAll('.lens-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.lens-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                const lens = tab.dataset.lens;
                document.querySelectorAll('.document-item').forEach(doc => {
                    const lenses = doc.dataset.lenses.split(' ');
                    doc.style.display = (lens === 'all' || lenses.includes(lens)) ? 'block' : 'none';
                });
            });
        });

        // Comment functionality
        // Replace the attachCommentListeners() function with the following:
        function attachCommentListeners() {
            // Add a mouseup listener to each commentable paragraph
            document.querySelectorAll('.commentable').forEach(p => {
                p.style.cursor = 'text';
                // Remove existing mouseup listeners if needed
                p.removeEventListener('mouseup', commentableMouseUpHandler);
                p.addEventListener('mouseup', commentableMouseUpHandler);
            });
        }

        function commentableMouseUpHandler(e) {
            const selection = window.getSelection();
            if (!selection.isCollapsed && selection.toString().trim().length > 0) {
                // Only show menu if selection is inside a commentable element.
                const range = selection.getRangeAt(0);
                if (!this.contains(range.commonAncestorContainer)) return;
                const rect = range.getBoundingClientRect();
                const menu = document.getElementById('comment-menu');
                menu.style.left = (rect.left + window.scrollX) + 'px';
                menu.style.top = (rect.bottom + window.scrollY) + 'px';
                menu.classList.add('show');
                // Store the current selection range for later use.
                menu.selectionRange = range;
            }
        }
        function initializeCommentSystem() {
            attachCommentListeners();
        }

        async function init() {
            await buildLeftPanel();
            initTopicFilters();
            buildThreadList();
            initializeCommentSystem(); // Initialize comment system
        }

        function showCommentMenu(e) {
            // Prevent the menu from showing if the dialog is already open
            const dialog = document.getElementById('comment-dialog');
            if (dialog.classList.contains('show')) {
                return;
            }
            e.stopPropagation();
            const menu = document.getElementById('comment-menu');
            menu.style.left = e.pageX + 'px';
            menu.style.top = e.pageY + 'px';
            menu.classList.add('show');
            menu.targetElement = e.target;
        }

        document.addEventListener('click', () => {
            document.getElementById('comment-menu').classList.remove('show');
        });

        document.addEventListener('DOMContentLoaded', function() {
            init();
        });

        // Comment dialog state
        let currentCommentTarget = null;
        let currentCommentType = '';

        // Handle comment selection
        // Replace the comment-option click handler with the following:
        document.querySelectorAll('.comment-option').forEach(option => {
            option.addEventListener('click', (e) => {
                e.stopPropagation();
                const type = option.dataset.type;
                const menu = document.getElementById('comment-menu');
                const range = menu.selectionRange;
                if (!range) return;
                // Determine highlight color based on type.
                let highlightColor = '';
                let marker = '';
                if (type === 'question') { 
                    highlightColor = 'rgba(255, 0, 0, 0.3)'; // red
                    marker = '?';
                } else if (type === 'clarification') {
                    highlightColor = 'rgba(255, 255, 0, 0.3)'; // yellow
                    marker = '!';
                } else if (type === 'approved') {
                    highlightColor = 'rgba(0, 255, 0, 0.3)'; // green
                    marker = '‚úì';
                }
                // Wrap the selected text with a span.
                const commentSpan = document.createElement('span');
                commentSpan.className = 'comment-marker';
                const now = Date.now();
                commentSpan.dataset.commentId = now;
                commentSpan.style.backgroundColor = highlightColor;
                // Create a small icon (the marker) that stays visible.
                const iconSpan = document.createElement('span');
                iconSpan.textContent = marker;
                iconSpan.style.fontWeight = 'bold';
                // For the tooltip, show edit/delete and metadata on mouse-over.
                const tooltip = document.createElement('div');
                tooltip.className = 'comment-tooltip';
                tooltip.style.fontSize = '10px';
                tooltip.style.marginTop = '4px';
                const dateStr = new Date(now).toLocaleDateString();
                tooltip.innerHTML = `<button onclick="editComment(${now})" style="margin-right:5px;">Edit</button>
                                    <button onclick="deleteComment(${now})">Delete</button>
                                    <div style="font-size:11px; opacity:0.8;">By ${userEmail} on ${dateStr}</div>`;
                commentSpan.appendChild(iconSpan);
                // Move the selected text into our span.
                try {
                    commentSpan.appendChild(range.extractContents());
                    range.insertNode(commentSpan);
                } catch(err) {
                    console.error('Error wrapping selection:', err);
                }
                // Optionally, save comment data (using your existing storage functions)
                // Determine the paragraph target from the selection.
                let p = commentSpan.closest('.commentable');
                if (p) {
                    const paraIndex = p.dataset.paraIndex;
                    const titleElement = document.querySelector('#center-panel h1, #center-panel h2');
                    if (titleElement && paraIndex !== undefined) {
                        const title = titleElement.textContent;
                        const comments = getStoredComments();
                        comments[title] = comments[title] || {};
                        comments[title][paraIndex] = comments[title][paraIndex] || [];
                        comments[title][paraIndex].push({
                            marker: marker,
                            text: commentSpan.innerText,
                            user: userEmail,
                            timestamp: now
                        });
                        saveComments(comments);
                        // Optionally call saveCommentToMarkdown(...)
                    }
                }
                menu.classList.remove('show');
                window.getSelection().removeAllRanges();
            });
        });

        function showCommentDialog(type) {
            const dialog = document.getElementById('comment-dialog');
            const title = document.getElementById('comment-dialog-title');
            const label = document.getElementById('comment-dialog-label');
            const textarea = document.getElementById('comment-dialog-text');

            if (type === 'question') {
                title.textContent = 'Ask Question';
                label.textContent = 'Question text:';
                textarea.placeholder = 'What would you like to clarify or ask about this section?';
            } else if (type === 'clarification') {
                title.textContent = 'Request Clarification';
                label.textContent = 'Clarification needed:';
                textarea.placeholder = 'What needs to be clarified or expanded in this section?';
            }

            textarea.value = '';
            dialog.classList.add('show');
            dialog.style.display = 'block';  // SHOW the dialog
            textarea.focus();
        }

        function hideCommentDialog() {
            const dialog = document.getElementById('comment-dialog');
            dialog.classList.remove('show');
            dialog.style.display = 'none';  // HIDE the dialog
            currentCommentTarget = null;
            currentCommentType = '';
        }

        function submitComment() {
            const textarea = document.getElementById('comment-dialog-text');
            const text = textarea.value.trim();
            
            if (!text && (currentCommentType === 'question' || currentCommentType === 'clarification')) {
                alert('Please enter comment text');
                return;
            }

            let marker = '';
            if (currentCommentType === 'question') marker = '?';
            else if (currentCommentType === 'clarification') marker = '!';

            addComment(text, marker);
            hideCommentDialog();
        }
        
        // ...code for editing comments

        // Global variable to track if a comment is being edited
        let currentEditingInfo = null;

        function editComment(commentTimestamp) {
            const titleElement = document.querySelector('#center-panel h1, #center-panel h2');
            if (!titleElement) {
                console.error('Cannot find document title');
                return;
            }
            const title = titleElement.textContent;
            const commentsData = getStoredComments();
            if (!commentsData[title]) {
                console.error('No comments for this document');
                return;
            }
            let found = false;
            for (const paraIndex in commentsData[title]) {
                const commentsArr = commentsData[title][paraIndex];
                for (let i = 0; i < commentsArr.length; i++) {
                    if (commentsArr[i].timestamp == commentTimestamp) {
                        // Set up editing state with necessary info
                        currentEditingInfo = {
                            title: title,
                            paraIndex: paraIndex,
                            commentIndex: i,
                            marker: commentsArr[i].marker,
                            originalText: commentsArr[i].text,
                            // Store reference to the comment marker element in the DOM
                            domElement: document.querySelector(`[data-comment-id="${commentTimestamp}"]`)
                        };
                        found = true;
                        break;
                    }
                }
                if (found) break;
            }
            if (!found) {
                console.error('Comment not found for editing');
                return;
            }
            
            // Open the dialog prefilled for editing
            const dialog = document.getElementById('comment-dialog');
            const dlgTitle = document.getElementById('comment-dialog-title');
            const label = document.getElementById('comment-dialog-label');
            const textarea = document.getElementById('comment-dialog-text');
            
            dlgTitle.textContent = 'Edit Comment';
            label.textContent = 'Edit your comment:';
            textarea.value = currentEditingInfo.originalText;
            
            dialog.style.display = 'block';
            dialog.classList.add('show');
            textarea.focus();
        }

        function deleteComment(commentTimestamp) {
            const titleElement = document.querySelector('#center-panel h1, #center-panel h2');
            if (!titleElement) {
                console.error('Cannot find document title');
                return;
            }
            const title = titleElement.textContent;
            const commentsData = getStoredComments();
            if (!commentsData[title]) {
                console.error('No comments for this document');
                return;
            }
            let found = false;
            for (const paraIndex in commentsData[title]) {
                const commentsArr = commentsData[title][paraIndex];
                for (let i = 0; i < commentsArr.length; i++) {
                    if (commentsArr[i].timestamp == commentTimestamp) {
                        // Remove the comment entry from storage
                        commentsArr.splice(i, 1);
                        if (commentsArr.length === 0) {
                            delete commentsData[title][paraIndex];
                        }
                        found = true;
                        break;
                    }
                }
                if (found) break;
            }
            if (!found) {
                console.error('Comment not found for deletion');
                return;
            }
            saveComments(commentsData);    
            // Remove the comment element from the DOM
            const domElem = document.querySelector(`[data-comment-id="${commentTimestamp}"]`);
            if (domElem) {
                domElem.remove();
            }
        }

        function submitComment() {
            const textarea = document.getElementById('comment-dialog-text');
            const newText = textarea.value.trim();
            
            // If editing, update the comment
            if (currentEditingInfo) {
                if (!newText) {
                    alert('Please enter comment text');
                    return;
                }
                const title = currentEditingInfo.title;
                const paraIndex = currentEditingInfo.paraIndex;
                const commentIndex = currentEditingInfo.commentIndex;
                const commentsData = getStoredComments();
                if (!commentsData[title] || !commentsData[title][paraIndex] || !commentsData[title][paraIndex][commentIndex]) {
                    console.error('Stored comment not found for editing');
                } else {
                    // Update comment text and saving date (timestamp)
                    const newTimestamp = Date.now();
                    commentsData[title][paraIndex][commentIndex].text = newText;
                    commentsData[title][paraIndex][commentIndex].timestamp = newTimestamp;
                    saveComments(commentsData);
                    
                    // Update the DOM element display
                    const domElem = currentEditingInfo.domElement;
                    if (domElem) {
                        const displayText = newText.length > 20 ? newText.substring(0, 20) + '...' : newText;
                        domElem.firstChild.textContent = ` [${currentEditingInfo.marker}${displayText ? ' ' + displayText : ''}]`;
                        // Update the tooltip content (author, date, buttons)
                        const tooltip = domElem.querySelector('.comment-tooltip');
                        if (tooltip) {
                            const commentType = currentEditingInfo.marker === '?' ?
                                'Question' : currentEditingInfo.marker === '!' ?
                                'Clarification' : 'Approved';
                            const newDateStr = new Date(newTimestamp).toLocaleString();
                            tooltip.innerHTML = `<div><strong>${commentType}</strong></div>
                                <div style="margin: 4px 0;">${newText}</div>
                                <div style="font-size: 11px; opacity: 0.8;">By ${userEmail}<br>${newDateStr}</div>
                                <div style="margin-top: 5px; font-size: 10px;">
                                    <button onclick="editComment(${newTimestamp})" style="margin-right: 5px;">Edit</button>
                                    <button onclick="deleteComment(${newTimestamp})">Delete</button>
                                </div>`;
                            // Also update the element's data attribute so future calls work with the new timestamp.
                            domElem.dataset.commentId = newTimestamp;
                        }
                    }
                }
                currentEditingInfo = null;
                hideCommentDialog();
                return;
            }

            // For new comments, ensure text is provided when needed
            if ((currentCommentType === 'question' || currentCommentType === 'clarification') && !newText) {
                alert('Please enter comment text');
                return;
            }
            let marker = '';
            if (currentCommentType === 'question') marker = '?';
            else if (currentCommentType === 'clarification') marker = '!';
            addComment(newText, marker);
            hideCommentDialog();
        }

        // In addComment, ensure you set a custom data attribute so we can find the comment later:
        // Replace the existing addComment() function with the one below
        function addComment(text, marker) {
            try {
                if (!currentCommentTarget) {
                    console.error('No comment target selected');
                    return;
                }
                if (!document.contains(currentCommentTarget)) {
                    console.error('Comment target is no longer in the DOM');
                    return;
                }
                const now = Date.now();
                // Only show the date (no hour)
                const dateStr = new Date(now).toLocaleDateString();
                const commentSpan = document.createElement('span');
                commentSpan.className = 'comment-marker';
                commentSpan.dataset.commentId = now;
                commentSpan.style.marginLeft = '5px';
                commentSpan.style.cursor = 'pointer';
                
                // Create an icon element
                const iconSpan = document.createElement('span');
                iconSpan.textContent = marker;
                iconSpan.style.fontWeight = 'bold';
                
                // Create an excerpt from the comment text (first 5‚Äì7 words)
                let excerpt = '';
                if (text && text.trim()) {
                    const words = text.trim().split(' ');
                    excerpt = words.slice(0, Math.min(7, words.length)).join(' ');
                }
                const excerptSpan = document.createElement('span');
                excerptSpan.style.fontSize = '0.8em';
                excerptSpan.style.marginLeft = '3px';
                // For approved comments, use a very light sepia background with rounded corners
                if (marker === '‚úì') {
                    excerptSpan.style.background = 'rgba(244,236,221,0.8)';
                    excerptSpan.style.borderRadius = '4px';
                    excerptSpan.style.padding = '1px 3px';
                }
                excerptSpan.textContent = excerpt ? excerpt : '';
            
                // Assemble the marker (icon + excerpt)
                commentSpan.appendChild(iconSpan);
                commentSpan.appendChild(excerptSpan);
            
                // Create a tooltip with edit and delete buttons and metadata
                const tooltip = document.createElement('div');
                tooltip.className = 'comment-tooltip';
                tooltip.style.fontSize = '10px';
                tooltip.style.marginTop = '4px';
                // No hour, only date is shown
                tooltip.innerHTML = `<button onclick="editComment(${now})" style="margin-right: 5px;">Edit</button>
                                    <button onclick="deleteComment(${now})">Delete</button>
                                    <div style="font-size:11px; opacity:0.8;">By ${userEmail} on ${dateStr}</div>`;
                // Append tooltip (it may be hidden via CSS until hover)
                commentSpan.appendChild(tooltip);
            
                currentCommentTarget.appendChild(commentSpan);
            
                // Save the comment into storage (unchanged)
                const titleElement = document.querySelector('#center-panel h1, #center-panel h2');
                if (!titleElement) {
                    console.error('Could not find document title');
                    return;
                }
                const title = titleElement.textContent;
                const paraIndex = currentCommentTarget.dataset.paraIndex;
                if (paraIndex === undefined) {
                    console.error('Paragraph index not found on target element');
                    return;
                }
                const comments = getStoredComments();
                comments[title] = comments[title] || {};
                comments[title][paraIndex] = comments[title][paraIndex] || [];
                comments[title][paraIndex].push({
                    marker: marker === '?' ? '?' : marker === '!' ? '!' : '‚úì',
                    text: text || '',
                    user: userEmail,
                    timestamp: now
                });
                saveComments(comments);
                // Optionally, save as markdown:
                saveCommentToMarkdown(title, paraIndex, marker === '?' ? '?' : marker === '!' ? '!' : '‚úì', text || '', userEmail, now);
            } catch (error) {
                console.error('Error adding comment:', error);
                alert('Failed to add comment. Please try again.');
            }
        }

        // ...edit comment up to here



        function saveCommentToMarkdown(docTitle, paraIndex, prefix, text, user, timestamp) {
            const slug = slugify(docTitle);
            const filename = `${slug}.md`;
            
            // Format the markdown comment
            const mdComment = text ? 
                `<!-- ${prefix} ${text} | ${user} | ${timestamp} -->` :
                `<!-- ${prefix} | ${user} | ${timestamp} -->`;
            
            console.log(`üìù SAVE TO FILE: /content/${filename}`);
            console.log(`üìç LOCATION: After paragraph ${paraIndex}`);
            console.log(`üí¨ COMMENT: ${mdComment}`);
            console.log(`---`);
            
            // In a real implementation, this would make an API call:
            // fetch('/api/save-comment', {
            //     method: 'POST',
            //     headers: { 'Content-Type': 'application/json' },
            //     body: JSON.stringify({ filename, paraIndex, comment: mdComment })
            // });
        }

        // Thread selection handling - FIXED
        function attachThreadListeners() {
            document.querySelectorAll('.message-thread').forEach(thread => {
                thread.addEventListener('click', () => {
                    document.querySelectorAll('.document-item, .message-thread').forEach(i => i.classList.remove('active'));
                    thread.classList.add('active');
                    
                    const subject = thread.querySelector('.pill-subject').textContent;
                    loadThreadContent(subject);
                    
                    // Mark as read immediately
                    markThreadAsRead(subject);
                });
            });
        }

        // Modal functions
        function showOverview() {
            document.getElementById('overview-modal').classList.add('show');
        }

        function hideOverview() {
            document.getElementById('overview-modal').classList.remove('show');
        }

        // Thread form functions
        function showNewThreadForm() {
            document.getElementById('new-thread-form').classList.add('show');
        }

        function hideNewThreadForm() {
            document.getElementById('new-thread-form').classList.remove('show');
            // Clear form
            document.getElementById('thread-subject').value = '';
            document.getElementById('thread-topic').value = '';
            document.getElementById('thread-message').value = '';
        }

        function createThread() {
            const subject = document.getElementById('thread-subject').value.trim();
            const topic = document.getElementById('thread-topic').value.trim();
            const message = document.getElementById('thread-message').value.trim();
            
            if (!subject || !topic || !message) {
                alert('Please fill in all fields');
                return;
            }

            const now = Date.now();

            // Add to threads data
            threads[subject] = {
                topic: topic,
                timestamp: now,
                lastActivity: now,
                messages: [{
                    text: message,
                    timestamp: now,
                    user: userEmail
                }]
            };

            // Mark as read for creator
            markThreadAsRead(subject);

            // Rebuild interface
            buildThreadList();
            initTopicFilters();

            hideNewThreadForm();
        }

        // Initialize everything
        async function init() {
        await buildLeftPanel();
        initTopicFilters();
        buildThreadList();
        initializeCommentSystem(); // Initialize comment system
    }

        // Start the application only after DOM is fully loaded
        document.addEventListener('DOMContentLoaded', async function() {
            await init();
            const dialog = document.getElementById('comment-dialog');
            if (dialog) {
                dialog.addEventListener('click', function(e) {
                    // Prevent clicks inside the dialog from propagating to show the comment menu.
                    e.stopPropagation();
                });
            }
        });
    </script>
    <div id="comment-dialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
         background: white; border: 1px solid #dee2e6; border-radius: 4px; padding: 20px; z-index: 3000;">
        <h3 id="comment-dialog-title">Comment</h3>
        <label id="comment-dialog-label" for="comment-dialog-text"></label>
        <textarea id="comment-dialog-text" style="width: 100%; min-height: 80px; margin-top: 10px;"></textarea>
        <div style="margin-top: 10px; text-align: right;">
            <button onclick="hideCommentDialog()" style="margin-right: 10px;">Cancel</button>
            <button onclick="submitComment()">Submit</button>
        </div>
    </div>
</body>
</html>