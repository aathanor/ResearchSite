<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pattern Constellations</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
       
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            color: #333333;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
       
        /* Header */
        .header {
            background: #f8f9fa;
            border-bottom: 2px solid #dee2e6;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
       
        .header h1 {
            font-size: 18px;
            color: #495057;
        }
       
        .header-actions {
            display: flex;
            gap: 15px;
        }
       
        .btn-overview {
            padding: 8px 16px;
            background: #0066cc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
       
        .btn-overview:hover {
            background: #0052a3;
        }
       
        /* Main layout */
        .main-container {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
       
        /* Left panel - Documents */
        .left-panel {
            width: 25%;
            background: #f8f9fa;
            border-right: 1px solid #dee2e6;
            overflow-y: auto;
            padding: 15px;
        }
       
        .lens-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
            border-bottom: 1px solid #dee2e6;
        }
       
        .lens-tab {
            padding: 8px 12px;
            background: transparent;
            border: none;
            cursor: pointer;
            color: #6c757d;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }
       
        .lens-tab.active {
            color: #0066cc;
            border-bottom-color: #0066cc;
        }
       
        .doc-category {
            margin-bottom: 20px;
        }
       
        .doc-category h3 {
            font-size: 12px;
            text-transform: uppercase;
            color: #6c757d;
            margin-bottom: 8px;
            font-weight: 600;
        }
       
        .document-item {
            background: white;
            padding: 10px;
            margin-bottom: 5px;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid transparent;
            transition: all 0.2s;
        }
       
        .document-item:hover {
            border-color: #0066cc;
        }
       
        .document-item.active {
            background: #e7f3ff;
            border-color: #0066cc;
        }
       
        /* Center - Main content */
        .center-panel {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            background: white;
            position: relative;
        }
       
        /* Right panel - Messages */
        .right-panel {
            width: 30%;
            background: #f8f9fa;
            border-left: 1px solid #dee2e6;
            display: flex;
            flex-direction: column;
        }
       
        .messages-header {
            padding: 15px;
            background: white;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
       
        .messages-header h3 {
            font-size: 14px;
            font-weight: 600;
            color: #495057;
        }
       
        .new-thread-btn {
            padding: 6px 12px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
       
        .topic-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 10px 15px;
            border-bottom: 1px solid #dee2e6;
        }
       
        .topic-pill {
            padding: 4px 10px;
            background: #f0f0f0;
            color: #666;
            border-radius: 12px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
       
        .topic-pill.active {
            background: #0066cc;
            color: white;
        }
       
        .messages-list {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }
       
        .message-thread {
            background: white;
            border-radius: 8px;
            margin-bottom: 10px;
            padding: 12px;
            cursor: pointer;
            border: 1px solid #e9ecef;
            transition: all 0.2s;
        }
       
        .message-thread:hover {
            border-color: #0066cc;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
       
        .message-thread.active {
            background: #e7f3ff;
            border-color: #0066cc;
        }
       
        .message-pills {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }
       
        .pill {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
        }
       
        .pill-subject {
            background: #e7f3ff;
            color: #0066cc;
        }
       
        .pill-topic {
            background: #f0f0f0;
            color: #666;
        }
       
        .pill-date {
            background: #fff3cd;
            color: #856404;
        }
       
        .pill-new {
            background: #dc3545;
            color: white;
        }
       
        .message-preview {
            font-size: 13px;
            color: #6c757d;
            margin-top: 5px;
        }
       
        .message-replies {
            font-size: 11px;
            color: #28a745;
            margin-top: 5px;
            font-weight: 500;
        }
       
        /* Thread view styles */
        .thread-messages {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
       
        .thread-message {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #dee2e6;
        }
       
        .reply-form {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
       
        .reply-form textarea {
            padding: 8px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            resize: vertical;
            min-height: 60px;
        }
       
        .reply-form button {
            align-self: flex-start;
            padding: 6px 12px;
            background: #0066cc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
       
        /* Comment Menu - VERTICAL */
        .comment-menu {
            position: absolute;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 8px;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            min-width: 180px;
        }
       
        .comment-menu.show {
            display: block;
        }
       
        .comment-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.2s;
            font-size: 14px;
            color: #495057;
        }
       
        .comment-option:hover {
            background: #f8f9fa;
        }
       
        .comment-option-icon {
            font-size: 18px;
            width: 24px;
            text-align: center;
        }
       
        .comment-option-text {
            flex: 1;
        }
       
        /* Overview Modal */
        .overview-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
        }
       
        .overview-modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }
       
        .overview-content {
            background: white;
            border-radius: 8px;
            width: 90%;
            height: 80%;
            padding: 30px;
            position: relative;
            overflow: auto;
        }
       
        .overview-close {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 24px;
            cursor: pointer;
            color: #6c757d;
        }
       
        .overview-graph {
            display: flex;
            flex-direction: column;
            gap: 30px;
            margin-top: 20px;
        }
       
        .overview-section {
            border-left: 3px solid #0066cc;
            padding-left: 20px;
        }
       
        .overview-section h3 {
            color: #0066cc;
            margin-bottom: 10px;
        }
       
        .overview-items {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
       
        .overview-item {
            padding: 8px 15px;
            background: #f8f9fa;
            border-radius: 4px;
            font-size: 13px;
            border: 1px solid #dee2e6;
        }
       
        .overview-item.stable {
            background: #d4edda;
            border-color: #28a745;
        }
       
        .overview-item.developing {
            background: #cce5ff;
            border-color: #0066cc;
        }
       
        .overview-item.draft {
            background: #fff3cd;
            border-color: #ffc107;
        }
       
        /* New thread form */
        .new-thread-form {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            z-index: 3000;
            display: none;
            width: 400px;
        }
       
        .new-thread-form.show {
            display: block;
        }
       
        .form-group {
            margin-bottom: 15px;
        }
       
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            color: #495057;
        }
       
        .form-group input, .form-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-size: 14px;
        }
       
        .form-group textarea {
            resize: vertical;
            min-height: 100px;
        }
       
        .form-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
       
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
       
        .btn-primary {
            background: #0066cc;
            color: white;
        }
       
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <h1>Pattern Constellations Research</h1>
        <div class="header-actions">
            <button class="btn-overview" onclick="showOverview()">📊 Project Overview</button>
        </div>
    </div>
   
    <!-- Main container -->
    <div class="main-container">
        <!-- Left Panel - Documents -->
        <div class="left-panel">
            <div class="lens-tabs">
                <button class="lens-tab active" data-lens="all">All</button>
                <button class="lens-tab" data-lens="philosophy">Philosophy</button>
                <button class="lens-tab" data-lens="cognition">Cognition</button>
                <button class="lens-tab" data-lens="cs-math">CS/Math</button>
            </div>
            <!-- Categories will be added dynamically -->
        </div>
       
        <!-- Center - Main content -->
        <div class="center-panel" id="center-panel">
            <div style="max-width: 700px;">
                <div style="text-align: center; padding: 60px; color: #6c757d;">
                    <h2 style="color: #495057; margin-bottom: 10px;">Select a document to begin</h2>
                    <p>Choose a document from the left panel</p>
                </div>
            </div>
        </div>
       
        <!-- Right Panel - Messages -->
        <div class="right-panel">
            <div class="messages-header">
                <h3>Discussion Threads</h3>
                <button class="new-thread-btn" onclick="showNewThreadForm()">+ New Thread</button>
            </div>
            <div class="topic-filters" id="topic-filters">
                <!-- Pills will be added here dynamically -->
            </div>
            <div class="messages-list" id="messages-list">
                <!-- Threads will be added dynamically -->
            </div>
        </div>
    </div>
   
    <!-- Comment Menu - VERTICAL with TEXT -->
    <div class="comment-menu" id="comment-menu">
        <div class="comment-option" data-type="question">
            <span class="comment-option-icon">❓</span>
            <span class="comment-option-text">Ask question</span>
        </div>
        <div class="comment-option" data-type="clarification">
            <span class="comment-option-icon">❗</span>
            <span class="comment-option-text">Needs clarification</span>
        </div>
        <div class="comment-option" data-type="approved">
            <span class="comment-option-icon">✅</span>
            <span class="comment-option-text">Approved / Keep</span>
        </div>
    </div>
   
    <!-- Overview Modal -->
    <div class="overview-modal" id="overview-modal">
        <div class="overview-content">
            <span class="overview-close" onclick="hideOverview()">×</span>
            <h2>Project Overview - Pattern Recognition Identity</h2>
           
            <div class="overview-graph">
                <div class="overview-section">
                    <h3>🎯 Core Theory</h3>
                    <div class="overview-items">
                        <div class="overview-item developing">PRI Main Thesis</div>
                        <div class="overview-item developing">Pattern-Recognition Unity</div>
                        <div class="overview-item draft">Consciousness as Reflexive PR</div>
                    </div>
                </div>
               
                <div class="overview-section">
                    <h3>💡 Problem Dissolutions</h3>
                    <div class="overview-items">
                        <div class="overview-item stable">Hard Problem</div>
                        <div class="overview-item developing">Symbol Grounding</div>
                        <div class="overview-item draft">Quantum Measurement</div>
                        <div class="overview-item draft">Causation Problem</div>
                    </div>
                </div>
               
                <div class="overview-section">
                    <h3>📊 Empirical Evidence</h3>
                    <div class="overview-items">
                        <div class="overview-item developing">Semantic Embeddings</div>
                        <div class="overview-item developing">Rod-Cap Structure</div>
                        <div class="overview-item draft">LLM Analysis</div>
                    </div>
                </div>
               
                <div class="overview-section">
                    <h3>🔗 Connections</h3>
                    <div class="overview-items">
                        <div class="overview-item stable">Eastern Philosophy</div>
                        <div class="overview-item developing">Transformer Architecture</div>
                        <div class="overview-item draft">Hopfield Networks</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
   
    <!-- New Thread Form -->
    <div class="new-thread-form" id="new-thread-form">
        <h3 style="margin-bottom: 20px;">Start New Discussion Thread</h3>
        <div class="form-group">
            <label>Subject</label>
            <input type="text" id="thread-subject" placeholder="Brief topic...">
        </div>
        <div class="form-group">
            <label>Topic Category</label>
            <input type="text" id="thread-topic" placeholder="e.g., Core Theory, Evidence, Questions...">
        </div>
        <div class="form-group">
            <label>Message</label>
            <textarea id="thread-message" placeholder="Your thoughts..."></textarea>
        </div>
        <div class="form-actions">
            <button class="btn btn-secondary" onclick="hideNewThreadForm()">Cancel</button>
            <button class="btn btn-primary" onclick="createThread()">Create Thread</button>
        </div>
    </div>
   
    <script>
        // User email (in real deployment, fetch from API)
        let userEmail = 'you@example.com';
        
        async function fetchUserEmail() {
            try {
                const res = await fetch('/api/user');
                const data = await res.json();
                userEmail = data.email || 'anonymous';
            } catch {
                userEmail = 'anonymous';
            }
        }
        fetchUserEmail();

        // Sample document content
        const documentContent = {
            'pattern-recognition-identity': {
                title: 'Pattern Recognition Identity',
                content: `
# Pattern Recognition Identity

Pattern Recognition Identity (PRI) proposes a radical reconceptualization of consciousness and identity grounded in the fundamental process of pattern recognition.

## Core Thesis

The central thesis of PRI is that what we experience as consciousness, identity, and subjective experience emerges from recursive pattern recognition processes. Rather than consciousness being something that recognizes patterns, consciousness *is* pattern recognition recognizing itself.

## Theoretical Framework

### Primary Principles

1. **Pattern Recognition as Fundamental**: All cognitive processes, from perception to abstract reasoning, operate through pattern recognition mechanisms.

2. **Recursive Self-Recognition**: Consciousness emerges when pattern recognition systems recognize their own pattern recognition processes - a recursive loop of recognition recognizing recognition.

3. **Identity as Pattern Constellation**: Personal identity is not a fixed entity but a dynamic constellation of interconnected patterns that maintain coherence through ongoing pattern recognition processes.

### Implications

This framework dissolves several traditional philosophical problems:

- **The Hard Problem of Consciousness**: Experience is not separate from information processing but emerges from the recursive recognition of pattern recognition itself.

- **The Symbol Grounding Problem**: Symbols ground themselves through pattern recognition processes that connect abstract representations to embodied pattern recognition systems.

- **The Unity of Consciousness**: Unity emerges from the integrative nature of pattern recognition systems that can recognize patterns across multiple domains simultaneously.

## Empirical Connections

Current evidence supporting PRI includes:

- Semantic embedding structures in neural networks mirror conceptual organization in human cognition
- Transformer architectures demonstrate emergent properties through attention mechanisms that resemble recursive pattern recognition
- Neuroscientific evidence for predictive processing and pattern completion in cortical circuits

## Future Directions

Research priorities include:

1. Developing computational models that implement recursive pattern recognition
2. Testing empirical predictions about consciousness and identity
3. Exploring connections to phenomenology and subjective experience
4. Investigating therapeutic applications for understanding mental disorders

*Last updated: [Date]*
                `.trim()
            }
        };

        // Thread data with better timestamp management
        const threads = {
            'Eastern Philosophy Connection': {
                topic: 'Core Theory',
                timestamp: Date.now() - 86400000 * 2,
                lastActivity: Date.now() - 7200000,
                messages: [
                    {text: "I've been thinking about how PRI relates to Buddhist dependent origination. The recursive self-recognition aspect seems to mirror the Buddhist understanding of consciousness as a process rather than a thing.", timestamp: Date.now() - 86400000 * 2, user: 'supervisor@example.com'},
                    {text: 'That\'s a compelling connection. The madhyamaka analysis of dependent origination might provide insights into how pattern recognition avoids the infinite regress problem.', timestamp: Date.now() - 7200000, user: 'you@example.com'},
                    {text: 'Exactly. And the yogācāra school\'s analysis of consciousness (vijñāna) as transformative recognition could be directly relevant to our recursive model.', timestamp: Date.now() - 3600000, user: 'supervisor@example.com'},
                    {text: 'We should explore whether ālaya-vijñāna (store consciousness) maps onto the pattern constellation structure we\'re proposing.', timestamp: Date.now() - 1800000, user: 'you@example.com'}
                ]
            },
            'Symbol Grounding Dissolution': {
                topic: 'Problems',
                timestamp: Date.now() - 86400000 * 3,
                lastActivity: Date.now() - 86400000,
                messages: [
                    {text: "The dissolution seems compelling but I'm not sure about the linguistic aspects. How does pattern recognition ground arbitrary symbols like words?", timestamp: Date.now() - 86400000 * 3, user: 'you@example.com'},
                    {text: 'The key insight is that symbols don\'t need external grounding - they ground through recognition patterns that connect them to embodied recognition systems.', timestamp: Date.now() - 86400000 * 2, user: 'supervisor@example.com'},
                    {text: 'But what about truly abstract concepts that seem divorced from embodied experience?', timestamp: Date.now() - 86400000 * 2, user: 'you@example.com'},
                    {text: 'Even abstract concepts emerge from pattern recognition operating on other patterns. Mathematical concepts, for instance, recognize structural patterns that can exist independently of specific instantiations.', timestamp: Date.now() - 86400000, user: 'supervisor@example.com'},
                    {text: 'So abstraction is pattern recognition operating on increasingly general pattern types rather than specific content?', timestamp: Date.now() - 86400000, user: 'you@example.com'}
                ]
            },
            'Meeting Notes': {
                topic: 'Admin',
                timestamp: Date.now() - 86400000 * 7,
                lastActivity: Date.now() - 86400000 * 6,
                messages: [
                    {text: "Summary of our discussion about the empirical evidence section. We agreed to focus on three main areas: semantic embeddings, transformer architectures, and predictive processing research.", timestamp: Date.now() - 86400000 * 7, user: 'supervisor@example.com'},
                    {text: 'I\'ll start working on the semantic embeddings analysis this week.', timestamp: Date.now() - 86400000 * 6, user: 'you@example.com'}
                ]
            }
        };

        // LocalStorage keys
        const COMMENTS_KEY = 'doc_comments';
        const READ_STATUS_KEY = 'thread_read_status_' + userEmail.replace('@', '_').replace('.', '_');

        // Document metadata
        const categoryMap = {
            "core": "Core Theory",
            "evidence": "Evidence",
            "references": "References"
        };
        
        const statusColors = {
            "developing": "#28a745",
            "draft": "#ffc107", 
            "stable": "#0066cc"
        };
        
        const docs = [
            {title: "Pattern Recognition Identity", slug: "pattern-recognition-identity", category: "core", lenses: "philosophy cognition", status: "developing"},
            {title: "Empirical Evidence Review", slug: "empirical-evidence", category: "evidence", lenses: "cognition cs-math", status: "draft"},
            {title: "Related Work", slug: "related-work", category: "references", lenses: "philosophy", status: "stable"}
        ];

        // Utility functions
        function slugify(str) {
            return str.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
        }

        function parseFrontmatter(text) {
            if (!text.startsWith('---')) return {meta: {}, content: text};
            const end = text.indexOf('---', 3);
            if (end === -1) return {meta: {}, content: text};
            const yamlText = text.substring(3, end).trim();
            const meta = {};
            yamlText.split('\n').forEach(line => {
                const colon = line.indexOf(':');
                if (colon > 0) {
                    const key = line.substring(0, colon).trim();
                    let val = line.substring(colon + 1).trim();
                    if (val.startsWith('[')) {
                        try {
                            val = JSON.parse(val.replace(/'/g, '"'));
                        } catch {
                            val = val.replace(/[\[\]"]/g, '').split(',').map(s => s.trim());
                        }
                    } else if (val.startsWith('"')) {
                        val = val.replace(/"/g, '');
                    }
                    meta[key] = val;
                }
            });
            const content = text.substring(end + 3).trim();
            return {meta, content};
        }

        // Comment management
        function getStoredComments() {
            const stored = localStorage.getItem(COMMENTS_KEY);
            return stored ? JSON.parse(stored) : {};
        }

        function saveComments(comments) {
            localStorage.setItem(COMMENTS_KEY, JSON.stringify(comments));
        }

        // Read status management - FIXED
        function getReadStatus() {
            const stored = localStorage.getItem(READ_STATUS_KEY);
            return stored ? JSON.parse(stored) : {};
        }

        function saveReadStatus(status) {
            localStorage.setItem(READ_STATUS_KEY, JSON.stringify(status));
        }

        function markThreadAsRead(subject) {
            const status = getReadStatus();
            status[subject] = Date.now();
            saveReadStatus(status);
            
            // Remove NEW pill immediately
            const threadElem = [...document.querySelectorAll('.message-thread')].find(t => 
                t.querySelector('.pill-subject')?.textContent === subject
            );
            if (threadElem) {
                const newPill = threadElem.querySelector('.pill-new');
                if (newPill) {
                    newPill.remove();
                }
            }
        }

        function isThreadNew(subject) {
            const threadData = threads[subject];
            if (!threadData) return false;
            
            const readStatus = getReadStatus();
            const lastReadTime = readStatus[subject] || 0;
            const lastActivity = threadData.lastActivity || threadData.timestamp;
            
            return lastActivity > lastReadTime;
        }

        // Build left panel
        function buildLeftPanel() {
            const leftPanel = document.querySelector('.left-panel');
            const existingCategories = leftPanel.querySelectorAll('.doc-category');
            existingCategories.forEach(cat => cat.remove());

            const categories = {};
            docs.forEach(doc => {
                categories[doc.category] = categories[doc.category] || [];
                categories[doc.category].push(doc);
            });

            Object.keys(categories).sort().forEach(cat => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'doc-category';
                
                const h3 = document.createElement('h3');
                h3.textContent = categoryMap[cat] || cat.toUpperCase();
                categoryDiv.appendChild(h3);
                
                const docsDiv = document.createElement('div');
                docsDiv.id = cat + '-docs';
                
                categories[cat].forEach((doc, idx) => {
                    const color = statusColors[doc.status] || '#6c757d';
                    const item = document.createElement('div');
                    item.className = 'document-item';
                    item.dataset.lenses = Array.isArray(doc.lenses) ? doc.lenses.join(' ') : doc.lenses;
                    item.dataset.slug = doc.slug;
                    item.innerHTML = `
                        <div>${doc.title}</div>
                        <span style="font-size: 11px; color: ${color};">● ${doc.status}</span>
                    `;
                    docsDiv.appendChild(item);
                });
                
                categoryDiv.appendChild(docsDiv);
                leftPanel.appendChild(categoryDiv);
            });

            // Attach click listeners
            document.querySelectorAll('.document-item').forEach(item => {
                item.addEventListener('click', () => {
                    document.querySelectorAll('.document-item, .message-thread').forEach(i => i.classList.remove('active'));
                    item.classList.add('active');
                    const title = item.querySelector('div').textContent;
                    loadDocContent(title, item.dataset.slug);
                });
            });

            // Load first document by default
            const firstItem = document.querySelector('.document-item');
            if (firstItem) {
                firstItem.click();
            }
        }

        // Initialize topic filters
        function initTopicFilters() {
            const filters = document.getElementById('topic-filters');
            filters.innerHTML = '';
            
            const allPill = document.createElement('span');
            allPill.className = 'topic-pill active';
            allPill.textContent = 'All';
            allPill.dataset.topic = 'all';
            filters.appendChild(allPill);

            const uniqueTopics = new Set(Object.values(threads).map(t => t.topic));
            uniqueTopics.forEach(topic => {
                const pill = document.createElement('span');
                pill.className = 'topic-pill';
                pill.textContent = topic;
                pill.dataset.topic = topic;
                filters.appendChild(pill);
            });

            // Add click listeners
            filters.querySelectorAll('.topic-pill').forEach(pill => {
                pill.addEventListener('click', () => {
                    filters.querySelectorAll('.topic-pill').forEach(p => p.classList.remove('active'));
                    pill.classList.add('active');
                    const selected = pill.dataset.topic;
                    document.querySelectorAll('.message-thread').forEach(thread => {
                        thread.style.display = (selected === 'all' || thread.dataset.topic === selected) ? 'block' : 'none';
                    });
                });
            });
        }

        // Build thread list
        function buildThreadList() {
            const messagesList = document.getElementById('messages-list');
            messagesList.innerHTML = '';

            Object.keys(threads).forEach(subject => {
                const data = threads[subject];
                const threadElem = document.createElement('div');
                threadElem.className = 'message-thread';
                threadElem.dataset.topic = data.topic;
                
                const repliesCount = data.messages.length - 1;
                const lastActivity = new Date(data.lastActivity || data.timestamp);
                const isNew = isThreadNew(subject);
                
                threadElem.innerHTML = `
                    <div class="message-pills">
                        <span class="pill pill-subject">${subject}</span>
                        <span class="pill pill-topic">${data.topic}</span>
                        <span class="pill pill-date">${new Date(data.timestamp).toLocaleDateString()}</span>
                        ${isNew ? '<span class="pill pill-new">new</span>' : ''}
                    </div>
                    <div class="message-preview">${data.messages[0].text.substring(0, 100)}${data.messages[0].text.length > 100 ? '...' : ''}</div>
                    <div class="message-replies">${repliesCount} repl${repliesCount === 1 ? 'y' : 'ies'} · Last: ${lastActivity.toLocaleString()}</div>
                `;
                
                messagesList.appendChild(threadElem);
            });

            attachThreadListeners();
        }

        // FIXED: Load document content properly
        function loadDocContent(title, slug) {
            try {
                const content = documentContent[slug];
                
                if (!content) {
                    const center = document.getElementById('center-panel');
                    center.innerHTML = `
                        <div style="max-width: 700px;">
                            <h2>${title}</h2>
                            <p style="color: #6c757d; font-style: italic;">
                                Document content not yet available. This would typically load from /content/${slug}.md
                            </p>
                        </div>
                    `;
                    return;
                }

                // Convert content to HTML with paragraph indexing
                let html = `<div style="max-width: 700px;">`;
                const lines = content.content.split('\n');
                let inParagraph = false;
                let paragraphIndex = 0;
                
                lines.forEach((line, index) => {
                    line = line.trim();
                    if (!line) {
                        if (inParagraph) {
                            html += '</p>';
                            inParagraph = false;
                        }
                        return;
                    }
                    
                    if (line.startsWith('# ')) {
                        if (inParagraph) html += '</p>';
                        html += `<h1>${line.substring(2)}</h1>`;
                        inParagraph = false;
                    } else if (line.startsWith('## ')) {
                        if (inParagraph) html += '</p>';
                        html += `<h2>${line.substring(3)}</h2>`;
                        inParagraph = false;
                    } else if (line.startsWith('### ')) {
                        if (inParagraph) html += '</p>';
                        html += `<h3>${line.substring(4)}</h3>`;
                        inParagraph = false;
                    } else if (line.startsWith('- ')) {
                        if (inParagraph) {
                            html += '</p>';
                            inParagraph = false;
                        }
                        html += `<ul><li>${line.substring(2)}</li></ul>`;
                    } else {
                        if (!inParagraph) {
                            html += `<p class="commentable" data-para-index="${paragraphIndex}">`;
                            inParagraph = true;
                            paragraphIndex++;
                        } else {
                            html += ' ';
                        }
                        html += line;
                    }
                });
                
                if (inParagraph) html += '</p>';
                html += '</div>';

                const center = document.getElementById('center-panel');
                center.innerHTML = html;
                
                // Restore saved comments
                restoreComments(title);
                attachCommentListeners();
                
            } catch (e) {
                console.error('Error loading document:', e);
                const center = document.getElementById('center-panel');
                center.innerHTML = `<div style="max-width: 700px;"><h2>${title}</h2><p style="color: #dc3545;">Error loading document: ${e.message}</p></div>`;
            }
        }

        function restoreComments(title) {
            const comments = getStoredComments()[title];
            if (!comments) return;

            Object.keys(comments).forEach(paraIndex => {
                const paragraph = document.querySelector(`[data-para-index="${paraIndex}"]`);
                if (!paragraph) return;

                comments[paraIndex].forEach(comment => {
                    const commentSpan = document.createElement('span');
                    commentSpan.className = 'comment-marker';
                    commentSpan.dataset.commentId = comment.timestamp;
                    const displayText = comment.text && comment.text.length > 20 ? comment.text.substring(0, 20) + '...' : comment.text;
                    commentSpan.textContent = ` [${comment.marker}${displayText ? ' ' + displayText : ''}]`;
                    
                    const tooltip = document.createElement('div');
                    tooltip.className = 'comment-tooltip';
                    const commentType = comment.marker === '?' ? 'Question' : comment.marker === '!' ? 'Clarification' : 'Approved';
                    const textDiv = comment.text ? `<div style="margin: 4px 0;">${comment.text}</div>` : '';
                    tooltip.innerHTML = `<div><strong>${commentType}</strong></div>${textDiv}<div style="font-size: 11px; opacity: 0.8;">By ${comment.user}<br>${new Date(comment.timestamp).toLocaleString()}</div><div style="margin-top: 5px; font-size: 10px;"><button onclick="editComment(${comment.timestamp})" style="margin-right: 5px;">Edit</button><button onclick="deleteComment(${comment.timestamp})">Delete</button></div>`;
                    commentSpan.appendChild(tooltip);
                    
                    paragraph.appendChild(commentSpan);
                });
            });
        }

        // Load thread content
        function loadThreadContent(subject) {
            const data = threads[subject];
            if (!data) return;

            let html = `
                <div style="max-width: 700px;">
                    <h2>${subject}</h2>
                    <div class="thread-messages">
            `;
            
            data.messages.forEach(msg => {
                const dateStr = new Date(msg.timestamp).toLocaleString();
                const isCurrentUser = msg.user === userEmail;
                html += `
                    <div class="thread-message" style="${isCurrentUser ? 'margin-left: 20px; background: #e7f3ff;' : ''}">
                        <p>${msg.text}</p>
                        <small style="color: #6c757d;">By ${msg.user} at ${dateStr}</small>
                    </div>
                `;
            });
            
            html += `
                    </div>
                    <div class="reply-form">
                        <textarea id="reply-text" placeholder="Add a reply..."></textarea>
                        <button onclick="addReply('${subject}')">Reply</button>
                    </div>
                </div>
            `;
            
            const center = document.getElementById('center-panel');
            center.innerHTML = html;
        }

        // Add reply
        function addReply(subject) {
            const textarea = document.getElementById('reply-text');
            const text = textarea.value.trim();
            if (!text) return;

            const now = Date.now();
            const data = threads[subject];
            
            data.messages.push({
                text: text,
                timestamp: now,
                user: userEmail
            });
            
            data.lastActivity = now;
            textarea.value = '';
            
            loadThreadContent(subject);
            buildThreadList(); // Rebuild to update previews
        }

        // Lens tab switching
        document.querySelectorAll('.lens-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.lens-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                const lens = tab.dataset.lens;
                document.querySelectorAll('.document-item').forEach(doc => {
                    const lenses = doc.dataset.lenses.split(' ');
                    doc.style.display = (lens === 'all' || lenses.includes(lens)) ? 'block' : 'none';
                });
            });
        });

        // Comment functionality
        function attachCommentListeners() {
            document.querySelectorAll('.commentable').forEach(p => {
                p.style.cursor = 'pointer';
                p.addEventListener('click', showCommentMenu);
            });
        }
        function initializeCommentSystem() {
            attachCommentListeners();
        }

        function init() {
            buildLeftPanel();
            initTopicFilters();
            buildThreadList();
            initializeCommentSystem(); // Now properly defined
        }

        function showCommentMenu(e) {
            e.stopPropagation();
            const menu = document.getElementById('comment-menu');
            menu.style.left = e.pageX + 'px';
            menu.style.top = e.pageY + 'px';
            menu.classList.add('show');
            menu.targetElement = e.target;
        }

        document.addEventListener('click', () => {
            document.getElementById('comment-menu').classList.remove('show');
        });

        document.addEventListener('DOMContentLoaded', function() {
            init();
        });

        // Comment dialog state
        let currentCommentTarget = null;
        let currentCommentType = '';

        // Handle comment selection
        document.querySelectorAll('.comment-option').forEach(option => {
            option.addEventListener('click', (e) => {
                e.stopPropagation();
                const type = option.dataset.type;
                const menu = document.getElementById('comment-menu');
                const target = menu.targetElement;
                if (!target) return;

                currentCommentTarget = target;
                currentCommentType = type;

                if (type === 'approved') {
                    // Approved comments don't need text input
                    addComment('', '✓');
                } else {
                    // Show dialog for question/clarification
                    showCommentDialog(type);
                }

                menu.classList.remove('show');
            });
        });

        function showCommentDialog(type) {
            const dialog = document.getElementById('comment-dialog');
            const title = document.getElementById('comment-dialog-title');
            const label = document.getElementById('comment-dialog-label');
            const textarea = document.getElementById('comment-dialog-text');

            if (type === 'question') {
                title.textContent = 'Ask Question';
                label.textContent = 'Question text:';
                textarea.placeholder = 'What would you like to clarify or ask about this section?';
            } else if (type === 'clarification') {
                title.textContent = 'Request Clarification';
                label.textContent = 'Clarification needed:';
                textarea.placeholder = 'What needs to be clarified or expanded in this section?';
            }

            textarea.value = '';
            dialog.classList.add('show');
            textarea.focus();
        }

        function hideCommentDialog() {
            document.getElementById('comment-dialog').classList.remove('show');
            currentCommentTarget = null;
            currentCommentType = '';
        }

        function submitComment() {
            const textarea = document.getElementById('comment-dialog-text');
            const text = textarea.value.trim();
            
            if (!text && (currentCommentType === 'question' || currentCommentType === 'clarification')) {
                alert('Please enter comment text');
                return;
            }

            let marker = '';
            if (currentCommentType === 'question') marker = '?';
            else if (currentCommentType === 'clarification') marker = '!';

            addComment(text, marker);
            hideCommentDialog();
        }

        function addComment(text, marker) {
            try {
                if (!currentCommentTarget) {
                    console.error('No comment target selected');
                    return;
                }

                // Validate that currentCommentTarget is still in the DOM
                if (!document.contains(currentCommentTarget)) {
                    console.error('Comment target is no longer in the DOM');
                    return;
                }

                const now = Date.now();
                const dateStr = new Date(now).toLocaleString();

                // Safely create comment marker with tooltip
                const commentSpan = document.createElement('span');
                commentSpan.className = 'comment-marker';
                
                // Safe text truncation for display
                const displayText = text ? (text.length > 20 ? text.substring(0, 20) + '...' : text) : '';
                commentSpan.textContent = ` [${marker}${displayText ? ' ' + displayText : ''}]`;
                
                // Create tooltip with safe DOM manipulation
                const tooltip = document.createElement('div');
                tooltip.className = 'comment-tooltip';
                
                // Header
                const header = document.createElement('div');
                const strong = document.createElement('strong');
                strong.textContent = marker === '?' ? 'Question' : marker === '!' ? 'Clarification' : 'Approved';
                header.appendChild(strong);
                tooltip.appendChild(header);
                
                // Text content (if any)
                if (text) {
                    const textDiv = document.createElement('div');
                    textDiv.style.margin = '4px 0';
                    textDiv.textContent = text; // Use textContent to avoid HTML injection
                    tooltip.appendChild(textDiv);
                }
                
                // Author and date
                const metaDiv = document.createElement('div');
                metaDiv.style.fontSize = '11px';
                metaDiv.style.opacity = '0.8';
                metaDiv.innerHTML = `By ${userEmail}<br>${dateStr}`;
                tooltip.appendChild(metaDiv);
                
                commentSpan.appendChild(tooltip);
                currentCommentTarget.appendChild(commentSpan);

                // Save to localStorage
                const titleElement = document.querySelector('#center-panel h1, #center-panel h2');
                if (!titleElement) {
                    console.error('Could not find document title');
                    return;
                }
                
                const title = titleElement.textContent;
                const paraIndex = currentCommentTarget.dataset.paraIndex;
                
                if (paraIndex === undefined) {
                    console.error('Paragraph index not found on target element');
                    return;
                }

                const comments = getStoredComments();
                comments[title] = comments[title] || {};
                comments[title][paraIndex] = comments[title][paraIndex] || [];
                comments[title][paraIndex].push({
                    marker: marker === '?' ? '?' : marker === '!' ? '!' : 'V',
                    text: text || '',
                    user: userEmail,
                    timestamp: now
                });
                saveComments(comments);

                // Save to markdown file (simulate)
                saveCommentToMarkdown(title, paraIndex, marker === '?' ? '?' : marker === '!' ? '!' : 'V', text || '', userEmail, now);
                
            } catch (error) {
                console.error('Error adding comment:', error);
                alert('Failed to add comment. Please try again.');
            }
        }

        function saveCommentToMarkdown(docTitle, paraIndex, prefix, text, user, timestamp) {
            const slug = slugify(docTitle);
            const filename = `${slug}.md`;
            
            // Format the markdown comment
            const mdComment = text ? 
                `<!-- ${prefix} ${text} | ${user} | ${timestamp} -->` :
                `<!-- ${prefix} | ${user} | ${timestamp} -->`;
            
            console.log(`📝 SAVE TO FILE: /content/${filename}`);
            console.log(`📍 LOCATION: After paragraph ${paraIndex}`);
            console.log(`💬 COMMENT: ${mdComment}`);
            console.log(`---`);
            
            // In a real implementation, this would make an API call:
            // fetch('/api/save-comment', {
            //     method: 'POST',
            //     headers: { 'Content-Type': 'application/json' },
            //     body: JSON.stringify({ filename, paraIndex, comment: mdComment })
            // });
        }

        // Thread selection handling - FIXED
        function attachThreadListeners() {
            document.querySelectorAll('.message-thread').forEach(thread => {
                thread.addEventListener('click', () => {
                    document.querySelectorAll('.document-item, .message-thread').forEach(i => i.classList.remove('active'));
                    thread.classList.add('active');
                    
                    const subject = thread.querySelector('.pill-subject').textContent;
                    loadThreadContent(subject);
                    
                    // Mark as read immediately
                    markThreadAsRead(subject);
                });
            });
        }

        // Modal functions
        function showOverview() {
            document.getElementById('overview-modal').classList.add('show');
        }

        function hideOverview() {
            document.getElementById('overview-modal').classList.remove('show');
        }

        // Thread form functions
        function showNewThreadForm() {
            document.getElementById('new-thread-form').classList.add('show');
        }

        function hideNewThreadForm() {
            document.getElementById('new-thread-form').classList.remove('show');
            // Clear form
            document.getElementById('thread-subject').value = '';
            document.getElementById('thread-topic').value = '';
            document.getElementById('thread-message').value = '';
        }

        function createThread() {
            const subject = document.getElementById('thread-subject').value.trim();
            const topic = document.getElementById('thread-topic').value.trim();
            const message = document.getElementById('thread-message').value.trim();
            
            if (!subject || !topic || !message) {
                alert('Please fill in all fields');
                return;
            }

            const now = Date.now();

            // Add to threads data
            threads[subject] = {
                topic: topic,
                timestamp: now,
                lastActivity: now,
                messages: [{
                    text: message,
                    timestamp: now,
                    user: userEmail
                }]
            };

            // Mark as read for creator
            markThreadAsRead(subject);

            // Rebuild interface
            buildThreadList();
            initTopicFilters();

            hideNewThreadForm();
        }

        // Initialize everything
        function init() {
            buildLeftPanel();
            initTopicFilters();
            buildThreadList();
            initializeCommentSystem(); // Initialize comment system
        }

        // Start the application only after DOM is fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            init();
        });
    </script>
    <div id="comment-dialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
         background: white; border: 1px solid #dee2e6; border-radius: 4px; padding: 20px; z-index: 3000;">
        <h3 id="comment-dialog-title">Comment</h3>
        <label id="comment-dialog-label" for="comment-dialog-text"></label>
        <textarea id="comment-dialog-text" style="width: 100%; min-height: 80px; margin-top: 10px;"></textarea>
        <div style="margin-top: 10px; text-align: right;">
            <button onclick="hideCommentDialog()" style="margin-right: 10px;">Cancel</button>
            <button onclick="submitComment()">Submit</button>
        </div>
    </div>
</body>
</html>