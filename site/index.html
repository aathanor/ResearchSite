<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pattern Constellations</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
       
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            color: #333333;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        /* Document Typography */
        .document-content {
            max-width: 700px;
            margin: 0 auto;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', sans-serif;
            font-size: 17px;
            line-height: 1.7;
            color: #333;
        }

        .document-content h1 {
            font-size: 2.2em;
            font-weight: 700;
            margin: 2rem 0 1.5rem 0;
            line-height: 1.2;
            color: #1a1a1a;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 0.5rem;
        }

        .document-content h2 {
            font-size: 1.7em;
            font-weight: 600;
            margin: 2rem 0 1rem 0;
            line-height: 1.3;
            color: #2c3e50;
        }

        .document-content h3 {
            font-size: 1.3em;
            font-weight: 600;
            margin: 1.5rem 0 0.8rem 0;
            line-height: 1.4;
            color: #34495e;
        }

        .document-content p {
            margin: 0 0 1.2rem 0;
            text-align: justify;
            hyphens: auto;
        }

        .document-content ul, .document-content ol {
            margin: 0 0 1.2rem 0;
            padding-left: 2rem;
        }

        .document-content li {
            margin-bottom: 0.5rem;
            line-height: 1.7;
        }

        .document-content strong {
            font-weight: 600;
            color: #1a1a1a;
        }

        .document-content em {
            font-style: italic;
        }

        /* Better readability on screens */
        @media screen and (min-width: 768px) {
            .document-content {
                font-size: 18px;
                line-height: 1.8;
            }
        }

        /* Selection and interaction */
        .document-content .commentable {
            cursor: text;
            transition: background-color 0.2s;
        }

        .document-content .commentable:hover {
            background-color: rgba(0, 102, 204, 0.03);
        }

        /* Code blocks if you have any */
        .document-content code {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
            font-size: 0.9em;
            padding: 0.2em 0.4em;
            background: #f4f4f4;
            border-radius: 3px;
        }

        /* Improve comment markers */
        .comment-marker {
            background: rgba(255, 235, 59, 0.2);
            padding: 0 3px;
            border-radius: 3px;
            margin: 0 2px;
        }
        .comment-marker {
            position: relative;
            display: inline;
            background-color: rgba(255, 0, 0, 0.3); /* Default color, will be overridden by JS */
            margin-left: 5px;
            cursor: pointer;
        }

        .comment-tooltip {
            position: absolute;
            bottom: 100%;
            left: 0;
            z-index: 1000;
            background: #fffeef;
            border: 1px solid #e9e9e9;
            border-radius: 4px;
            padding: 8px;
            white-space: nowrap;
            pointer-events: auto;
            font-size: 14px;
            display: none;
        }

        .comment-marker:hover .comment-tooltip {
            display: block;
        }
       
        /* Header */
        .header {
            background: #f8f9fa;
            border-bottom: 2px solid #dee2e6;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
       
        .header h1 {
            font-size: 18px;
            color: #495057;
        }
       
        .header-actions {
            display: flex;
            gap: 15px;
        }
       
        .btn-overview {
            padding: 8px 16px;
            background: #0066cc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
       
        .btn-overview:hover {
            background: #0052a3;
        }
       
        /* Main layout */
        .main-container {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
       
        /* Left panel - Documents */
        .left-panel {
            width: 20%;
            background: #f8f9fa;
            border-right: 1px solid #dee2e6;
            overflow-y: auto;
            padding: 15px;
        }
       
        .lens-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
            border-bottom: 1px solid #dee2e6;
        }
       
        .lens-tab {
            padding: 8px 12px;
            background: transparent;
            border: none;
            cursor: pointer;
            color: #6c757d;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }
       
        .lens-tab.active {
            color: #0066cc;
            border-bottom-color: #0066cc;
        }
       
        .doc-category {
            margin-bottom: 20px;
        }
       
        .doc-category h3 {
            font-size: 12px;
            text-transform: uppercase;
            color: #6c757d;
            margin-bottom: 8px;
            font-weight: 600;
        }
       
        .document-item {
            background: white;
            padding: 10px;
            margin-bottom: 5px;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid transparent;
            transition: all 0.2s;
        }
       
        .document-item:hover {
            border-color: #0066cc;
        }
       
        .document-item.active {
            background: #e7f3ff;
            border-color: #0066cc;
        }
       
        /* Center - Main content */
        .center-panel {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            background: white;
            position: relative;
        }
       
        /* Right panel - Messages */
        .right-panel {
            width: 25%;
            background: #f8f9fa;
            border-left: 1px solid #dee2e6;
            display: flex;
            flex-direction: column;
        }
       
        .messages-header {
            padding: 15px;
            background: white;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
       
        .messages-header h3 {
            font-size: 14px;
            font-weight: 600;
            color: #495057;
        }
       
        .new-thread-btn {
            padding: 6px 12px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
       
        .topic-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 10px 15px;
            border-bottom: 1px solid #dee2e6;
        }
       
        .topic-pill {
            padding: 4px 10px;
            background: #f0f0f0;
            color: #666;
            border-radius: 12px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
       
        .topic-pill.active {
            background: #0066cc;
            color: white;
        }
       
        .messages-list {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }
       
        .message-thread {
            background: white;
            border-radius: 8px;
            margin-bottom: 10px;
            padding: 12px;
            cursor: pointer;
            border: 1px solid #e9ecef;
            transition: all 0.2s;
        }
       
        .message-thread:hover {
            border-color: #0066cc;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
       
        .message-thread.active {
            background: #e7f3ff;
            border-color: #0066cc;
        }
       
        .message-pills {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }
       
        .pill {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
        }
       
        .pill-subject {
            background: #e7f3ff;
            color: #0066cc;
        }
       
        .pill-topic {
            background: #f0f0f0;
            color: #666;
        }
       
        .pill-date {
            background: #fff3cd;
            color: #856404;
        }
       
        .pill-new {
            background: #dc3545;
            color: white;
        }
       
        .message-preview {
            font-size: 13px;
            color: #6c757d;
            margin-top: 5px;
        }
       
        .message-replies {
            font-size: 11px;
            color: #28a745;
            margin-top: 5px;
            font-weight: 500;
        }
       
        /* Thread view styles */
        .thread-messages {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
       
        .thread-message {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #dee2e6;
        }
       
        .reply-form {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
       
        .reply-form textarea {
            padding: 8px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            resize: vertical;
            min-height: 60px;
        }
       
        .reply-form button {
            align-self: flex-start;
            padding: 6px 12px;
            background: #0066cc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
       
        /* Comment Menu - VERTICAL */
        .comment-menu {
            position: absolute;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 8px;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            min-width: 180px;
        }
       
        .comment-menu.show {
            display: block;
        }
       
        .comment-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.2s;
            font-size: 14px;
            color: #495057;
        }
       
        .comment-option:hover {
            background: #f8f9fa;
        }
       
        .comment-option-icon {
            font-size: 18px;
            width: 24px;
            text-align: center;
        }
       
        .comment-option-text {
            flex: 1;
        }
       
        /* Overview Modal */
        .overview-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
        }
       
        .overview-modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }
       
        .overview-content {
            background: white;
            border-radius: 8px;
            width: 90%;
            height: 80%;
            padding: 30px;
            position: relative;
            overflow: auto;
        }
       
        .overview-close {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 24px;
            cursor: pointer;
            color: #6c757d;
        }
       
        .overview-graph {
            display: flex;
            flex-direction: column;
            gap: 30px;
            margin-top: 20px;
        }
       
        .overview-section {
            border-left: 3px solid #0066cc;
            padding-left: 20px;
        }
       
        .overview-section h3 {
            color: #0066cc;
            margin-bottom: 10px;
        }
       
        .overview-items {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
       
        .overview-item {
            padding: 8px 15px;
            background: #f8f9fa;
            border-radius: 4px;
            font-size: 13px;
            border: 1px solid #dee2e6;
        }
       
        .overview-item.stable {
            background: #d4edda;
            border-color: #28a745;
        }
       
        .overview-item.developing {
            background: #cce5ff;
            border-color: #0066cc;
        }
       
        .overview-item.draft {
            background: #fff3cd;
            border-color: #ffc107;
        }
       
        /* New thread form */
        .new-thread-form {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            z-index: 3000;
            display: none;
            width: 400px;
        }
       
        .new-thread-form.show {
            display: block;
        }
       
        .form-group {
            margin-bottom: 15px;
        }
       
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            color: #495057;
        }
       
        .form-group input, .form-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-size: 14px;
        }
       
        .form-group textarea {
            resize: vertical;
            min-height: 100px;
        }
       
        .form-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
       
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
       
        .btn-primary {
            background: #0066cc;
            color: white;
        }
       
        .btn-secondary {
            background: #6c757d;
            color: white;
        }

       
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <h1>Pattern Constellations Research</h1>
        <div class="header-actions">
            <button class="btn-overview" onclick="showOverview()">üìä Project Overview</button>
        </div>
    </div>
   
    <!-- Main container -->
    <div class="main-container">
        <!-- Left Panel - Documents -->
        <div class="left-panel">
            <div class="lens-tabs">
                <button class="lens-tab active" data-lens="all">All</button>
                <button class="lens-tab" data-lens="philosophy">Philosophy</button>
                <button class="lens-tab" data-lens="cognition">Cognition</button>
                <button class="lens-tab" data-lens="cs-math">CS/Math</button>
            </div>
            <!-- Categories will be added dynamically -->
        </div>
       
        <!-- Center - Main content -->
        <div class="center-panel" id="center-panel">
            <div style="max-width: 700px;">
                <div style="text-align: center; padding: 60px; color: #6c757d;">
                    <h2 style="color: #495057; margin-bottom: 10px;">Select a document to begin</h2>
                    <p>Choose a document from the left panel</p>
                </div>
            </div>
        </div>
       
        <!-- Right Panel - Messages -->
        <div class="right-panel">
            <div class="messages-header">
                <h3>Messages</h3>
                <button class="new-thread-btn" onclick="showNewThreadForm()">+ New Thread</button>
            </div>
            <div class="topic-filters" id="topic-filters">
                <!-- Pills will be added here dynamically -->
            </div>
            <div class="messages-list" id="messages-list">
                <!-- Threads will be added dynamically -->
            </div>
        </div>
    </div>
   
    <!-- Comment Menu - VERTICAL with TEXT -->
    <div class="comment-menu" id="comment-menu">
        <div class="comment-option" data-type="question">
            <span class="comment-option-icon">‚ùì</span>
            <span class="comment-option-text">Ask question</span>
        </div>
        <div class="comment-option" data-type="clarification">
            <span class="comment-option-icon">‚ùó</span>
            <span class="comment-option-text">Needs clarification</span>
        </div>
        <div class="comment-option" data-type="approved">
            <span class="comment-option-icon">‚úÖ</span>
            <span class="comment-option-text">Approved / Keep</span>
        </div>
    </div>
   
    <!-- Overview Modal -->
    <div class="overview-modal" id="overview-modal">
        <div class="overview-content">
            <span class="overview-close" onclick="hideOverview()">√ó</span>
            <h2>Project Overview - Pattern Recognition Identity</h2>
           
            <div class="overview-graph">
                <div class="overview-section">
                    <h3>üéØ Core Theory</h3>
                    <div class="overview-items">
                        <div class="overview-item developing">PRI Main Thesis</div>
                        <div class="overview-item developing">Pattern-Recognition Unity</div>
                        <div class="overview-item draft">Consciousness as Reflexive PR</div>
                    </div>
                </div>
               
                <div class="overview-section">
                    <h3>üí° Problem Dissolutions</h3>
                    <div class="overview-items">
                        <div class="overview-item stable">Hard Problem</div>
                        <div class="overview-item developing">Symbol Grounding</div>
                        <div class="overview-item draft">Quantum Measurement</div>
                        <div class="overview-item draft">Causation Problem</div>
                    </div>
                </div>
               
                <div class="overview-section">
                    <h3>üìä Empirical Evidence</h3>
                    <div class="overview-items">
                        <div class="overview-item developing">Semantic Embeddings</div>
                        <div class="overview-item developing">Rod-Cap Structure</div>
                        <div class="overview-item draft">LLM Analysis</div>
                    </div>
                </div>
               
                <div class="overview-section">
                    <h3>üîó Connections</h3>
                    <div class="overview-items">
                        <div class="overview-item stable">Eastern Philosophy</div>
                        <div class="overview-item developing">Transformer Architecture</div>
                        <div class="overview-item draft">Hopfield Networks</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
   
    <!-- New Thread Form -->
    <div class="new-thread-form" id="new-thread-form">
        <h3 style="margin-bottom: 20px;">New Discussion</h3>
        <div class="form-group">
            <label>Subject</label>
            <input type="text" id="thread-subject" placeholder="Brief topic...">
        </div>
        <div class="form-group">
            <label>Topic Category</label>
            <input type="text" id="thread-topic" placeholder="e.g., Core Theory, Evidence, Questions...">
        </div>
        <div class="form-group">
            <label>Message</label>
            <textarea id="thread-message" placeholder="Your thoughts..."></textarea>
        </div>
        <div class="form-actions">
            <button class="btn btn-secondary" onclick="hideNewThreadForm()">Cancel</button>
            <button class="btn btn-primary" onclick="createThread()">Create Thread</button>
        </div>
    </div>
   
    <script>
        // User email (in real deployment, fetch from API)
        let userEmail = 'you@example.com';

        let currentCommentRange = null;  // store the selection range when showing dialog
        let currentCommentType = '';     // store type of comment (question, clarification, approved)
        
        async function fetchUserEmail() {
            try {
                const res = await fetch('/api/user');
                const data = await res.json();
                userEmail = data.email || 'anonymous';
            } catch {
                userEmail = 'anonymous';
            }
        }
        fetchUserEmail();

        // Thread data with better timestamp management
        const threads = {
            'Eastern Philosophy Connection': {
                topic: 'Core Theory',
                timestamp: Date.now() - 86400000 * 2,
                lastActivity: Date.now() - 7200000,
                messages: [
                    {text: "I've been thinking about how PRI relates to Buddhist dependent origination. The recursive self-recognition aspect seems to mirror the Buddhist understanding of consciousness as a process rather than a thing.", timestamp: Date.now() - 86400000 * 2, user: 'supervisor@example.com'},
                    {text: 'That\'s a compelling connection. The madhyamaka analysis of dependent origination might provide insights into how pattern recognition avoids the infinite regress problem.', timestamp: Date.now() - 7200000, user: 'you@example.com'},
                    {text: 'Exactly. And the yogƒÅcƒÅra school\'s analysis of consciousness (vij√±ƒÅna) as transformative recognition could be directly relevant to our recursive model.', timestamp: Date.now() - 3600000, user: 'supervisor@example.com'},
                    {text: 'We should explore whether ƒÅlaya-vij√±ƒÅna (store consciousness) maps onto the pattern constellation structure we\'re proposing.', timestamp: Date.now() - 1800000, user: 'you@example.com'}
                ]
            },
            'Symbol Grounding Dissolution': {
                topic: 'Problems',
                timestamp: Date.now() - 86400000 * 3,
                lastActivity: Date.now() - 86400000,
                messages: [
                    {text: "The dissolution seems compelling but I'm not sure about the linguistic aspects. How does pattern recognition ground arbitrary symbols like words?", timestamp: Date.now() - 86400000 * 3, user: 'you@example.com'},
                    {text: 'The key insight is that symbols don\'t need external grounding - they ground through recognition patterns that connect them to embodied recognition systems.', timestamp: Date.now() - 86400000 * 2, user: 'supervisor@example.com'},
                    {text: 'But what about truly abstract concepts that seem divorced from embodied experience?', timestamp: Date.now() - 86400000 * 2, user: 'you@example.com'},
                    {text: 'Even abstract concepts emerge from pattern recognition operating on other patterns. Mathematical concepts, for instance, recognize structural patterns that can exist independently of specific instantiations.', timestamp: Date.now() - 86400000, user: 'supervisor@example.com'},
                    {text: 'So abstraction is pattern recognition operating on increasingly general pattern types rather than specific content?', timestamp: Date.now() - 86400000, user: 'you@example.com'}
                ]
            },
            'Meeting Notes': {
                topic: 'Admin',
                timestamp: Date.now() - 86400000 * 7,
                lastActivity: Date.now() - 86400000 * 6,
                messages: [
                    {text: "Summary of our discussion about the empirical evidence section. We agreed to focus on three main areas: semantic embeddings, transformer architectures, and predictive processing research.", timestamp: Date.now() - 86400000 * 7, user: 'supervisor@example.com'},
                    {text: 'I\'ll start working on the semantic embeddings analysis this week.', timestamp: Date.now() - 86400000 * 6, user: 'you@example.com'}
                ]
            }
        };

        // LocalStorage keys
        const COMMENTS_KEY = 'doc_comments';
        const READ_STATUS_KEY = 'thread_read_status_' + userEmail.replace('@', '_').replace('.', '_');

        // Document metadata
        const categoryMap = {
            "core": "Core Theory",
            "evidence": "Evidence",
            "references": "References"
        };
        
        const statusColors = {
            "developing": "#28a745",
            "draft": "#ffc107", 
            "stable": "#0066cc"
        };
        
        const docs = [
            {title: "Pattern Recognition Identity", slug: "pattern-recognition-identity", category: "core", lenses: "philosophy cognition", status: "developing"},
            {title: "Empirical Evidence Review", slug: "empirical-evidence", category: "evidence", lenses: "cognition cs-math", status: "draft"},
            {title: "Related Work", slug: "related-work", category: "references", lenses: "philosophy", status: "stable"}
        ];

        // Utility functions
        function slugify(str) {
            return str.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
        }

        function parseFrontmatter(text) {
            if (!text.startsWith('---')) return {meta: {}, content: text};
            const end = text.indexOf('---', 3);
            if (end === -1) return {meta: {}, content: text};
            const yamlText = text.substring(3, end).trim();
            const meta = {};
            yamlText.split('\n').forEach(line => {
                const colon = line.indexOf(':');
                if (colon > 0) {
                    const key = line.substring(0, colon).trim();
                    let val = line.substring(colon + 1).trim();
                    if (val.startsWith('[')) {
                        try {
                            val = JSON.parse(val.replace(/'/g, '"'));
                        } catch {
                            val = val.replace(/[\[\]"]/g, '').split(',').map(s => s.trim());
                        }
                    } else if (val.startsWith('"')) {
                        val = val.replace(/"/g, '');
                    }
                    meta[key] = val;
                }
            });
            const content = text.substring(end + 3).trim();
            return {meta, content};
        }

        // Comment management
        function getStoredComments() {
            const stored = localStorage.getItem(COMMENTS_KEY);
            return stored ? JSON.parse(stored) : {};
        }

        function saveComments(comments) {
            localStorage.setItem(COMMENTS_KEY, JSON.stringify(comments));
        }

        // Read status management - FIXED
        function getReadStatus() {
            const stored = localStorage.getItem(READ_STATUS_KEY);
            return stored ? JSON.parse(stored) : {};
        }

        function saveReadStatus(status) {
            localStorage.setItem(READ_STATUS_KEY, JSON.stringify(status));
        }

        function markThreadAsRead(subject) {
            const status = getReadStatus();
            status[subject] = Date.now();
            saveReadStatus(status);
            
            // Remove NEW pill immediately
            const threadElem = [...document.querySelectorAll('.message-thread')].find(t => 
                t.querySelector('.pill-subject')?.textContent === subject
            );
            if (threadElem) {
                const newPill = threadElem.querySelector('.pill-new');
                if (newPill) {
                    newPill.remove();
                }
            }
        }

        function isThreadNew(subject) {
            const threadData = threads[subject];
            if (!threadData) return false;
            
            const readStatus = getReadStatus();
            const lastReadTime = readStatus[subject] || 0;
            const lastActivity = threadData.lastActivity || threadData.timestamp;
            
            return lastActivity > lastReadTime;
        }

        // Build left panel
        // Add this new function to load a manifest of markdown docs from /content/manifest.json
        async function loadMarkdownManifest() {
            try {
                const res = await fetch('/content/manifest.json');
                const docsFromManifest = await res.json(); // Expected to be an array of objects with at least: { title, slug, category, lenses, status }
                return docsFromManifest;
            } catch (err) {
                console.error('Error loading markdown manifest:', err);
                return [];
            }
        }

        // Replace your buildLeftPanel() function with this version that loads the manifest dynamically.
        // New function to load documents from documents.json
async function loadDocContent(doc) {
    try {
        // Use the pre-built content from documents.json
        let text = doc.fullContent || doc.content;
        if (!text) {
            const res = await fetch(`/content/${doc.id}`);
            text = await res.text();
        }
        
        // Parse and render comments in the content
        const renderComments = (content) => {
            // Regular expression to match comment patterns - FIXED: replaced ‚ùó with !
            const commentRegex = new RegExp('<!--\\s*([?!\\u2713])\\s*(.*?)\\s*\\|\\s*(.*?)\\s*\\|\\s*(\\d+)(?:\\s*\\|\\s*(.*?))?\\s*-->', 'g');
            
            let lastIndex = 0;
            let result = '';
            let match;
            
            while ((match = commentRegex.exec(content)) !== null) {
                // Add content before the comment
                result += content.substring(lastIndex, match.index);
                
                const [fullMatch, commentHtml, type, commentText, author, timestamp, highlightedText] = match;
                
                // Create a comment element
                const commentElement = document.createElement('span');
                commentElement.className = 'comment-marker';
                commentElement.dataset.commentId = timestamp;
                commentElement.dataset.originalText = highlightedText || commentText;
                
                // Set background color based on type
                if (type === '?') {
                    commentElement.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
                } else if (type === '!') {
                    commentElement.style.backgroundColor = 'rgba(255, 255, 0, 0.3)';
                } else if (type === '‚úì') {
                    commentElement.style.backgroundColor = 'rgba(0, 255, 0, 0.3)';
                }
                
                // Add the highlighted text
                if (highlightedText) {
                    commentElement.textContent = highlightedText;
                } else {
                    // Fallback: use comment text or type indicator
                    commentElement.textContent = commentText || type;
                }
                
                // Create tooltip
                const tooltip = document.createElement('div');
                tooltip.className = 'comment-tooltip';
                
                const dateStr = new Date(parseInt(timestamp)).toLocaleDateString();
                tooltip.innerHTML = `<button onclick="editComment(${timestamp})" style="margin-right:5px;">Edit</button>
                                    <button onclick="deleteComment(${timestamp})">Delete</button>
                                    <div style="font-size:11px; opacity:0.8;">By ${author} on ${dateStr}</div>
                                    <div>${commentText}</div>`;
                
                commentElement.appendChild(tooltip);
                
                // Add to result as HTML string
                result += commentElement.outerHTML;
                
                lastIndex = match.index + fullMatch.length;
            }
            
            // Add remaining content
            result += content.substring(lastIndex);
            
            return result;
        };
        
        // Simple markdown to HTML conversion
        function markdownToHtml(markdown) {
            let html = markdown;
            
            // Headers
            html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
            html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
            html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');
            
            // Bold and italic
            html = html.replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>');
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
            
            // Lists
            html = html.replace(/^\* (.+)$/gim, '<li>$1</li>');
            html = html.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');
            html = html.replace(/^\d+\. (.+)$/gim, '<li>$1</li>');
            
            // Paragraphs - wrap lines that aren't already tags
            const lines = html.split('\n');
            const processedLines = [];
            let inParagraph = false;
            let paragraphIndex = 0;
            
            lines.forEach(line => {
                const trimmed = line.trim();
                if (!trimmed) {
                    if (inParagraph) {
                        processedLines.push('</p>');
                        inParagraph = false;
                    }
                    processedLines.push(''); // Keep empty lines
                    return;
                }
                
                // Check if line is already a tag
                if (trimmed.startsWith('<h') || trimmed.startsWith('<ul') || 
                    trimmed.startsWith('<li') || trimmed.startsWith('</')) {
                    if (inParagraph) {
                        processedLines.push('</p>');
                        inParagraph = false;
                    }
                    processedLines.push(line);
                } else {
                    if (!inParagraph) {
                        processedLines.push(`<p class="commentable" data-para-index="${paragraphIndex}">`);
                        inParagraph = true;
                        paragraphIndex++;
                    } else {
                        processedLines.push('<br>'); // Add line break within paragraph
                    }
                    processedLines.push(line);
                }
            });
            
            if (inParagraph) {
                processedLines.push('</p>');
            }
            
            return processedLines.join('\n');
        }
        
        // Convert markdown to HTML and render comments
        let htmlContent = markdownToHtml(text);
        htmlContent = renderComments(htmlContent);
        
        // Add proper container with good typography
        document.getElementById('center-panel').innerHTML = `
            <article class="document-content">
                ${htmlContent}
            </article>
        `;
        
        const docTitle = doc.frontmatter?.title || doc.title;
        restoreComments(docTitle);
        attachCommentListeners();
        
    } catch (e) {
        console.error('Error loading document:', e);
        document.getElementById('center-panel').innerHTML = `
            <div class="document-content">
                <h2>Error loading document</h2>
                <p style="color: #dc3545;">${e.message}</p>
            </div>
        `;
    }
}

// Helper functions
function getHighlightColor(type) {
    const colors = {
        'question': 'rgba(255, 0, 0, 0.3)',
        'clarification': 'rgba(255, 255, 0, 0.3)',
        'approved': 'rgba(0, 255, 0, 0.3)'
    };
    return colors[type] || 'rgba(0, 0, 255, 0.3)';
}

function getCommentIcon(type) {
    const icons = {
        'question': '‚ùì',
        'clarification': '‚ùó',
        'approved': '‚úÖ'
    };
    return icons[type] || 'üí¨';
}

async function loadDocuments() {
        try {
            const res = await fetch('/content/manifest.json');
            if (!res.ok) throw new Error('Manifest fetch failed');
            return await res.json(); // Assume array of {id, title, category, lenses, status, frontmatter}
        } catch (err) {
            console.error('Error loading documents:', err);
            return []; // Fallback to empty to avoid pane crash
        }
    }

// Updated buildLeftPanel that groups documents by frontmatter.category
async function buildLeftPanel() {
const leftPanel = document.querySelector('.left-panel');
leftPanel.querySelectorAll('.doc-category').forEach(cat => cat.remove());

const docsArray = await loadDocuments();
if (docsArray.length === 0) {
    leftPanel.innerHTML += '<p style="color: #dc3545; text-align: center;">No documents found</p>'; // UX feedback
    return;
}
    
    // Deduplicate by ID
    const uniqueDocs = {};
    docsArray.forEach(doc => {
        if (!uniqueDocs[doc.id]) {
            uniqueDocs[doc.id] = doc;
        }
    });
    
    // Group by category
    const categories = {};
    Object.values(uniqueDocs).forEach(doc => {
        const cat = doc.frontmatter?.category || 'uncategorized';
        if (!categories[cat]) categories[cat] = [];
        categories[cat].push(doc);
    });
    
    // Build UI
    Object.keys(categories).sort().forEach(cat => {
        const categoryDiv = document.createElement('div');
        categoryDiv.className = 'doc-category';
        
        const h3 = document.createElement('h3');
        h3.textContent = cat.toUpperCase();
        categoryDiv.appendChild(h3);
        
        const docsDiv = document.createElement('div');
        
        categories[cat].forEach(doc => {
            const item = document.createElement('div');
            item.className = 'document-item';
            item.dataset.id = doc.id;
            item.dataset.lenses = doc.lens ? doc.lens.join(' ') : '';
            item.innerHTML = `
                <div>${doc.title || doc.frontmatter?.title || 'Untitled'}</div>
                <span style="font-size: 11px; color: #6c757d;">‚óè ${doc.status}</span>
            `;
            
            item.addEventListener('click', () => {
                document.querySelectorAll('.document-item').forEach(i => i.classList.remove('active'));
                item.classList.add('active');
                loadDocContent(doc);
            });
            
            docsDiv.appendChild(item);
        });
        
        categoryDiv.appendChild(docsDiv);
        leftPanel.appendChild(categoryDiv);
    });

    async function init() {
    await buildLeftPanel(); // Await dynamic load
    initTopicFilters();
    buildThreadList();
    initializeCommentSystem();
  }

  document.addEventListener('DOMContentLoaded', async function() {
    await init();
    });
}

        // Initialize topic filters
        function initTopicFilters() {
            const filters = document.getElementById('topic-filters');
            filters.innerHTML = '';
            
            const allPill = document.createElement('span');
            allPill.className = 'topic-pill active';
            allPill.textContent = 'All';
            allPill.dataset.topic = 'all';
            filters.appendChild(allPill);

            const uniqueTopics = new Set(Object.values(threads).map(t => t.topic));
            uniqueTopics.forEach(topic => {
                const pill = document.createElement('span');
                pill.className = 'topic-pill';
                pill.textContent = topic;
                pill.dataset.topic = topic;
                filters.appendChild(pill);
            });

            // Add click listeners
            filters.querySelectorAll('.topic-pill').forEach(pill => {
                pill.addEventListener('click', () => {
                    filters.querySelectorAll('.topic-pill').forEach(p => p.classList.remove('active'));
                    pill.classList.add('active');
                    const selected = pill.dataset.topic;
                    document.querySelectorAll('.message-thread').forEach(thread => {
                        thread.style.display = (selected === 'all' || thread.dataset.topic === selected) ? 'block' : 'none';
                    });
                });
            });
        }

        // Build thread list
        function buildThreadList() {
            const messagesList = document.getElementById('messages-list');
            messagesList.innerHTML = '';

            Object.keys(threads).forEach(subject => {
                const data = threads[subject];
                const threadElem = document.createElement('div');
                threadElem.className = 'message-thread';
                threadElem.dataset.topic = data.topic;
                
                const repliesCount = data.messages.length - 1;
                const lastActivity = new Date(data.lastActivity || data.timestamp);
                const isNew = isThreadNew(subject);
                
                threadElem.innerHTML = `
                    <div class="message-pills">
                        <span class="pill pill-subject">${subject}</span>
                        <span class="pill pill-topic">${data.topic}</span>
                        <span class="pill pill-date">${new Date(data.timestamp).toLocaleDateString()}</span>
                        ${isNew ? '<span class="pill pill-new">new</span>' : ''}
                    </div>
                    <div class="message-preview">${data.messages[0].text.substring(0, 100)}${data.messages[0].text.length > 100 ? '...' : ''}</div>
                    <div class="message-replies">${repliesCount} repl${repliesCount === 1 ? 'y' : 'ies'} ¬∑ Last: ${lastActivity.toLocaleString()}</div>
                `;
                
                messagesList.appendChild(threadElem);
            });

            attachThreadListeners();
        }

        // FIXED: Load document content properly
        async function loadDocContent(doc) {
            try {
                // Use the pre-built content from documents.json
                let text = doc.fullContent || doc.content;
                if (!text) {
                    const res = await fetch(`/content/${doc.id}`);
                    text = await res.text();
                }
                
                // Simple markdown to HTML conversion
                function markdownToHtml(markdown) {
                    let html = markdown;
                    
                    // Headers
                    html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
                    html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
                    html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');
                    
                    // Bold and italic
                    html = html.replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>');
                    html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                    html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
                    
                    // Lists
                    html = html.replace(/^\* (.+)$/gim, '<li>$1</li>');
                    html = html.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');
                    html = html.replace(/^\d+\. (.+)$/gim, '<li>$1</li>');
                    
                    // Paragraphs - wrap lines that aren't already tags
                    const lines = html.split('\n');
                    const processedLines = [];
                    let inParagraph = false;
                    let paragraphIndex = 0;
                    
                    lines.forEach(line => {
                        const trimmed = line.trim();
                        if (!trimmed) {
                            if (inParagraph) {
                                processedLines.push('</p>');
                                inParagraph = false;
                            }
                            processedLines.push(''); // Keep empty lines
                            return;
                        }
                        
                        // Check if line is already a tag
                        if (trimmed.startsWith('<h') || trimmed.startsWith('<ul') || 
                            trimmed.startsWith('<li') || trimmed.startsWith('</')) {
                            if (inParagraph) {
                                processedLines.push('</p>');
                                inParagraph = false;
                            }
                            processedLines.push(line);
                        } else {
                            if (!inParagraph) {
                                processedLines.push(`<p class="commentable" data-para-index="${paragraphIndex}">`);
                                inParagraph = true;
                                paragraphIndex++;
                            } else {
                                processedLines.push('<br>'); // Add line break within paragraph
                            }
                            processedLines.push(line);
                        }
                    });
                    
                    if (inParagraph) {
                        processedLines.push('</p>');
                    }
                    
                    return processedLines.join('\n');
                }
                
                // Convert markdown to HTML
                const htmlContent = markdownToHtml(text);
                
                // Add proper container with good typography
                document.getElementById('center-panel').innerHTML = `
                    <article class="document-content">
                        ${htmlContent}
                    </article>
                `;
                
                // Use doc.id instead of title for restoring comments
                restoreComments(doc.id);
                attachCommentListeners();
                
            } catch (e) {
                console.error('Error loading document:', e);
                document.getElementById('center-panel').innerHTML = `
                    <div class="document-content">
                        <h2>Error loading document</h2>
                        <p style="color: #dc3545;">${e.message}</p>
                        <p>Please check the document format and try again.</p>
                    </div>
                `;
            }
        }

        // Updated restoreComments function with proper positioning
        function restoreComments(docId) {
            const comments = getStoredComments()[docId];
            if (!comments) return;
            
            Object.keys(comments).forEach(paraIndex => {
                if (paraIndex === 'general') {
                    comments[paraIndex].forEach(comment => {
                        console.log('General comment found:', comment);
                    });
                    return;
                }
                
                const paragraph = document.querySelector(`[data-para-index="${paraIndex}"]`);
                if (!paragraph) {
                    console.log(`Paragraph ${paraIndex} not found for comments`);
                    return;
                }
                
                comments[paraIndex].forEach(comment => {
                    // Find if this comment already exists in the DOM
                    const existingComment = document.querySelector(`[data-comment-id="${comment.timestamp}"]`);
                    if (existingComment) return;
                    
                    // Create a new comment element
                    const commentSpan = document.createElement('span');
                    commentSpan.className = 'comment-marker';
                    commentSpan.dataset.commentId = comment.timestamp;
                    commentSpan.dataset.originalText = comment.text || '';
                    commentSpan.style.backgroundColor = getHighlightColor(comment.type);
                    
                    // Add the comment text
                    const textNode = document.createTextNode(comment.text || '');
                    commentSpan.appendChild(textNode);
                    
                    // Create tooltip
                    const tooltip = document.createElement('div');
                    tooltip.className = 'comment-tooltip';
                    
                    const dateStr = new Date(comment.timestamp).toLocaleDateString();
                    tooltip.innerHTML = `<button onclick="editComment(${comment.timestamp})" style="margin-right:5px;">Edit</button>
                                        <button onclick="deleteComment(${comment.timestamp})">Delete</button>
                                        <div style="font-size:11px; opacity:0.8;">By ${comment.user} on ${dateStr}</div>`;
                    
                    // Add to DOM
                    commentSpan.appendChild(tooltip);
                    
                    // For now, just append to the end of the paragraph
                    // In a more advanced implementation, we would insert at the correct position
                    paragraph.appendChild(commentSpan);
                    
                    // Add a space after the comment for better readability
                    paragraph.appendChild(document.createTextNode(' '));
                });
            });
        }

        // Add this error display function
        function showError(title, message, details = null) {
            // Create error notification if it doesn't exist
            let errorDiv = document.getElementById('error-notification');
            if (!errorDiv) {
                errorDiv = document.createElement('div');
                errorDiv.id = 'error-notification';
                errorDiv.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #f8d7da;
                    color: #721c24;
                    padding: 15px;
                    border-radius: 6px;
                    border: 1px solid #f5c6cb;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                    z-index: 10000;
                    max-width: 400px;
                    display: none;
                `;
                
                errorDiv.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 8px;" id="error-title"></div>
                    <div style="margin-bottom: 10px;" id="error-message"></div>
                    <div style="
                        background: rgba(0,0,0,0.05);
                        padding: 10px;
                        border-radius: 4px;
                        font-family: monospace;
                        font-size: 12px;
                        margin-top: 10px;
                        overflow: auto;
                        max-height: 120px;
                        display: none;
                    " id="error-details"></div>
                    <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 10px;">
                        <button style="
                            padding: 6px 12px;
                            background: #6c757d;
                            color: white;
                            border: none;
                            border-radius: 4px;
                            cursor: pointer;
                        " onclick="document.getElementById('error-notification').style.display = 'none'">Dismiss</button>
                        <button style="
                            padding: 6px 12px;
                            background: #721c24;
                            color: white;
                            border: none;
                            border-radius: 4px;
                            cursor: pointer;
                        " onclick="document.getElementById('error-details').style.display = 
                            document.getElementById('error-details').style.display === 'block' ? 'none' : 'block'">Details</button>
                    </div>
                `;
                
                document.body.appendChild(errorDiv);
            }
            
            // Set error content
            document.getElementById('error-title').textContent = title;
            document.getElementById('error-message').textContent = message;
            
            if (details) {
                document.getElementById('error-details').textContent = details;
                document.getElementById('error-details').style.display = 'block';
            } else {
                document.getElementById('error-details').style.display = 'none';
            }
            
            // Show the error
            errorDiv.style.display = 'block';
            
            // Auto-hide after 10 seconds
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 10000);
        }
    
    


        // Load thread content
        function loadThreadContent(subject) {
            const data = threads[subject];
            if (!data) return;

            let html = `
                <div style="max-width: 700px;">
                    <h2>${subject}</h2>
                    <div class="thread-messages">
            `;
            
            data.messages.forEach(msg => {
                const dateStr = new Date(msg.timestamp).toLocaleString();
                const isCurrentUser = msg.user === userEmail;
                html += `
                    <div class="thread-message" style="${isCurrentUser ? 'margin-left: 20px; background: #e7f3ff;' : ''}">
                        <p>${msg.text}</p>
                        <small style="color: #6c757d;">By ${msg.user} at ${dateStr}</small>
                    </div>
                `;
            });
            
            html += `
                    </div>
                    <div class="reply-form">
                        <textarea id="reply-text" placeholder="Add a reply..."></textarea>
                        <button onclick="addReply('${subject}')">Reply</button>
                    </div>
                </div>
            `;
            
            const center = document.getElementById('center-panel');
            center.innerHTML = html;
        }

        // Add reply
        function addReply(subject) {
            const textarea = document.getElementById('reply-text');
            const text = textarea.value.trim();
            if (!text) return;

            const now = Date.now();
            const data = threads[subject];
            
            data.messages.push({
                text: text,
                timestamp: now,
                user: userEmail
            });
            
            data.lastActivity = now;
            textarea.value = '';
            
            loadThreadContent(subject);
            buildThreadList(); // Rebuild to update previews
        }

        // Lens tab switching
        document.querySelectorAll('.lens-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.lens-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                const lens = tab.dataset.lens;
                document.querySelectorAll('.document-item').forEach(doc => {
                    const lenses = doc.dataset.lenses.split(' ');
                    doc.style.display = (lens === 'all' || lenses.includes(lens)) ? 'block' : 'none';
                });
            });
        });

        // Comment functionality
        // Replace the attachCommentListeners() function with the following:
        // In attachCommentListeners(), add a contextmenu handler and use a slight delay in mouseup
        function attachCommentListeners() {
            document.querySelectorAll('.commentable').forEach(p => {
                p.style.cursor = 'text';
                // Prevent the native right-click menu
                p.addEventListener('contextmenu', (e) => { e.preventDefault(); });
                // Remove any previously attached listener to avoid duplicates
                p.removeEventListener('mouseup', commentableMouseUpHandler);
                p.addEventListener('mouseup', commentableMouseUpHandler);
            });
        }

        function commentableMouseUpHandler(e) {
            // Delay a tick so that selection has updated.
            setTimeout(() => {
                const selection = window.getSelection();
                if (!selection.isCollapsed && selection.toString().trim().length > 0) {
                    // Only show menu if selection is inside the same element.
                    const range = selection.getRangeAt(0);
                    if (!this.contains(range.commonAncestorContainer)) return;
                    // Get bounding rect of selection and then show the comment menu immediately.
                    const rect = range.getBoundingClientRect();
                    const menu = document.getElementById('comment-menu');
                    menu.style.left = (rect.left + window.scrollX) + 'px';
                    menu.style.top = (rect.bottom + window.scrollY) + 'px';
                    menu.classList.add('show');
                    // Store the current selection range for later use.
                    menu.selectionRange = range;
                }
            }, 0);
        }

        // Also, let clicking anywhere outside hide the comment menu.
        document.addEventListener('click', () => {
            document.getElementById('comment-menu').classList.remove('show');
        });
        function initializeCommentSystem() {
            attachCommentListeners();
        }

        async function init() {
            await buildLeftPanel();
            initTopicFilters();
            buildThreadList();
            initializeCommentSystem(); // Initialize comment system
        }

        function showCommentMenu(e) {
            // Prevent the menu from showing if the dialog is already open
            const dialog = document.getElementById('comment-dialog');
            if (dialog.classList.contains('show')) {
                return;
            }
            e.stopPropagation();
            const menu = document.getElementById('comment-menu');
            menu.style.left = e.pageX + 'px';
            menu.style.top = e.pageY + 'px';
            menu.classList.add('show');
            menu.targetElement = e.target;
        }

        document.addEventListener('click', () => {
            document.getElementById('comment-menu').classList.remove('show');
        });

        document.addEventListener('DOMContentLoaded', function() {
            init();
        });

        // Handle comment selection
        // Replace the comment-option click handler with the following:
        document.querySelectorAll('.comment-option').forEach(option => {
            option.addEventListener('click', (e) => {
                e.stopPropagation();
                const type = option.dataset.type; 
                const menu = document.getElementById('comment-menu');
                const range = menu.selectionRange;
                if (!range) return;
                let highlightColor = '';
                if (type === 'question') { 
                    highlightColor = 'rgba(255, 0, 0, 0.3)'; // red
                    currentCommentType = 'question';
                    // Show dialog to get comment text:
                    showCommentDialog('question');
                    currentCommentRange = range;
                    menu.classList.remove('show');
                    window.getSelection().removeAllRanges();
                    return;
                } else if (type === 'clarification') {
                    highlightColor = 'rgba(255, 255, 0, 0.3)'; // yellow
                    currentCommentType = 'clarification';
                    showCommentDialog('clarification');
                    currentCommentRange = range;
                    menu.classList.remove('show');
                    window.getSelection().removeAllRanges();
                    return;
                } else if (type === 'approved') {
                    highlightColor = 'rgba(0, 255, 0, 0.3)'; // green
                    currentCommentType = 'approved';
                    // For approved, we assume no comment text is required.
                    addHighlight(range, highlightColor, '', currentCommentType);
                }
                menu.classList.remove('show');
                window.getSelection().removeAllRanges();
            });
        });

        // Update the addHighlight function to ensure proper text handling
        function addHighlight(range, highlightColor, commentText, type) {
            const now = Date.now();
            const commentSpan = document.createElement('span');
            commentSpan.className = 'comment-marker';
            commentSpan.dataset.commentId = now;
            commentSpan.style.backgroundColor = highlightColor;
            commentSpan.style.marginLeft = '5px';
            commentSpan.style.cursor = 'pointer';
            
            // Extract and store the original text content
            const extractedContent = range.extractContents();
            const originalText = extractedContent.textContent;
            commentSpan.dataset.originalText = originalText;
            
            // Also store the surrounding context for precise positioning
            const startContainer = range.startContainer;
            const startOffset = range.startOffset;
            const endOffset = range.endOffset;
            
            // Get the paragraph text
            const paragraph = startContainer.parentElement.closest('.commentable');
            const paragraphText = paragraph.textContent;
            
            // Get the text before and after the selection
            const textBefore = paragraphText.substring(0, startOffset);
            const textAfter = paragraphText.substring(endOffset);
            
            // Add only the original text to the span
            commentSpan.appendChild(extractedContent);
            
            // Insert the comment span
            range.insertNode(commentSpan);
            
            // Create tooltip
            const tooltip = document.createElement('div');
            tooltip.className = 'comment-tooltip';
            
            const dateStr = new Date(now).toLocaleDateString();
            
            let tooltipContent = '';
            if (commentText) {
                tooltipContent += `<div>${commentText}</div>`;
            }
            tooltipContent += `<div style="font-size:11px; opacity:0.8;">By ${userEmail} on ${dateStr}</div>`;
            tooltipContent += `<div style="margin-top:5px; font-size:10px;">
                                <button onclick="editComment(${now})" style="margin-right:5px;">Edit</button>
                                <button onclick="deleteComment(${now})">Delete</button>
                            </div>`;
            tooltip.innerHTML = tooltipContent;
            
            // Add tooltip to the comment span
            commentSpan.appendChild(tooltip);
            
            // Get the document ID from the active document
            const currentDocItem = document.querySelector('.document-item.active');
            if (!currentDocItem) {
                console.error('No active document found');
                return;
            }
            
            const docId = currentDocItem.dataset.id;
            const p = commentSpan.closest('.commentable');
            
            if (!p) {
                console.error('Comment target paragraph not found');
                // Still save the comment but without paragraph reference
                const comments = getStoredComments();
                comments[docId] = comments[docId] || {};
                comments[docId]['general'] = comments[docId]['general'] || [];
                comments[docId]['general'].push({
                    text: commentText,
                    user: userEmail,
                    timestamp: now,
                    type: type,
                    highlightedText: originalText,
                    contextBefore: textBefore,
                    contextAfter: textAfter
                });
                saveComments(comments);
                return;
            }
            
            const paraIndex = p.dataset.paraIndex;
            const comments = getStoredComments();
            comments[docId] = comments[docId] || {};
            comments[docId][paraIndex] = comments[docId][paraIndex] || [];
            comments[docId][paraIndex].push({
                text: commentText,
                user: userEmail,
                timestamp: now,
                type: type,
                highlightedText: originalText,
                contextBefore: textBefore,
                contextAfter: textAfter
            });
            saveComments(comments);
            
            // Save to GitHub with precise positioning information
            saveCommentToMarkdown(docId, paraIndex, type === 'question' ? '?' : type === 'clarification' ? '!' : '‚úì', 
                                commentText, userEmail, now, originalText, textBefore, textAfter);
        }



        function showCommentDialog(type) {
            const dialog = document.getElementById('comment-dialog');
            const title = document.getElementById('comment-dialog-title');
            const label = document.getElementById('comment-dialog-label');
            const textarea = document.getElementById('comment-dialog-text');

            if (type === 'question') {
                title.textContent = 'Ask Question';
                label.textContent = 'Question text:';
                textarea.placeholder = 'What would you like to clarify or ask about this section?';
            } else if (type === 'clarification') {
                title.textContent = 'Request Clarification';
                label.textContent = 'Clarification needed:';
                textarea.placeholder = 'What needs to be clarified or expanded in this section?';
            }

            textarea.value = '';
            dialog.classList.add('show');
            dialog.style.display = 'block';  // SHOW the dialog
            textarea.focus();
        }

        function hideCommentDialog() {
            const dialog = document.getElementById('comment-dialog');
            dialog.classList.remove('show');
            dialog.style.display = 'none';  // HIDE the dialog
            currentCommentType = '';
        }

        function submitComment() {
            const textarea = document.getElementById('comment-dialog-text');
            const text = textarea.value.trim();
            
            // If editing, update the comment (existing code)
            if (currentEditingInfo) {
                if (!text) {
                    alert('Please enter comment text');
                    return;
                }
                // ... (editing code unchanged) ...
                currentEditingInfo = null;
                hideCommentDialog();
                return;
            }
            
            // Ensure text is provided for question/clarification types.
            if ((currentCommentType === 'question' || currentCommentType === 'clarification') && !text) {
                alert('Please enter comment text');
                return;
            }
            
            let highlightColor = '';
            if (currentCommentType === 'question') highlightColor = 'rgba(255, 0, 0, 0.3)';
            else if (currentCommentType === 'clarification') highlightColor = 'rgba(255, 255, 0, 0.3)';
            else if (currentCommentType === 'approved') highlightColor = 'rgba(0, 255, 0, 0.3)';
            
            if (currentCommentRange) {
                addHighlight(currentCommentRange, highlightColor, text, currentCommentType);
            } else {
                console.error("No selection range available.");
            }
            hideCommentDialog();
            currentCommentRange = null;
            currentCommentType = '';
        }
        
        // ...code for editing comments

        // Global variable to track if a comment is being edited
        let currentEditingInfo = null;

        function editComment(commentTimestamp) {
            const titleElement = document.querySelector('#center-panel h1, #center-panel h2');
            if (!titleElement) {
                console.error('Cannot find document title');
                return;
            }
            const title = titleElement.textContent;
            const commentsData = getStoredComments();
            if (!commentsData[title]) {
                console.error('No comments for this document');
                return;
            }
            let found = false;
            for (const paraIndex in commentsData[title]) {
                const commentsArr = commentsData[title][paraIndex];
                for (let i = 0; i < commentsArr.length; i++) {
                    if (commentsArr[i].timestamp == commentTimestamp) {
                        // Set up editing state with necessary info
                        currentEditingInfo = {
                            title: title,
                            paraIndex: paraIndex,
                            commentIndex: i,
                            marker: commentsArr[i].marker,
                            originalText: commentsArr[i].text,
                            // Store reference to the comment marker element in the DOM
                            domElement: document.querySelector(`[data-comment-id="${commentTimestamp}"]`)
                        };
                        found = true;
                        break;
                    }
                }
                if (found) break;
            }
            if (!found) {
                console.error('Comment not found for editing');
                return;
            }
            
            // Open the dialog prefilled for editing
            const dialog = document.getElementById('comment-dialog');
            const dlgTitle = document.getElementById('comment-dialog-title');
            const label = document.getElementById('comment-dialog-label');
            const textarea = document.getElementById('comment-dialog-text');
            
            dlgTitle.textContent = 'Edit Comment';
            label.textContent = 'Edit your comment:';
            textarea.value = currentEditingInfo.originalText;
            
            dialog.style.display = 'block';
            dialog.classList.add('show');
            textarea.focus();
        }

        async function deleteComment(commentTimestamp) {
            const commentElement = document.querySelector(`[data-comment-id="${commentTimestamp}"]`);
            
            if (!commentElement) {
                console.error('Comment element not found in DOM');
                return;
            }
            
            // Get the original text from the data attribute, not the element content
            const originalText = commentElement.dataset.originalText || 
                                // Fallback: try to extract just the highlighted text
                                Array.from(commentElement.childNodes)
                                    .filter(node => node.nodeType === Node.TEXT_NODE || 
                                                    (node.nodeType === Node.ELEMENT_NODE && 
                                                    !node.classList.contains('comment-tooltip')))
                                    .map(node => node.textContent)
                                    .join('');
            
            // Create a text node with only the original text
            const textNode = document.createTextNode(originalText);
            
            // Replace the comment element with the text node
            commentElement.parentNode.replaceChild(textNode, commentElement);
            
            // Remove from stored comments
            const titleElement = document.querySelector('#center-panel h1, #center-panel h2');
            if (!titleElement) {
                console.error('Cannot find document title');
                return;
            }
            
            const title = titleElement.textContent;
            const commentsData = getStoredComments();
            
            if (!commentsData[title]) {
                console.error('No comments for this document');
                return;
            }
            
            let found = false;
            for (const paraIndex in commentsData[title]) {
                const commentsArr = commentsData[title][paraIndex];
                for (let i = 0; i < commentsArr.length; i++) {
                    if (commentsArr[i].timestamp == commentTimestamp) {
                        commentsArr.splice(i, 1);
                        if (commentsArr.length === 0) {
                            delete commentsData[title][paraIndex];
                        }
                        found = true;
                        break;
                    }
                }
                if (found) break;
            }
            
            if (!found) {
                console.error('Comment not found for deletion in storage');
            } else {
                saveComments(commentsData);
            }

            // Get docId and paraIndex for removal
            const currentDocItem = document.querySelector('.document-item.active');
            if (currentDocItem) {
                const docId = currentDocItem.dataset.id;
                const paraIndex = commentElement.closest('.commentable')?.dataset.paraIndex;
                if (paraIndex !== undefined) {
                    await removeCommentFromMarkdown(docId, paraIndex, commentTimestamp);
                }
            }
        }


        function submitComment() {
            const textarea = document.getElementById('comment-dialog-text');
            const newText = textarea.value.trim();
            
            // If editing, update the comment (existing code remains)
            if (currentEditingInfo) {
                if (!newText) {
                    alert('Please enter comment text');
                    return;
                }
                const title = currentEditingInfo.title;
                const paraIndex = currentEditingInfo.paraIndex;
                const commentIndex = currentEditingInfo.commentIndex;
                const commentsData = getStoredComments();
                if (!commentsData[title] || !commentsData[title][paraIndex] || !commentsData[title][paraIndex][commentIndex]) {
                    console.error('Stored comment not found for editing');
                } else {
                    const newTimestamp = Date.now();
                    commentsData[title][paraIndex][commentIndex].text = newText;
                    commentsData[title][paraIndex][commentIndex].timestamp = newTimestamp;
                    saveComments(commentsData);
                    // Update the DOM element display (editing code here)
                    const domElem = currentEditingInfo.domElement;
                    if (domElem) {
                        const displayText = newText.length > 20 ? newText.substring(0, 20) + '...' : newText;
                        // Example update of inner text; adjust as needed for your tooltip structure.
                        const tooltip = domElem.querySelector('.comment-tooltip');
                        if (tooltip) {
                            const newDateStr = new Date(newTimestamp).toLocaleDateString();
                            tooltip.innerHTML = `<div>${newText}</div>
                                <div style="font-size:11px; opacity:0.8;">By ${userEmail} on ${newDateStr}</div>
                                <div style="margin-top:5px; font-size:10px;">
                                    <button onclick="editComment(${newTimestamp})" style="margin-right:5px;">Edit</button>
                                    <button onclick="deleteComment(${newTimestamp})">Delete</button>
                                </div>`;
                            domElem.dataset.commentId = newTimestamp;
                        }
                    }
                }
                currentEditingInfo = null;
                hideCommentDialog();
                return;
            }

            // For new comments: ensure text is provided if needed.
            if ((currentCommentType === 'question' || currentCommentType === 'clarification') && !newText) {
                alert('Please enter comment text');
                return;
            }
            let highlightColor = '';
            if (currentCommentType === 'question') highlightColor = 'rgba(255, 0, 0, 0.3)';
            else if (currentCommentType === 'clarification') highlightColor = 'rgba(255, 255, 0, 0.3)';
            else if (currentCommentType === 'approved') highlightColor = 'rgba(0, 255, 0, 0.3)';
            
            if (currentCommentRange) {
                addHighlight(currentCommentRange, highlightColor, newText, currentCommentType);
            } else {
                console.error("No selection range available.");
            }
            hideCommentDialog();
            currentCommentRange = null;
            currentCommentType = '';
        }

        // In addComment, ensure you set a custom data attribute so we can find the comment later:
        // Replace the existing addComment() function with the one below
        function addComment(text, marker) {
            try {
                if (!currentCommentTarget) {
                    console.error('No comment target selected');
                    return;
                }
                if (!document.contains(currentCommentTarget)) {
                    console.error('Comment target is no longer in the DOM');
                    return;
                }
                const now = Date.now();
                // Only show the date (no hour)
                const dateStr = new Date(now).toLocaleDateString();
                const commentSpan = document.createElement('span');
                commentSpan.className = 'comment-marker';
                commentSpan.dataset.commentId = now;
                commentSpan.style.marginLeft = '5px';
                commentSpan.style.cursor = 'pointer';
                
                // Create an icon element
                const iconSpan = document.createElement('span');
                iconSpan.textContent = marker;
                iconSpan.style.fontWeight = 'bold';
                
                // Create an excerpt from the comment text (first 5‚Äì7 words)
                let excerpt = '';
                if (text && text.trim()) {
                    const words = text.trim().split(' ');
                    excerpt = words.slice(0, Math.min(7, words.length)).join(' ');
                }
                const excerptSpan = document.createElement('span');
                excerptSpan.style.fontSize = '0.8em';
                excerptSpan.style.marginLeft = '3px';
                // For approved comments, use a very light sepia background with rounded corners
                if (marker === '‚úì') {
                    excerptSpan.style.background = 'rgba(244,236,221,0.8)';
                    excerptSpan.style.borderRadius = '4px';
                    excerptSpan.style.padding = '1px 3px';
                }
                excerptSpan.textContent = excerpt ? excerpt : '';
            
                // Assemble the marker (icon + excerpt)
                commentSpan.appendChild(iconSpan);
                commentSpan.appendChild(excerptSpan);
            
                // Create a tooltip with edit and delete buttons and metadata
                const tooltip = document.createElement('div');
                tooltip.className = 'comment-tooltip';
                tooltip.style.fontSize = '10px';
                tooltip.style.marginTop = '4px';
                // No hour, only date is shown
                tooltip.innerHTML = `<button onclick="editComment(${now})" style="margin-right: 5px;">Edit</button>
                                    <button onclick="deleteComment(${now})">Delete</button>
                                    <div style="font-size:11px; opacity:0.8;">By ${userEmail} on ${dateStr}</div>`;
                // Append tooltip (it may be hidden via CSS until hover)
                commentSpan.appendChild(tooltip);
            
                currentCommentTarget.appendChild(commentSpan);
            
                // Save the comment into storage (unchanged)
                const titleElement = document.querySelector('#center-panel h1, #center-panel h2');
                if (!titleElement) {
                    console.error('Could not find document title');
                    return;
                }
                const title = titleElement.textContent;
                const paraIndex = currentCommentTarget.dataset.paraIndex;
                if (paraIndex === undefined) {
                    console.error('Paragraph index not found on target element');
                    return;
                }
                const comments = getStoredComments();
                comments[title] = comments[title] || {};
                comments[title][paraIndex] = comments[title][paraIndex] || [];
                comments[title][paraIndex].push({
                    marker: marker === '?' ? '?' : marker === '!' ? '!' : '‚úì',
                    text: text || '',
                    user: userEmail,
                    timestamp: now
                });
                saveComments(comments);
                // Optionally, save as markdown:
                saveCommentToMarkdown(title, paraIndex, marker === '?' ? '?' : marker === '!' ? '!' : '‚úì', text || '', userEmail, now);
            } catch (error) {
                console.error('Error adding comment:', error);
                alert('Failed to add comment. Please try again.');
            }
        }

        // ...edit comment up to here



        // Remove the getActualFilename function entirely

        // Update the saveCommentToMarkdown function
        async function saveCommentToMarkdown(docId, paraIndex, prefix, text, user, timestamp, highlightedText, contextBefore, contextAfter) {
            // Format the markdown comment with positioning information
            const mdComment = text ? 
                `<!-- ${prefix} ${text} | ${user} | ${timestamp} | ${highlightedText} | ${contextBefore} | ${contextAfter} -->` :
                `<!-- ${prefix} | ${user} | ${timestamp} | ${highlightedText} | ${contextBefore} | ${contextAfter} -->`;
            
            try {
                const response = await fetch('/api/save-comment', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        docId,
                        paraIndex, 
                        comment: mdComment,
                        highlightedText,
                        contextBefore,
                        contextAfter
                    })
                });
                
                // [Rest of the function remains the same]
            } catch (error) {
                // [Error handling remains the same]
            }
        }

        async function removeCommentFromMarkdown(docId, paraIndex, timestamp) {
            try {
                const response = await fetch('/api/save-comment', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    docId,
                    paraIndex,
                    remove: true,
                    timestamp
                })
                });
                
                if (!response.ok) {
                const errorData = await response.json();
                showError('Removal Failed', 'Could not remove comment from file', errorData.details);
                return;
                }
                
                console.log('Comment removed from Markdown');
            } catch (error) {
                console.error('Error removing comment from Markdown:', error);
                showError('Network Error', 'Failed to connect to server for removal');
            }
        }

        // Thread selection handling - FIXED
        function attachThreadListeners() {
            document.querySelectorAll('.message-thread').forEach(thread => {
                thread.addEventListener('click', () => {
                    document.querySelectorAll('.document-item, .message-thread').forEach(i => i.classList.remove('active'));
                    thread.classList.add('active');
                    
                    const subject = thread.querySelector('.pill-subject').textContent;
                    loadThreadContent(subject);
                    
                    // Mark as read immediately
                    markThreadAsRead(subject);
                });
            });
        }

        // Modal functions
        function showOverview() {
            document.getElementById('overview-modal').classList.add('show');
        }

        function hideOverview() {
            document.getElementById('overview-modal').classList.remove('show');
        }

        // Thread form functions
        function showNewThreadForm() {
            document.getElementById('new-thread-form').classList.add('show');
        }

        function hideNewThreadForm() {
            document.getElementById('new-thread-form').classList.remove('show');
            // Clear form
            document.getElementById('thread-subject').value = '';
            document.getElementById('thread-topic').value = '';
            document.getElementById('thread-message').value = '';
        }

        function createThread() {
            const subject = document.getElementById('thread-subject').value.trim();
            const topic = document.getElementById('thread-topic').value.trim();
            const message = document.getElementById('thread-message').value.trim();
            
            if (!subject || !topic || !message) {
                alert('Please fill in all fields');
                return;
            }

            const now = Date.now();

            // Add to threads data
            threads[subject] = {
                topic: topic,
                timestamp: now,
                lastActivity: now,
                messages: [{
                    text: message,
                    timestamp: now,
                    user: userEmail
                }]
            };

            // Mark as read for creator
            markThreadAsRead(subject);

            // Rebuild interface
            buildThreadList();
            initTopicFilters();

            hideNewThreadForm();
        }

        // Initialize everything
        async function init() {
        await buildLeftPanel();
        initTopicFilters();
        buildThreadList();
        initializeCommentSystem(); // Initialize comment system
    }

        // Start the application only after DOM is fully loaded
        document.addEventListener('DOMContentLoaded', async function() {
            await init();
            const dialog = document.getElementById('comment-dialog');
            if (dialog) {
                dialog.addEventListener('click', function(e) {
                    // Prevent clicks inside the dialog from propagating to show the comment menu.
                    e.stopPropagation();
                });
            }
        });

    // Add this after initializing your comment system (for example near the end of your script)
    document.addEventListener('click', function(e) {
        const marker = e.target.closest('.comment-marker');
        if (marker) {
            // Toggle tooltip visibility on click.
            const tooltip = marker.querySelector('.comment-tooltip');
            if (tooltip) {
                tooltip.style.display = (tooltip.style.display === "block") ? "none" : "block";
                e.stopPropagation();
            }
        }
    });
    </script>
    <div id="comment-dialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
         background: white; border: 1px solid #dee2e6; border-radius: 4px; padding: 20px; z-index: 3000;">
        <h3 id="comment-dialog-title">Comment</h3>
        <label id="comment-dialog-label" for="comment-dialog-text"></label>
        <textarea id="comment-dialog-text" style="width: 100%; min-height: 80px; margin-top: 10px;"></textarea>
        <div style="margin-top: 10px; text-align: right;">
            <button onclick="hideCommentDialog()" style="margin-right: 10px;">Cancel</button>
            <button onclick="submitComment()">Submit</button>
        </div>
    </div>
</body>
</html>