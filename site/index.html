<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pattern Constellations - Footnote Comments</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <style>

        /* Formula/inline code styling */
        .formula, code {
            background: #f5f5f5;
            border: 1px solid #e0e0e0;
            border-radius: 3px;
            padding: 2px 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            color: #d63384;
            white-space: nowrap;
        }
        /* Import Inter font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        /* Set Inter as the base font for everything */
        * {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
       
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            color: #333333;
            line-height: 1.3;
            display: flex;
            flex-direction: column;
        }
        
        /* Header */
        .header {
            background: #f8f9fa;
            border-bottom: 2px solid #dee2e6;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
       
        .header h1 {
            font-size: 24px; /* Increased from 16px to be bigger than document h1 */
            color: #495057;
            font-weight: 700;
        }
       
        .header-actions {
            display: flex;
            gap: 14px;
            align-items: center;
        }
        
        .header-info {
            font-size: 12px;
            color: #6c757d;
        }
       
        .btn-overview {
            padding: 8px 16px;
            background: #502a97;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
       
        .btn-overview:hover {
            background: #68508d;
        }
       
        /* Main layout */
        .main-container {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
       
        /* Left panel - Documents */
        .left-panel {
            width: 23%;
            background: #f8f9fa;
            border-right: 1px solid #dee2e6;
            overflow-y: auto;
            padding: 15px;
            
        }
       
        .lens-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
            border-bottom: 1px solid #dee2e6;
        }
       
        .lens-tab {
            padding: 8px 12px;
            background: transparent;
            border: none;
            cursor: pointer;
            color: #6c757d;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }
       
        .lens-tab.active {
            color: #0066cc;
            border-bottom-color: #0066cc;
        }
       
        .doc-category {
            margin-bottom: 20px;
        }
       
        .doc-category h3 {
            font-size: 12px;
            text-transform: uppercase;
            color: #6c757d;
            margin-bottom: 8px;
            font-weight: 600;
        }
       
        .document-item {
            background: white;
            padding: 10px;
            margin-bottom: 5px;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid transparent;
            transition: all 0.2s;
        }
       
        .document-item:hover {
            border-color: #0066cc;
        }
       
        .document-item.active {
            background: #e7f3ff;
            border-color: #0066cc;
            font-size: 14px;
            color: black;
            line-height: 1.4;
        }

        .error-message {
            color: #dc3545;
            text-align: center;
            padding: 20px;
            font-style: italic;
        }
       
        /* Center - Main content */
        .center-panel {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            background: white;
            position: relative;
        }
        
        /* Document Typography */
        .document-content {
            max-width: 700px;
            margin: 0 auto;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 16px;
            line-height: 1.5;
            color: #333;
        }

        .document-content h1 {
            font-size: 2em; /* This is now smaller than the header title (24px vs ~32px) */
            font-weight: 600;
            margin: 2rem 0 1.5rem 0;
            line-height: 1.2;
            color: #1a1a1a;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 0.5rem;
        }

        .document-content h2 {
            font-size: 1.5em;
            font-weight: 600;
            margin: 2rem 0 1rem 0;
            line-height: 1.3;
            color: #2c3e50;
        }

        .document-content h3 {
            font-size: 1.3em;
            font-weight: 600;
            margin: 1.5rem 0 0.8rem 0;
            line-height: 1.4;
            color: #34495e;
        }

        .document-content p {
            margin: 0 0 1.2rem 0;
        }

        .document-content ul, .document-content ol {
            margin: 0 0 1.2rem 0;
            padding-left: 2rem;
        }

        .document-content li {
            margin-bottom: 0.5rem;
            line-height: 1.7;
        }

        .document-content strong {
            font-weight: 600;
            color: #1a1a1a;
        }

        .document-content em {
            font-style: italic;
        }

        /* Footnote references in text */
        .footnote-ref {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            font-size: 11px;
            font-weight: bold;
            color: white;
            text-decoration: none;
            margin: 0 2px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            top: -2px;
        }
        
        .footnote-ref.question {
            background-color: #dc3545;
        }
        
        .footnote-ref.clarification {
            background-color: #ffc107;
            color: #856404;
        }
        
        .footnote-ref.approved {
            background-color: #28a745;
        }
        
        .footnote-ref:hover {
            transform: scale(1.2);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .footnote-ref.active {
            transform: scale(1.3);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }
        
        /* Regular footnote links */
        .footnote-link {
            color: #0066cc;
            text-decoration: underline;
            font-size: 0.9em;
            cursor: pointer;
            position: relative;
            top: -2px;
        }
        
        .footnote-link:hover {
            color: #0052a3;
            text-decoration: none;
        }
        
        /* Footnotes section styling */
        .document-content hr {
            margin: 2rem 0;
            border: none;
            border-top: 1px solid #dee2e6;
        }
        
        .document-content p[id^="footnote-"] {
            font-size: 0.9em;
            line-height: 1.6;
            margin: 0.5rem 0;
            padding: 0.5rem;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        
        /* Footnote back links */
        .footnote-back {
            color: #6c757d;
            text-decoration: none;
            font-size: 0.9em;
            margin-left: 0.5em;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            transition: all 0.2s;
            display: inline-block;
        }
        
        .footnote-back:hover {
            color: #0066cc;
            background: rgba(0, 102, 204, 0.1);
            transform: translateY(-1px);
        }
        
        .footnote-back:active {
            transform: translateY(0);
        }
        
        /* Right panel - Comments */
        .right-panel {
            width: 25%;
            background: #f8f9fa;
            border-left: 1px solid #dee2e6;
            display: flex;
            flex-direction: column;
        }
       
        .comments-header {
            padding: 15px;
            background: white;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
       
        .comments-header h3 {
            font-size: 14px;
            font-weight: 600;
            color: #495057;
        }
       
        .comments-list {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }
        
        .comment-item {
            background: white;
            border-radius: 8px;
            margin-bottom: 15px;
            padding: 15px;
            border: 1px solid #e9ecef;
            transition: all 0.2s;
        }
        
        .comment-item:hover {
            border-color: #0066cc;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .comment-item.active {
            background: #e7f3ff;
            border-color: #0066cc;
        }
        
        .comment-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .comment-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            font-size: 12px;
            font-weight: bold;
            color: white;
        }
        
        .comment-number.question {
            background-color: #dc3545;
        }
        
        .comment-number.clarification {
            background-color: #ffc107;
            color: #856404;
        }
        
        .comment-number.approved {
            background-color: #28a745;
        }
        
        .comment-type {
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 500;
        }
        
        .comment-type.question {
            background: #f8d7da;
            color: #721c24;
        }
        
        .comment-type.clarification {
            background: #fff3cd;
            color: #856404;
        }
        
        .comment-type.approved {
            background: #d4edda;
            color: #155724;
        }
        
        .comment-content {
            font-size: 14px;
            line-height: 1.5;
            margin-bottom: 10px;
        }
        
        .comment-meta {
            font-size: 11px;
            color: #6c757d;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .comment-actions {
            display: flex;
            gap: 8px;
        }
        
        .comment-action {
            padding: 2px 6px;
            font-size: 10px;
            border: 1px solid #dee2e6;
            background: white;
            color: #6c757d;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .comment-action:hover {
            background: #f8f9fa;
            color: #495057;
        }
        
        /* Overview Modal */
        .overview-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
        }
       
        .overview-modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }
       
        .overview-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 1000px;
            height: 85%;
            padding: 30px;
            position: relative;
            overflow: auto;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            animation: modalSlideIn 0.3s ease-out;
        }
        
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: scale(0.9) translateY(-20px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }
       
        .overview-close {
            position: absolute;
            top: 20px;
            right: 25px;
            font-size: 28px;
            cursor: pointer;
            color: #6c757d;
            transition: color 0.2s;
        }
        
        .overview-close:hover {
            color: #343a40;
        }
       
        .overview-graph {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 35px;
            margin-top: 25px;
        }
        
        @media (max-width: 768px) {
            .overview-content {
                width: 95%;
                height: 90%;
                padding: 20px;
            }
            
            .overview-graph {
                grid-template-columns: 1fr;
                gap: 25px;
            }
            
            .overview-close {
                top: 15px;
                right: 20px;
                font-size: 24px;
            }
        }
       
        .overview-section {
            padding: 20px;
            border-radius: 10px;
            background: rgba(255,255,255,0.7);
            border: 2px solid;
            transition: all 0.3s ease;
        }
        
        .overview-section:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
        }
       
        /* Core Theory - Deep Blue */
        .overview-section.core-theory {
            border-color: #2E5BBA;
            background: linear-gradient(135deg, rgba(46, 91, 186, 0.08), rgba(46, 91, 186, 0.03));
        }
        
        .overview-section.core-theory h3 {
            color: #2E5BBA;
        }
        
        .overview-section.core-theory .overview-item {
            background: rgba(46, 91, 186, 0.1);
            border-color: #2E5BBA;
            color: #1E3A5F;
        }
        
        /* Problem Dissolutions - Warm Orange */
        .overview-section.problem-dissolutions {
            border-color: #E67E22;
            background: linear-gradient(135deg, rgba(230, 126, 34, 0.08), rgba(230, 126, 34, 0.03));
        }
        
        .overview-section.problem-dissolutions h3 {
            color: #E67E22;
        }
        
        .overview-section.problem-dissolutions .overview-item {
            background: rgba(230, 126, 34, 0.1);
            border-color: #E67E22;
            color: #A0522D;
        }
        
        /* Empirical Evidence - Forest Green */
        .overview-section.empirical-evidence {
            border-color: #27AE60;
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.08), rgba(39, 174, 96, 0.03));
        }
        
        .overview-section.empirical-evidence h3 {
            color: #27AE60;
        }
        
        .overview-section.empirical-evidence .overview-item {
            background: rgba(39, 174, 96, 0.1);
            border-color: #27AE60;
            color: #1E6344;
        }
        
        /* Connections - Rich Purple */
        .overview-section.connections {
            border-color: #8E44AD;
            background: linear-gradient(135deg, rgba(142, 68, 173, 0.08), rgba(142, 68, 173, 0.03));
        }
        
        .overview-section.connections h3 {
            color: #8E44AD;
        }
        
        .overview-section.connections .overview-item {
            background: rgba(142, 68, 173, 0.1);
            border-color: #8E44AD;
            color: #5B2C6F;
        }
       
        .overview-items {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 15px;
        }
       
        .overview-item {
            padding: 10px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            border: 1px solid;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            position: relative;
        }
        
        .overview-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            opacity: 0.9;
        }
        
        .overview-item:active {
            transform: translateY(0);
        }

        /* Disabled state for items with no documents */
        .overview-item.no-docs {
            opacity: 0.4;
            cursor: not-allowed;
            color: #6c757d !important;
            background: #f8f9fa !important;
            border-color: #dee2e6 !important;
        }

        .overview-item.no-docs:hover {
            transform: none;
            box-shadow: none;
            opacity: 0.4;
        }

        /* Tooltip for items with no documents */
        .overview-item.no-docs::after {
            content: "No docs yet here";
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 1000;
            margin-bottom: 5px;
        }

        .overview-item.no-docs:hover::after {
            opacity: 1;
            visibility: visible;
        }

        /* Tooltip for items with documents - shows document list */
        .overview-item:not(.no-docs)::before {
            content: attr(data-doc-list);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 11px;
            white-space: pre-line;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 1000;
            margin-bottom: 5px;
            max-width: 600px;
            min-width: 250px;
            text-align: left;
            line-height: 1.4;
        }

        .overview-item:not(.no-docs):hover::before {
            opacity: 1;
            visibility: visible;
        }
        
        /* Filter indicator in left panel */
        .filter-indicator {
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 10px 15px;
            margin-bottom: 15px;
            display: none;
            align-items: center;
            justify-content: space-between;
            font-size: 14px;
            color: #495057;
        }
        
        .filter-indicator.show {
            display: flex;
        }
        
        .filter-clear {
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 10px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        /* Category-specific filter indicator colors */
        .filter-indicator.core-theory {
            background: rgba(46, 91, 186, 0.1);
            border-color: #2E5BBA;
            color: #2E5BBA;
        }
        
        .filter-indicator.core-theory .filter-clear {
            background: #2E5BBA;
        }
        
        .filter-indicator.core-theory .filter-clear:hover {
            background: #1E3A5F;
        }
        
        .filter-indicator.problem-dissolutions {
            background: rgba(230, 126, 34, 0.1);
            border-color: #E67E22;
            color: #E67E22;
        }
        
        .filter-indicator.problem-dissolutions .filter-clear {
            background: #E67E22;
        }
        
        .filter-indicator.problem-dissolutions .filter-clear:hover {
            background: #A0522D;
        }
        
        .filter-indicator.empirical-evidence {
            background: rgba(39, 174, 96, 0.1);
            border-color: #27AE60;
            color: #27AE60;
        }
        
        .filter-indicator.empirical-evidence .filter-clear {
            background: #27AE60;
        }
        
        .filter-indicator.empirical-evidence .filter-clear:hover {
            background: #1E6344;
        }
        
        .filter-indicator.connections {
            background: rgba(142, 68, 173, 0.1);
            border-color: #8E44AD;
            color: #8E44AD;
        }
        
        .filter-indicator.connections .filter-clear {
            background: #8E44AD;
        }
        
        .filter-indicator.connections .filter-clear:hover {
            background: #5B2C6F;
        }
        
        .filter-indicator.methodology {
            background: rgba(46, 91, 186, 0.1);
            border-color: #2E5BBA;
            color: #2E5BBA;
        }
        
        .filter-indicator.methodology .filter-clear {
            background: #2E5BBA;
        }
        
        .filter-indicator.methodology .filter-clear:hover {
            background: #1E3A5F;
        }
        
        /* Category-specific document backgrounds when filtered */
        .document-item.filtered-core-theory {
            background: linear-gradient(135deg, rgba(46, 91, 186, 0.08), rgba(46, 91, 186, 0.03));
            border-color: #2E5BBA;
        }
        
        .document-item.filtered-problem-dissolutions {
            background: linear-gradient(135deg, rgba(230, 126, 34, 0.08), rgba(230, 126, 34, 0.03));
            border-color: #E67E22;
        }
        
        .document-item.filtered-empirical-evidence {
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.08), rgba(39, 174, 96, 0.03));
            border-color: #27AE60;
        }
        
        .document-item.filtered-connections {
            background: linear-gradient(135deg, rgba(142, 68, 173, 0.08), rgba(142, 68, 173, 0.03));
            border-color: #8E44AD;
        }
        
        .document-item.filtered-methodology {
            background: linear-gradient(135deg, rgba(46, 91, 186, 0.08), rgba(46, 91, 186, 0.03));
            border-color: #2E5BBA;
        }
        
        /* Update filter indicator colors based on category */
        .filter-indicator.core-theory {
            background: rgba(46, 91, 186, 0.1);
            border-color: #2E5BBA;
            color: #1E3A5F;
        }
        
        .filter-indicator.problem-dissolutions {
            background: rgba(230, 126, 34, 0.1);
            border-color: #E67E22;
            color: #A0522D;
        }
        
        .filter-indicator.empirical-evidence {
            background: rgba(39, 174, 96, 0.1);
            border-color: #27AE60;
            color: #1E6344;
        }
        
        .filter-indicator.connections {
            background: rgba(142, 68, 173, 0.1);
            border-color: #8E44AD;
            color: #5B2C6F;
        }
        
        .filter-indicator.methodology {
            background: rgba(46, 91, 186, 0.1);
            border-color: #2E5BBA;
            color: #1E3A5F;
        }
        
        /* Comment Menu - Pop-up after text selection */
        .comment-menu {
            position: absolute;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 4px;
            display: none;
            z-index: 1000;
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
            min-width: 160px;
            animation: fadeIn 0.15s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }
       
        .comment-menu.show {
            display: block;
        }
       
        .comment-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.15s;
            font-size: 13px;
            color: #495057;
            margin: 1px 0;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
       
        .comment-option:hover {
            background: #f8f9fa;
            color: #212529;
        }
        
        .comment-option:active {
            background: #e9ecef;
        }
       
        .comment-option-icon {
            font-size: 16px;
            width: 20px;
            text-align: center;
            flex-shrink: 0;
        }
       
        .comment-option-text {
            flex: 1;
            font-weight: 500;
        }
        
        /* Selected text highlighting */
        #document-content ::selection {
            background-color: rgba(0, 102, 204, 0.2);
        }
        
        #document-content::-moz-selection {
            background-color: rgba(0, 102, 204, 0.2);
        }
        
        /* Loading state */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6c757d;
            font-style: italic;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <h1>Pattern Constellations Research</h1>
        <div class="header-actions">
            <span id="user-info" class="header-info">Loading...</span>
            <span id="cache-info" class="header-info">Ready</span>
        </div>
    </div>
   
    <!-- Comment Menu - Pop-up after text selection -->
    <div class="comment-menu" id="comment-menu">
        <div class="comment-option" data-type="question" onclick="handleCommentOption('question')">
            <span class="comment-option-icon">?</span>
            <span class="comment-option-text">Ask question</span>
        </div>
        <div class="comment-option" data-type="clarification" onclick="handleCommentOption('clarification')">
            <span class="comment-option-icon">!</span>
            <span class="comment-option-text">Needs clarification</span>
        </div>
        <div class="comment-option" data-type="approved" onclick="handleCommentOption('approved')">
            <span class="comment-option-icon">✓</span>
            <span class="comment-option-text">Approved / Keep</span>
        </div>
    </div>
   
    <!-- Comment Dialog -->
    <div id="comment-dialog" style="display: none; position: absolute; 
         background: white; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; z-index: 3000; 
         box-shadow: 0 8px 32px rgba(0,0,0,0.12); min-width: 400px;">
        <h3 id="comment-dialog-title" style="margin: 0 0 15px 0; color: #212529;">Comment</h3>
        <label id="comment-dialog-label" for="comment-dialog-text" style="display: block; margin-bottom: 8px; font-weight: 500; color: #495057;"></label>
        <textarea id="comment-dialog-text" 
                  style="width: 100%; min-height: 80px; margin-top: 0; padding: 10px; border: 1px solid #dee2e6; 
                         border-radius: 4px; font-family: inherit; resize: vertical; font-size: 14px;"
                  onkeydown="if(event.key==='Enter' && (event.ctrlKey || event.metaKey)) submitComment()"></textarea>
        <div style="margin-top: 15px; text-align: right;">
            <button onclick="hideCommentDialog()" 
                    style="margin-right: 10px; padding: 8px 16px; border: 1px solid #dee2e6; background: white; 
                           border-radius: 4px; cursor: pointer; color: #6c757d;">Cancel</button>
            <button onclick="submitComment()" 
                    style="padding: 8px 16px; background: #0066cc; color: white; border: none; border-radius: 4px; 
                           cursor: pointer; font-weight: 500;">Submit</button>
        </div>
        <div style="margin-top: 8px; font-size: 12px; color: #6c757d; text-align: right;">
            Press Ctrl+Enter to submit
        </div>
    </div>
   
    <!-- Main container -->
    <div class="main-container">
        <!-- Left Panel - Documents -->
        <div class="left-panel">
            <!-- Project Overview button moved here -->
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                <button class="btn-overview" onclick="showOverview()" style="margin-bottom: 0;">Project Overview</button>
                <span style="font-size: 12px; color: #6c757d; font-style: italic;">← overview and filter documents by subject</span>
            </div>
            
            <!-- Filter indicator moved above lens tabs -->
            <div class="filter-indicator" id="filter-indicator">
                <span id="filter-text">Filtered by: </span>
                <button class="filter-clear" onclick="clearCategoryFilter()">Clear Filter</button>
            </div>
            
            <div class="lens-tabs">
                <button class="lens-tab active" data-lens="all">All</button>
                <button class="lens-tab" data-lens="philosophy">Philosophy</button>
                <button class="lens-tab" data-lens="cognition">Cognition</button>
                <button class="lens-tab" data-lens="cs-math">CS/Math</button>
            </div>
            
            <!-- Categories will be added dynamically -->
        </div>
       
        <!-- Center - Main content -->
        <!-- Center - Main content -->
        <div class="center-panel" id="center-panel">
            <div style="max-width: 900px; margin: 0 auto; padding: 40px;">
                <h1 style="color: #2c3e50; margin-bottom: 20px;">Pattern Constellations Research</h1>
                <p style="color: #495057; margin-bottom: 20px; font-size: 14px; line-height: 1.6;">
                    <strong>1. Main Point, Scope and Method: </strong>
                    This research investigates patterns as the fundamental organizing principle of reality, proposing that what Western philosophy has traditionally separated as "pattern" (object) and "recognition" (subject) are actually a single unified event appearing dual only through conceptual analysis. The Pattern-Recognition Unity (PRU) framework operates not as another theory requiring proof, but as a lens that dissolves rather than solves classical philosophical problems—from consciousness and causation to symbol grounding and reference. The method combines empirical analysis of semantic patterns in language models (revealing rod/cap structures where literal uses cluster tightly while figurative uses disperse) with philosophical investigation and cognition and computer experiments showing how patterns emerge through repetition-based encoding in both biological and artificial neural systems. This approach bridges Dennett's compression-based pattern realism with phenomenological insights about immediate versus mediated existence, suggesting that patterns are neither purely objective regularities nor subjective impositions but unified recognition-events crystallized through iterative exposure. 
                </p>
                <p style="color: #6c757d; margin-bottom: 40px; font-size: 14px; line-height: 1.6;">
                    <strong>Research Areas and Navigation: </strong>
                    The project's interdisciplinary scope risks becoming a maze without clear organizing principles. The three domains—philosophy (metaphysics, epistemology, philosophy of mind), cognition (neural pattern-recognition, embodied cognition, consciousness studies), and computer science/mathematics (LLM architectures, semantic embeddings, information theory)—converge around the empirical discovery that meaning manifests as geometric topology in high-dimensional spaces. Navigation through this landscape requires maintaining balance between dissolution and construction: using PRI to eliminate false problems inherited from dualistic thinking while building concrete demonstrations through semantic analysis. The four research areas provide structure: "core theory" develops the pattern-constellation framework and PRI principle; "problem-dissolutions" show how traditional puzzles vanish when pattern/recognition unity is recognized; "empirical evidence" examines rod/cap structures in language models and convergent learning mechanisms across biological and artificial systems; "connections" explore resonances with Eastern non-dualism, implications for AI consciousness, and applications to fields from aesthetics to ethics. The key is remembering this isn't about adding complexity but recognizing simplicity—patterns all the way down, with recognition being the pattern itself rather than something done to it.
                </p>
                <p style="color: #6c757d; margin-bottom: 40px; font-size: 14px; line-height: 1.6;">
                    <strong>Navigation: </strong> Use the colored topic areas below to filter documents by theme, or browse the categorized document list on the left. Click the "Project Overview" button for a comprehensive view. Each document supports inline commenting—select any text to add questions, clarifications, or approvals that are saved directly to the repository.
                </p>
                
                <div class="overview-graph" style="display: grid; grid-template-columns: 1fr 1fr; gap: 35px; margin-top: 25px;">
                    <div class="overview-section core-theory">
                        <h3>Core Theory</h3>
                        <div class="overview-items">
                            <div class="overview-item" data-category="methodological-precautions" onclick="filterByCategory('methodological-precautions')">Methodological Precautions</div>
                            <div class="overview-item" data-category="pattern-constellations" onclick="filterByCategory('pattern-constellations')">Pattern Constellations</div>
                            <div class="overview-item" data-category="pattern-recognition-unity" onclick="filterByCategory('pattern-recognition-unity')">Pattern-Recognition Unity</div>
                            <div class="overview-item" data-category="learning-vs-inference" onclick="filterByCategory('learning-vs-inference')">Learning vs Inference</div>
                            <div class="overview-item" data-category="hopfield-networks" onclick="filterByCategory('hopfield-networks')">Hopfield Networks with Hebbian Learning</div>
                            <div class="overview-item" data-category="animal-cognition" onclick="filterByCategory('animal-cognition')">Animal Cognition</div>
                            <div class="overview-item" data-category="language-patterns" onclick="filterByCategory('language-patterns')">Language Pattern Constellations</div>
                        </div>
                    </div>
                
                    <div class="overview-section problem-dissolutions">
                        <h3>Problem Dissolutions</h3>
                        <div class="overview-items">
                            <div class="overview-item" data-category="reference-problem" onclick="filterByCategory('reference-problem')">Reference Problem</div>
                            <div class="overview-item" data-category="hard-problem" onclick="filterByCategory('hard-problem')">Hard Problem</div>
                            <div class="overview-item" data-category="symbol-grounding" onclick="filterByCategory('symbol-grounding')">Symbol Grounding</div>
                            <div class="overview-item" data-category="composition-problem" onclick="filterByCategory('composition-problem')">Composition Problem</div>
                        </div>
                    </div>
                
                    <div class="overview-section empirical-evidence">
                        <h3>Empirical Evidence</h3>
                        <div class="overview-items">
                            <div class="overview-item" data-category="semantic-embeddings" onclick="filterByCategory('semantic-embeddings')">Semantic Embeddings & Rod-Cap Structure</div>
                            <div class="overview-item" data-category="llms-linguistic-animals" onclick="filterByCategory('llms-linguistic-animals')">LLMs as Linguistic Animals</div>
                            <div class="overview-item" data-category="neuroscience-evidence" onclick="filterByCategory('neuroscience-evidence')">Neurosciences Evidence</div>
                            <div class="overview-item" data-category="vision-animal-model" onclick="filterByCategory('vision-animal-model')">Vision Animal Model</div>
                        </div>
                    </div>
                
                    <div class="overview-section connections">
                        <h3>Connections</h3>
                        <div class="overview-items">
                            <div class="overview-item" data-category="eastern-philosophy" onclick="filterByCategory('eastern-philosophy')">Eastern Philosophy</div>
                            <div class="overview-item" data-category="analytical-phenomenology" onclick="filterByCategory('analytical-phenomenology')">Analytical Phenomenology</div>
                            <div class="overview-item" data-category="transformer-architecture" onclick="filterByCategory('transformer-architecture')">Transformer Architecture</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
       
        <!-- Right Panel - Comments -->
        <div class="right-panel">
            <div class="comments-header">
                <h3>Comments</h3>
            </div>
            <div class="comments-list" id="comments-list">
                <div class="loading">No document selected</div>
            </div>
        </div>
    </div>
   
    <!-- Overview Modal -->
    <div class="overview-modal" id="overview-modal">
        <div class="overview-content">
            <span class="overview-close" onclick="hideOverview()">&times;</span>
            <h2 style="margin-bottom: 10px; color: #2c3e50; font-size: 28px;">Project Overview</h2>
            <p style="color: #6c757d; margin-bottom: 25px; font-size: 16px;">Pattern Recognition Identity Research - Click any item to filter documents</p>
           
            <div class="overview-graph" id="overview-graph">
                <div class="overview-section core-theory">
                    <h3>Core Theory</h3>
                    <div class="overview-items">
                        <div class="overview-item" data-category="methodological-precautions" onclick="filterByCategory('methodological-precautions')">Methodological Precautions</div>
                        <div class="overview-item" data-category="formalism" onclick="filterByCategory('formalism')">Formalism</div>
                        <div class="overview-item" data-category="pattern-constellations" onclick="filterByCategory('pattern-constellations')">Pattern Constellations</div>
                        <div class="overview-item" data-category="pattern-recognition-unity" onclick="filterByCategory('pattern-recognition-unity')">Pattern-Recognition Unity</div>
                        <div class="overview-item" data-category="learning-vs-inference" onclick="filterByCategory('learning-vs-inference')">Learning vs Inference</div>
                        <div class="overview-item" data-category="hopfield-networks" onclick="filterByCategory('hopfield-networks')">Hopfield Networks with Hebbian Learning</div>
                        <div class="overview-item" data-category="animal-cognition" onclick="filterByCategory('animal-cognition')">Animal Cognition</div>
                        <div class="overview-item" data-category="language-patterns" onclick="filterByCategory('language-patterns')">Language Pattern Constellations</div>
                    </div>
                </div>
               
                <div class="overview-section problem-dissolutions">
                    <h3>Problem Dissolutions</h3>
                    <div class="overview-items">
                        <div class="overview-item" data-category="reference-problem" onclick="filterByCategory('reference-problem')">Reference Problem</div>
                        <div class="overview-item" data-category="hard-problem" onclick="filterByCategory('hard-problem')">Hard Problem</div>
                        <div class="overview-item" data-category="symbol-grounding" onclick="filterByCategory('symbol-grounding')">Symbol Grounding</div>
                        <div class="overview-item" data-category="composition-problem" onclick="filterByCategory('composition-problem')">Composition Problem</div>
                    </div>
                </div>
               
                <div class="overview-section empirical-evidence">
                    <h3>Empirical Evidence</h3>
                    <div class="overview-items">
                        <div class="overview-item" data-category="semantic-embeddings" onclick="filterByCategory('semantic-embeddings')">Semantic Embeddings & Rod-Cap Structure</div>
                        <div class="overview-item" data-category="llms-linguistic-animals" onclick="filterByCategory('llms-linguistic-animals')">LLMs as Linguistic Animals</div>
                        <div class="overview-item" data-category="neuroscience-evidence" onclick="filterByCategory('neuroscience-evidence')">Neurosciences Evidence</div>
                        <div class="overview-item" data-category="vision-animal-model" onclick="filterByCategory('vision-animal-model')">Vision Animal Model</div>
                    </div>
                </div>
               
                <div class="overview-section connections">
                    <h3>Connections</h3>
                    <div class="overview-items">
                        <div class="overview-item" data-category="eastern-philosophy" onclick="filterByCategory('eastern-philosophy')">Eastern Philosophy</div>
                        <div class="overview-item" data-category="analytical-phenomenology" onclick="filterByCategory('analytical-phenomenology')">Analytical Phenomenology</div>
                        <div class="overview-item" data-category="transformer-architecture" onclick="filterByCategory('transformer-architecture')">Transformer Architecture</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let currentDocument = null;
        let currentComments = [];
        let nextCommentNumber = 1;
        let userEmail = 'anonymous';
        let isInitialized = false;
        let currentCommentRange = null;
        let currentCommentType = '';

        let globalData = null;
        let currentLens = 'All';

        // Category filtering functions
        let currentCategoryFilter = null;

        function renderMath() {
            const content = document.getElementById('document-content');
            if (!content || !window.renderMathInElement) return;
            
            renderMathInElement(content, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false}
                ],
                throwOnError: false
            });
        }
        
        function filterByCategory(category) {
            console.log('Filtering by category:', category);
            
            // Add visual feedback to the clicked item (only if event is available)
            if (typeof event !== 'undefined' && event.target) {
                // Check if item has no docs - if so, don't proceed
                if (event.target.classList.contains('no-docs')) {
                    return;
                }
                
                event.target.style.transform = 'scale(0.95)';
                setTimeout(() => {
                    event.target.style.transform = '';
                }, 150);
            }
            
            currentCategoryFilter = category;
            
            // Determine which broad category this specific tag belongs to
            const tagToCategoryMap = {
                'methodological-precautions': 'core-theory',
                'formalism': 'core-theory',
                'pattern-constellations': 'core-theory',
                'pattern-recognition-unity': 'core-theory',
                'learning-vs-inference': 'core-theory',
                'hopfield-networks': 'core-theory',
                'animal-cognition': 'core-theory',
                'language-patterns': 'core-theory',
                
                'reference-problem': 'problem-dissolutions',
                'hard-problem': 'problem-dissolutions',
                'symbol-grounding': 'problem-dissolutions',
                'composition-problem': 'problem-dissolutions',
                
                'semantic-embeddings': 'empirical-evidence',
                'llms-linguistic-animals': 'empirical-evidence',
                'neuroscience-evidence': 'empirical-evidence',
                'vision-animal-model': 'empirical-evidence',
                
                'eastern-philosophy': 'connections',
                'analytical-phenomenology': 'connections',
                'transformer-architecture': 'connections'
            };
            
            const broadCategory = tagToCategoryMap[category] || 'methodology';
            
            // Hide overview modal with slight delay for visual feedback
            setTimeout(() => {
                hideOverview();
            }, 200);
            
            // Show filter indicator with category-specific styling
            const filterIndicator = document.getElementById('filter-indicator');
            const filterText = document.getElementById('filter-text');
            
            // Remove existing category classes
            filterIndicator.className = 'filter-indicator show';
            // Add the broad category class for styling
            filterIndicator.classList.add(broadCategory);
            
            // Convert category to display name
            const displayName = category.replace(/-/g, ' ')
                .replace(/\b\w/g, c => c.toUpperCase());
            
            filterText.textContent = `Filtered by: ${displayName}`;
            
            // Filter documents in the left panel
            setTimeout(() => {
                applyDocumentFilter(broadCategory);
            }, 300);
        }
        
        function clearCategoryFilter() {
            console.log('Clearing category filter');
            currentCategoryFilter = null;
            
            // Remove category-specific styling from all documents
            const documents = document.querySelectorAll('.document-item');
            documents.forEach(doc => {
                doc.classList.remove('filtered-core-theory', 'filtered-problem-dissolutions', 
                                   'filtered-empirical-evidence', 'filtered-connections', 'filtered-methodology');
            });
            
            // Hide filter indicator and remove category styling
            const filterIndicator = document.getElementById('filter-indicator');
            filterIndicator.className = 'filter-indicator'; // Remove 'show' and any category classes
            
            // Show all documents again
            applyDocumentFilter();
        }
        
        function applyDocumentFilter(broadCategory = null) {
            console.log('=== DEBUG: applyDocumentFilter called ===');
            console.log('currentCategoryFilter:', currentCategoryFilter);
            console.log('broadCategory:', broadCategory);
            
            const documents = document.querySelectorAll('.document-item');
            const currentLens = document.querySelector('.lens-tab.active')?.dataset.lens || 'all';
            
            documents.forEach(doc => {
                let shouldShow = true;
                
                // Remove any existing filter classes
                doc.classList.remove('filtered-core-theory', 'filtered-problem-dissolutions', 
                                   'filtered-empirical-evidence', 'filtered-connections', 'filtered-methodology');
                
                // First check lens filter
                if (currentLens !== 'all') {
                    const docLenses = doc.dataset.lenses ? doc.dataset.lenses.split(' ') : [];
                    shouldShow = shouldShow && docLenses.includes(currentLens);
                }
                
                // Then check category filter (now using tags)
                if (currentCategoryFilter && shouldShow) {
                    const docData = doc.docData;
                    console.log('=== DEBUG: Checking document ===');
                    console.log('Document title:', docData?.title);
                    console.log('Document tags raw:', docData?.tags);
                    console.log('Document tags type:', typeof docData?.tags);
                    
                    if (docData && docData.tags) {
                        // Check if document has the specific methodology tag
                        const docTags = Array.isArray(docData.tags) ? docData.tags : [docData.tags];
                        console.log('docTags processed:', docTags);
                        
                        const hasTag = docTags.some(tag => {
                            if (!tag) return false;
                            const normalizedTag = tag.toLowerCase().replace(/\s+/g, '-');
                            const normalizedFilter = currentCategoryFilter.toLowerCase();
                            console.log(`Comparing: "${normalizedTag}" === "${normalizedFilter}" ?`, normalizedTag === normalizedFilter);
                            return normalizedTag === normalizedFilter;
                        });
                        
                        console.log('hasTag result:', hasTag);
                        shouldShow = shouldShow && hasTag;
                        
                        // If showing and we have a broad category, apply the styling
                        if (shouldShow && broadCategory) {
                            doc.classList.add(`filtered-${broadCategory}`);
                        }
                    } else {
                        console.log('No tags data found for document');
                        // No tags data - hide when category filtering
                        shouldShow = false;
                    }
                }
                
                console.log('Final shouldShow:', shouldShow);
                doc.style.display = shouldShow ? 'block' : 'none';
            });
            
            // Update document category visibility
            const categories = document.querySelectorAll('.doc-category');
            categories.forEach(category => {
                const visibleDocs = Array.from(category.querySelectorAll('.document-item')).filter(doc => 
                    doc.style.display !== 'none'
                );
                category.style.display = visibleDocs.length > 0 ? 'block' : 'none';
            });
            
            console.log('=== END DEBUG ===');
        }

        // Function to update overview items based on document availability
        function updateOverviewItems() {
            if (!globalData || !globalData.documents) {
                console.log('No globalData available for overview update');
                return;
            }

            console.log('Updating overview items based on document availability');
            
            // Get all overview items
            const overviewItems = document.querySelectorAll('.overview-item');
            
            overviewItems.forEach(item => {
                const category = item.getAttribute('data-category');
                if (!category) return;
                
                // Find documents that have this specific tag
                const docsWithTag = Object.values(globalData.documents).filter(doc => {
                    if (!doc.tags) return false;
                    const docTags = Array.isArray(doc.tags) ? doc.tags : [doc.tags];
                    return docTags.some(tag => {
                        if (!tag) return false;
                        const normalizedTag = tag.toLowerCase().replace(/\s+/g, '-');
                        const normalizedCategory = category.toLowerCase();
                        return normalizedTag === normalizedCategory;
                    });
                });

                console.log(`Category ${category}: ${docsWithTag.length} documents`);

                if (docsWithTag.length === 0) {
                    // No documents - gray out and disable
                    item.classList.add('no-docs');
                    item.onclick = null; // Remove click handler
                } else {
                    // Has documents - enable and add tooltip with document list
                    item.classList.remove('no-docs');
                    
                    // Create document list for tooltip
                    const docTitles = docsWithTag.map(doc => `• ${doc.title || doc.id.replace('.md', '')}`);
                    const docListText = `Documents (${docsWithTag.length}):\n${docTitles.join('\n')}`;
                    item.setAttribute('data-doc-list', docListText);
                    
                    // Restore click handler if it was removed
                    if (!item.onclick) {
                        item.onclick = () => filterByCategory(category);
                    }
                }
            });
        }

        // Initialize the application
        async function init() {
            if (isInitialized) return;
            isInitialized = true;
            
            try {
                await fetchUserEmail();
                await buildLeftPanel();
                
                // Update overview items after documents are loaded
                updateOverviewItems();
                
                // Add lens tab functionality
                document.querySelectorAll('.lens-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        document.querySelectorAll('.lens-tab').forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');
                        
                        // Apply both lens and category filters
                        applyDocumentFilter();
                    });
                });
                
            } catch (error) {
                console.error('Error during initialization:', error);
            }
        }

        const leftPanel = document.querySelector('.left-panel');
        let treeDiv = document.getElementById('document-tree');
        if (!treeDiv) {
            treeDiv = document.createElement('div');
            treeDiv.id = 'document-tree';
            leftPanel.appendChild(treeDiv);
        }
        // Load documents from GitHub/JSON - simplified for tags-based approach
        async function loadDocuments(forceReload = false) {
            if (globalData && !forceReload) {
                console.log('Using cached data');
                return globalData;
            }
            try {
                const response = await fetch('/api/list-documents');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                globalData = await response.json();
                console.log('Loaded data:', globalData);
                console.log('Raw documents data:', globalData.documents);
                
                // Update overview items when data is loaded
                setTimeout(updateOverviewItems, 100);
                
                return globalData;
            } catch (error) {
                console.error('Failed to load documents:', error);
                return null;
            }
        }

        function buildDocumentTree() {
            const treeDiv = document.getElementById('document-tree');
            if (!treeDiv) {
                console.error('Element #document-tree not found');
                return;
            }
            treeDiv.innerHTML = '';
            if (!globalData || !globalData.tree || Object.keys(globalData.tree).length === 0) {
                treeDiv.innerHTML = '<p>No documents available</p>';
                return;
            }

            // Normalize lens to array for filter
            const filteredDocs = Object.fromEntries(
                Object.entries(globalData.documents).filter(([, doc]) => {
                    let docLens = doc.lens || [];
                    if (typeof docLens === 'string') docLens = [docLens];
                    if (!Array.isArray(docLens)) docLens = [];
                    return currentLens === 'All' || docLens.some(l => l.toLowerCase() === currentLens.toLowerCase());
                })
            );

            if (Object.keys(filteredDocs).length === 0) {
                treeDiv.innerHTML = '<p>No documents for selected lens</p>';
                return;
            }

            // Build filtered tree (recursive inclusion if has docs or children with docs)
            const filteredTree = {};
            const addNode = (nodeId) => {
                if (filteredTree[nodeId]) return;
                const node = globalData.tree[nodeId];
                if (!node) return;
                const filteredNodeDocs = node.documents.filter(id => filteredDocs[id]);
                let hasContent = filteredNodeDocs.length > 0;
                node.children.forEach(childId => addNode(childId));
                hasContent = hasContent || node.children.some(childId => filteredTree[childId]);
                if (hasContent) {
                filteredTree[nodeId] = { ...node, documents: filteredNodeDocs };
                }
            };
            Object.keys(globalData.tree).forEach(addNode); // Build from all to include dependencies

            // Find roots
            const roots = Object.values(filteredTree).filter(node => !node.parent || !filteredTree[node.parent]);

            if (roots.length === 0) {
                treeDiv.innerHTML = '<p>No root nodes found</p>';
                return;
            }

            // Build UL recursively
            function buildUl(nodeId) {
                const node = filteredTree[nodeId];
                if (!node) return null;
                const ul = document.createElement('ul');
                const nodeLi = document.createElement('li');
                nodeLi.className = 'node-title';
                nodeLi.textContent = node.id.replace(/[-_]/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
                ul.appendChild(nodeLi);
                node.children.forEach(childId => {
                const childUl = buildUl(childId);
                if (childUl) ul.appendChild(childUl);
                });
                node.documents.forEach(docId => {
                const doc = filteredDocs[docId];
                if (doc) {
                    const docLi = document.createElement('li');
                    docLi.className = 'document-item';
                    const a = document.createElement('a');
                    a.href = `#${doc.id.replace('.md', '')}`;
                    a.textContent = doc.title || doc.id.replace('.md', '').replace(/[-_]/g, ' ');
                    a.addEventListener('click', e => {
                    e.preventDefault();
                    loadDocumentContent(doc.id);
                    });
                    docLi.appendChild(a);
                    ul.appendChild(docLi);
                }
                });
                return ul;
            }

            roots.sort((a, b) => a.id.localeCompare(b.id)).forEach(root => {
                const ul = buildUl(root.id);
                if (ul) treeDiv.appendChild(ul);
            });
            }

        // Call loadDocuments() on page load
        document.addEventListener('DOMContentLoaded', loadDocuments);

        // Fetch user email
        async function fetchUserEmail() {
            console.log('=== Fetching user email ===');
            
            try {
                console.log('Trying /api/user...');
                const res = await fetch('/api/user');
                console.log('Response status:', res.status);
                
                if (res.ok) {
                    const data = await res.json();
                    console.log('User data received:', data);
                    userEmail = data.email || data.user?.email || data.userEmail || 'anonymous';
                    console.log('Set userEmail to:', userEmail);
                } else {
                    console.warn('/api/user failed with status:', res.status);
                    throw new Error(`API returned ${res.status}`);
                }
            } catch (error) {
                console.warn('Primary user fetch failed:', error.message);
                userEmail = 'anonymous';
            }
            
            console.log('Final userEmail:', userEmail);
            
            // Update UI
            const userInfoElement = document.getElementById('user-info');
            if (userInfoElement) {
                if (userEmail === 'anonymous') {
                    userInfoElement.textContent = 'Anonymous';
                    userInfoElement.style.color = '#dc3545';
                    userInfoElement.title = 'Authentication failed - comments will be saved as anonymous';
                } else {
                    userInfoElement.textContent = userEmail;
                    userInfoElement.style.color = '#28a745';
                    userInfoElement.title = 'Authenticated user';
                }
            }
            
            console.log('=== End user email fetch ===');
        }

        // Add/ensure lens event listeners
        document.querySelectorAll('#lens-selector button').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('#lens-selector button').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            currentLens = btn.textContent.trim();
            buildDocumentTree();
        });
        });
        
        // Set default lens
        const firstLensBtn = document.querySelector('#lens-selector button');
        if (firstLensBtn) firstLensBtn.classList.add('active');
        currentLens = firstLensBtn ? firstLensBtn.textContent.trim() : 'All';
            
        // Lens listeners (rebuild without refetch)
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('#lens-selector button').forEach(btn => {
                btn.addEventListener('click', () => {
                document.querySelectorAll('#lens-selector button').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentLens = btn.textContent.trim();
                buildLeftPanel(); // Reuses cached data
                });
            });
            document.querySelector('#lens-selector button')?.classList.add('active');
        });

        // On load
        document.addEventListener('DOMContentLoaded', () => {
        loadDocuments(); 
        document.querySelector('#lens-selector button:first-child')?.classList.add('active');
        });
        // Build left panel with documents from GitHub - using tags-based organization
        async function buildLeftPanel() {
            console.log('buildLeftPanel started - tags-based approach');
            const leftPanel = document.querySelector('.left-panel');
            const treeDiv = document.getElementById('document-tree');
            if (!treeDiv) {
                console.error('Element #document-tree not found');
                return;
            }
            leftPanel.querySelectorAll('.doc-category, .error-message').forEach(el => el.remove());
            treeDiv.innerHTML = '';
            
            try {
                console.log('Fetching docsData...');
                const docsData = await loadDocuments();
                console.log('docsData received:', docsData);
                if (!docsData || !docsData.documents) {
                    treeDiv.innerHTML = '<div class="error-message">No documents found - check console for details</div>';
                    return;
                }
                
                const documents = docsData.documents;
                console.log('documents:', documents);
                if (Object.keys(documents).length === 0) {
                    treeDiv.innerHTML = '<div class="error-message">No documents available</div>';
                    return;
                }

                // Filter docs by lens
                console.log('Filtering docs by lens:', currentLens);
                const filteredDocs = Object.fromEntries(
                    Object.entries(documents).filter(([, doc]) => {
                        if (currentLens === 'All') return true;
                        const docLens = doc.lens || [];
                        return docLens.some(l => l.toLowerCase() === currentLens.toLowerCase());
                    })
                );
                
                if (Object.keys(filteredDocs).length === 0) {
                    treeDiv.innerHTML = '<div class="error-message">No documents for selected lens</div>';
                    return;
                }

                // Define broad category mappings (removed uncategorized)
                const categoryDefinitions = {
                    'core-theory': {
                        displayName: 'Core Theory',
                        order: 1
                    },
                    'reference-problem': {
                        displayName: 'The Reference Problem',
                        order: 2
                    },
                    'empirical-evidence': {
                        displayName: 'Empirical Evidence',
                        order: 3
                    },
                    'connections': {
                        displayName: 'Connections',
                        order: 4
                    },
                    'methodology': {
                        displayName: 'Methodology',
                        order: 5
                    }
                };

                // Group documents by their broad category tags
                const documentsByCategory = {};
                
                // Mapping from specific tags to broad categories
                const tagToCategoryMap = {
                    'methodological-precautions': 'core-theory',
                    'formalism': 'core-theory',
                    'pattern-constellations': 'core-theory',
                    'pattern-recognition-unity': 'core-theory',
                    'learning-vs-inference': 'core-theory',
                    'hopfield-networks': 'core-theory',
                    'animal-cognition': 'core-theory',
                    'language-patterns': 'core-theory',
                    
                    'reference-problem': 'reference-problem',
                    'hard-problem': 'reference-problem',
                    'symbol-grounding': 'reference-problem',
                    'composition-problem': 'reference-problem',
                    
                    'semantic-embeddings': 'empirical-evidence',
                    'llms-linguistic-animals': 'empirical-evidence',
                    'neuroscience-evidence': 'empirical-evidence',
                    'vision-animal-model': 'empirical-evidence',
                    
                    'eastern-philosophy': 'connections',
                    'analytical-phenomenology': 'connections',
                    'transformer-architecture': 'connections'
                };
                
                Object.entries(filteredDocs).forEach(([docId, doc]) => {
                    const docTags = doc.tags || [];
                    let assignedCategory = null;
                    
                    // First, look for explicit broad category tags
                    for (const categoryTag of ['core-theory', 'problem-dissolutions', 'empirical-evidence', 'connections', 'methodology']) {
                        if (docTags.includes(categoryTag)) {
                            assignedCategory = categoryTag;
                            break;
                        }
                    }
                    
                    // If no broad category found, infer from specific methodology tags
                    if (!assignedCategory) {
                        for (const tag of docTags) {
                            if (tagToCategoryMap[tag]) {
                                assignedCategory = tagToCategoryMap[tag];
                                break;
                            }
                        }
                    }
                    
                    // If still no category, default to methodology (instead of excluding)
                    if (!assignedCategory) {
                        assignedCategory = 'methodology';
                    }
                    
                    if (!documentsByCategory[assignedCategory]) {
                        documentsByCategory[assignedCategory] = [];
                    }
                    documentsByCategory[assignedCategory].push(doc);
                });

                console.log('Documents grouped by category:', documentsByCategory);

                // Sort categories and build the UI
                const sortedCategories = Object.keys(documentsByCategory).sort((a, b) => {
                    const orderA = categoryDefinitions[a]?.order || 99;
                    const orderB = categoryDefinitions[b]?.order || 99;
                    return orderA - orderB;
                });

                sortedCategories.forEach(categoryKey => {
                    const docs = documentsByCategory[categoryKey];
                    if (docs.length === 0) return;

                    const categoryDef = categoryDefinitions[categoryKey];
                    const categoryDiv = document.createElement('div');
                    categoryDiv.className = 'doc-category';
                    
                    const h3 = document.createElement('h3');
                    h3.textContent = categoryDef.displayName.toUpperCase();
                    categoryDiv.appendChild(h3);

                    // Sort documents by title
                    docs.sort((a, b) => (a.title || a.id).localeCompare(b.title || b.id));

                    docs.forEach(doc => {
                        console.log('Adding doc:', doc.id);
                        const item = document.createElement('div');
                        item.className = 'document-item';
                        item.dataset.id = doc.id;
                        item.dataset.lenses = (doc.lens || []).join(' ');
                        
                        // FIXED: Set docData immediately, not just on click
                        item.docData = doc;
                        
                        const title = doc.title || doc.id.replace('.md', '').replace(/[-_]/g, ' ');
                        const status = doc.status || 'draft';
                        item.innerHTML = `<div>${title}</div><span style="font-size: 11px; color: #6c757d;">• ${status}</span>`;
                        
                        item.addEventListener('click', e => {
                            e.preventDefault();
                            e.stopPropagation();
                            console.log('Document clicked:', doc);
                            document.querySelectorAll('.document-item').forEach(i => i.classList.remove('active'));
                            item.classList.add('active');
                            // docData already set above
                            loadDocument(doc);
                        });
                        
                        categoryDiv.appendChild(item);
                    });

                    treeDiv.appendChild(categoryDiv);
                });

                console.log('buildLeftPanel completed');
            } catch (error) {
                console.error('Error building left panel:', error);
                treeDiv.innerHTML = `<div class="error-message">Error loading documents<br><small style="font-size:10px;">${error.message}</small></div>`;
            }
        }

        // Load document content - no cache, always from GitHub
        async function loadDocument(doc) {
            currentDocument = doc;
            
            try {
                console.log('=== Loading document from GitHub ===');
                console.log('Loading document:', doc);
                
                const filename = doc.filename || doc.id || `${doc.id}.md`;
                console.log('Fetching fresh content from GitHub for:', filename);
                
                // Always fetch from GitHub, no cache
                let text = await fetchContentDirectlyFromGitHub(filename);
                
                if (!text) {
                    throw new Error(`Could not fetch ${filename} from GitHub`);
                }
                
                console.log('GitHub content loaded, length:', text.length);
                
                // Check for and fix encoding issues
                if (text.indexOf('\u00C3') !== -1 || text.indexOf('\u2019') !== -1) {
                    console.log('Fixing encoding issues...');
                    text = fixEncodingIssues(text);
                }
                
                // Parse markdown and extract footnotes
                const { content, footnotes } = parseMarkdownWithFootnotes(text);
                currentComments = footnotes;
                nextCommentNumber = Math.max(...footnotes.map(f => f.number), 0) + 1;
                
                // Convert to HTML with footnote references
                const htmlContent = markdownToHtml(content);
                
                // Create footnotes section for regular footnotes
                const regularFootnotes = footnotes.filter(f => !f.isComment);
                let footnotesSection = '';
                
                if (regularFootnotes.length > 0) {
                    footnotesSection = '<hr style="margin: 2rem 0; border: none; border-top: 1px solid #dee2e6;"><h3>Footnotes</h3>';
                    regularFootnotes.forEach(footnote => {
                        footnotesSection += `
                            <p id="footnote-${footnote.number}">
                                <strong>${footnote.number}.</strong> ${footnote.text} 
                                <a href="#" class="footnote-back" data-footnote-number="${footnote.number}" title="Return to text">&larr;</a>
                            </p>`;
                    });
                }
                
                // Display content
                // Display content with title and date
                const lastUpdated = new Date().toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });

                document.getElementById('center-panel').innerHTML = `
                    <article class="document-content" id="document-content">
                        <div style="margin-bottom: 2rem; padding-bottom: 1rem; border-bottom: 2px solid #e9ecef;">
                            <h1 style="margin: 0 0 0.5rem 0; font-size: 2.2em; font-weight: 600; color: #1a1a1a; border: none; padding: 0;">
                                ${doc.title || doc.id.replace('.md', '')}
                            </h1>
                            <div style="font-size: 0.9em; color: #6c757d;">
                                Last updated: ${lastUpdated}
                            </div>
                        </div>
                        ${htmlContent}
                        ${footnotesSection}
                    </article>
                `;
                setTimeout(renderMath, 50);
                
                // Display comments
                displayComments();
                
                // Add click handlers for footnote references
                addFootnoteClickHandlers();
                
                // Add text selection handlers for comments
                addTextSelectionHandlers();
                
                // Update status indicator
                const cacheInfoElement = document.getElementById('cache-info');
                if (cacheInfoElement) {
                    cacheInfoElement.textContent = `GitHub: ${new Date().toLocaleTimeString()}`;
                    cacheInfoElement.style.color = '#28a745';
                    cacheInfoElement.title = 'Content loaded fresh from GitHub';
                }
                
                console.log('=== Document loaded successfully from GitHub ===');
                
            } catch (e) {
                console.error('Error loading document from GitHub:', e);
                document.getElementById('center-panel').innerHTML = `
                    <div class="document-content">
                        <h2>Error loading document</h2>
                        <p style="color: #dc3545;">${e.message}</p>
                    </div>
                `;
                
                const cacheInfoElement = document.getElementById('cache-info');
                if (cacheInfoElement) {
                    cacheInfoElement.textContent = `Error: ${new Date().toLocaleTimeString()}`;
                    cacheInfoElement.style.color = '#dc3545';
                    cacheInfoElement.title = 'Failed to load from GitHub: ' + e.message;
                }
            }
        }

        // Fetch content directly from GitHub using new get-content endpoint
        async function fetchContentDirectlyFromGitHub(filename) {
            try {
                console.log('Fetching from GitHub via get-content API for:', filename);
                
                const response = await fetch(`/api/get-content?filename=${encodeURIComponent(filename)}`, {
                    method: 'GET',
                    headers: {
                        'Cache-Control': 'no-cache'
                    }
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.success && result.content) {
                        console.log('Successfully fetched from GitHub via get-content API');
                        console.log('Content length:', result.content.length);
                        return result.content;
                    } else {
                        console.error('API returned success=false or no content:', result);
                        return null;
                    }
                } else {
                    const errorData = await response.text();
                    console.error('Get-content API failed:', response.status, errorData);
                    return null;
                }
                
            } catch (error) {
                console.error('Error fetching from get-content API:', error);
                return null;
            }
        }

        // Fix encoding issues
        // FOR index.html - REPLACE the existing fixEncodingIssues function
// IMPORTANT: Type this manually, do NOT copy-paste to avoid syntax errors

        function fixEncodingIssues(text) {
            let fixedText = text;
            
            // Fix em dashes - type the corrupted characters manually from your document
            fixedText = fixedText.replace(/â€"/g, '—');
            fixedText = fixedText.replace(/â/g, '—');
            
            // Fix quotes - type these manually  
            fixedText = fixedText.replace(/â€œ/g, '"');
            fixedText.replace(/â€/g, '"');
            
            // Clean up Â characters around emphasis
            fixedText = fixedText.replace(/Â\*/g, '*');
            fixedText = fixedText.replace(/\*Â/g, '*');
            fixedText = fixedText.replace(/Â_/g, '_'); 
            fixedText = fixedText.replace(/_Â/g, '_');
            
            // Remove remaining Â characters
            fixedText = fixedText.replace(/Â /g, ' ');
            fixedText = fixedText.replace(/Â/g, '');
            
            // Clean up spaces
            fixedText = fixedText.replace(/  +/g, ' ');
            
            // Keep your original Unicode fixes too
            fixedText = fixedText.replace(/\u00C3/g, '');
            fixedText = fixedText.replace(/\u2014/g, '—');
            fixedText = fixedText.replace(/\u201C/g, '"');
            fixedText = fixedText.replace(/\u201D/g, '"');
            fixedText = fixedText.replace(/\u2019/g, "'");
            
            return fixedText;
        }

        // Helper function to validate that content is markdown, not HTML
        function isMarkdownContent(content) {
            // Quick checks to determine if content is markdown vs HTML
            const trimmedContent = content.trim();
            
            // If it starts with HTML doctype or html tags, it's HTML
            if (trimmedContent.startsWith('<!DOCTYPE html') || 
                trimmedContent.startsWith('<html') || 
                trimmedContent.startsWith('<HTML')) {
                return false;
            }
            
            // If it has a lot of HTML tags relative to content length, it's probably HTML
            const htmlTagRegex = /<[^>]+>/g;
            const htmlTags = trimmedContent.match(htmlTagRegex);
            const htmlTagRatio = htmlTags ? htmlTags.length / (trimmedContent.length / 100) : 0;
            
            if (htmlTagRatio > 5) { // More than 5 HTML tags per 100 characters indicates HTML
                return false;
            }
            
            // If it contains typical HTML structure elements, it's HTML
            if (trimmedContent.includes('<head>') || 
                trimmedContent.includes('<body>') || 
                trimmedContent.includes('<script>')) {
                return false;
            }
            
            // If it starts with markdown frontmatter or contains markdown elements, it's markdown
            if (trimmedContent.startsWith('---') || 
                /^#+\s/.test(trimmedContent) ||  // Headers
                /^\* /.test(trimmedContent) ||   // Bullet lists
                /^\d+\. /.test(trimmedContent) || // Numbered lists
                trimmedContent.includes('[^') || // Footnote references
                trimmedContent.includes('](')) {  // Links
                return true;
            }
            
            // If it's just plain text without much HTML, consider it markdown
            if (htmlTagRatio < 1) {
                return true;
            }
            
            return false;
        }

        // Parse markdown and extract footnotes
        function parseMarkdownWithFootnotes(content) {
            const footnoteRefs = [];
            const footnoteDefinitions = {};
            
            console.log('=== Parsing footnotes from content ===');
            console.log('Content length:', content.length);
            
            // FIRST: Clean up any corrupted JavaScript template literals that may have been saved to the file
            console.log('Cleaning up corrupted template literals...');
            content = content.replace(/\[\^\$\{[^}]+\}\]/g, ''); // Remove [^${...}] patterns
            content = content.replace(/\$\{[^}]+\}/g, ''); // Remove ${...} patterns
            content = content.replace(/\[\^n\]/g, ''); // Remove [^n] patterns  
            content = content.replace(/\[\^\\\\\]/g, ''); // Remove [^\\] patterns
            
            // Extract footnote definitions [^n]: content
            const definitionRegex = /^\[(\^[^\]]+)\]:\s*(.+?)(?=\n\[|\n\n|\n$|$)/gms;
            let match;
            const matches = [];
            
            while ((match = definitionRegex.exec(content)) !== null) {
                // Skip corrupted entries that contain template literals
                if (match[1].includes('${') || match[2].includes('${')) {
                    console.log('Skipping corrupted footnote:', match[0]);
                    continue;
                }
                
                matches.push({
                    fullMatch: match[0],
                    ref: match[1],
                    definition: match[2].trim()
                });
            }
            
            console.log('Found footnote matches:', matches);
            
            matches.forEach(({ fullMatch, ref, definition }) => {
                console.log('Processing footnote:', { ref, definition });
                
                // Try to parse as comment footnote (type:text:author:timestamp)
                const parts = definition.split(':');
                console.log('Definition parts:', parts);
                
                if (parts.length >= 5 && ['question', 'clarification', 'approved'].includes(parts[0].trim())) {
                    const type = parts[0].trim();
                    const text = parts[1].trim().replace(/\\:/g, ':');
                    const author = parts[2].trim();
                    const timestamp = parseInt(parts[3].trim());
                    const selectedText = parts[4].trim().replace(/\\:/g, ':');
                    
                    footnoteDefinitions[ref] = {
                        ref: ref,
                        number: parseInt(ref.replace('^', '')),
                        type: type,
                        text: text,
                        author: author,
                        timestamp: timestamp,
                        selectedText: selectedText,
                        isComment: true
                    };
                } else {
                    // This is a regular footnote
                    console.log('Parsed as regular footnote');
                    
                    footnoteDefinitions[ref] = {
                        ref: ref,
                        number: parseInt(ref.replace('^', '')),
                        type: 'regular',
                        text: definition,
                        author: '',
                        timestamp: 0,
                        isComment: false
                    };
                }
                
                // Remove from content
                content = content.replace(fullMatch, '').trim();
            });
            
            // Convert footnote definitions to array
            const footnotes = Object.values(footnoteDefinitions).sort((a, b) => a.number - b.number);
            
            console.log('Final parsed footnotes:', footnotes);
            console.log('Comment footnotes:', footnotes.filter(f => f.isComment));
            console.log('Regular footnotes:', footnotes.filter(f => !f.isComment));
            console.log('=== End footnote parsing ===');
            
            return { content, footnotes };
        }
        function addSectionNumbering(html) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            
            // Start counters at h2 level since h1 is the document title
            const counters = [0, 0, 0, 0, 0];  // h2, h3, h4, h5, h6
            
            doc.querySelectorAll('h2, h3, h4, h5, h6').forEach(heading => {
                const level = parseInt(heading.tagName[1]) - 2; // h2=0, h3=1, h4=2, etc.
                
                // Increment current level
                counters[level]++;
                
                // Reset all deeper levels
                for (let i = level + 1; i < 5; i++) {
                    counters[i] = 0;
                }
                
                // Build number from non-zero counters up to current level
                const number = counters.slice(0, level + 1).join('.');
                heading.textContent = `${number} ${heading.textContent}`;
            });
            
            return doc.body.innerHTML;
        }

        // Convert markdown to HTML with footnote handling
        function markdownToHtml(markdown) {
            console.log('=== Converting markdown to HTML ===');
            console.log('Input markdown length:', markdown.length);
            console.log('First 200 chars of markdown:', markdown.substring(0, 200));
            console.log('currentComments at rendering time:', currentComments);
            
            let html = markdown;
            
            // Fix \not\exists for KaTeX - ADD THIS
            html = html.replace(/\\not\\exists/g, '\\nexists');

            // Remove frontmatter
            html = html.replace(/^---[\s\S]*?---\n/, '');
            
            // NEW
            // Headers - shift down one level (title is h1, so markdown # becomes h2)
            html = html.replace(/^### (.*$)/gim, '<h4>$1</h4>');
            html = html.replace(/^## (.*$)/gim, '<h3>$1</h3>');
            html = html.replace(/^# (.*$)/gim, '<h2>$1</h2>');
            
            // IMPORTANT: Process inline code/formulas BEFORE bold/italic
            html = html.replace(/`([^`]+)`/g, '<span class="formula">$1</span>');
            
            // Bold and italic
            html = html.replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>');
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
            html = html.replace(/__(.*?)__/g, '<strong>$1</strong>');
            html = html.replace(/_(.*?)_/g, '<em>$1</em>');
            
            // Lists
            html = html.replace(/^\* (.+)$/gim, '<li>$1</li>');
            html = html.replace(/^- (.+)$/gim, '<li>$1</li>');
            html = html.replace(/^\d+\. (.+)$/gim, '<li>$1</li>');
            
            // Footnote references [^n] - but skip corrupted ones
            html = html.replace(/\[(\^[^\]]+)\]/g, (match, ref) => {
                // Skip corrupted template literal references
                if (ref.includes('${') || ref.includes('n') || ref.includes('\\')) {
                    console.log('Skipping corrupted footnote reference:', match);
                    return '';
                }
                
                const number = parseInt(ref.replace('^', ''));
                if (isNaN(number)) {
                    console.log('Skipping non-numeric footnote reference:', match);
                    return '';
                }
                
                const footnote = currentComments.find(f => f.number === number);
                
                console.log('Processing footnote reference:', { ref, number, footnote });
                
                if (footnote && footnote.isComment) {
                    // Comment footnote - colored circle
                    const type = footnote.type;
                    console.log('Rendering as comment footnote:', type);
                    return `<a href="#comment-${number}" class="footnote-ref ${type}" data-comment-number="${number}">${number}</a>`;
                } else {
                    // Regular footnote - normal underlined link
                    console.log('Rendering as regular footnote');
                    return `<a href="#footnote-${number}" class="footnote-link" id="footnote-ref-${number}" data-footnote-number="${number}">${number}</a>`;
                }
            });
            
            // Paragraphs
            html = html.replace(/\n\n/g, '</p><p>');
            html = '<p>' + html + '</p>';
            
            // Clean up empty paragraphs and fix header/list formatting
            html = html.replace(/<p><\/p>/g, '');
            html = html.replace(/<p>(<h[1-6]>)/g, '$1');
            html = html.replace(/(<\/h[1-6]>)<\/p>/g, '$1');
            html = html.replace(/<p>(<li>)/g, '<ul>$1');
            html = html.replace(/(<\/li>)<\/p>/g, '$1</ul>');

            html = addSectionNumbering(html);
            
            console.log('Final HTML length:', html.length);
            console.log('First 300 chars of HTML:', html.substring(0, 300));
            console.log('=== End markdown to HTML conversion ===');
            return html;
        }

        // Display comments in right panel (only comment footnotes)
        function displayComments() {
            console.log('=== Displaying comments ===');
            console.log('All currentComments:', currentComments);
            
            const commentsList = document.getElementById('comments-list');
            commentsList.innerHTML = '';
            
            // Filter to only show comment footnotes, not regular footnotes
            const commentFootnotes = currentComments.filter(comment => comment.isComment);
            console.log('Filtered comment footnotes:', commentFootnotes);
            
            if (commentFootnotes.length === 0) {
                console.log('No comment footnotes found, showing empty message');
                commentsList.innerHTML = '<div style="text-align: center; color: #6c757d; padding: 20px;">No comments yet</div>';
                return;
            }
            
            commentFootnotes.forEach(comment => {
                console.log('Displaying comment:', comment);
                
                const commentItem = document.createElement('div');
                commentItem.className = 'comment-item';
                commentItem.id = `comment-${comment.number}`;
                
                const typeDisplay = {
                    'question': 'Question',
                    'clarification': 'Clarification', 
                    'approved': 'Approved'
                };
                
                commentItem.innerHTML = `
                    <div class="comment-header">
                        <div class="comment-number ${comment.type}">${comment.number}</div>
                        <div class="comment-type ${comment.type}">${typeDisplay[comment.type] || comment.type}</div>
                    </div>
                    ${comment.selectedText ? `<div style="font-size: 12px; color: #6c757d; font-style: italic; margin-bottom: 8px; border-left: 2px solid #dee2e6; padding-left: 8px;">"${comment.selectedText}"</div>` : ''}
                    <div class="comment-content">${comment.text}</div>
                    <div class="comment-meta">
                        <span>By ${comment.author} - ${new Date(comment.timestamp).toLocaleDateString()}</span>
                        <div class="comment-actions">
                            <button class="comment-action" onclick="editComment(${comment.number})">Edit</button>
                            <button class="comment-action" onclick="deleteComment(${comment.number})">Delete</button>
                        </div>
                    </div>
                `;
                
                // Add click handler to highlight in document
                commentItem.addEventListener('click', () => {
                    highlightCommentInDocument(comment.number);
                });
                
                commentsList.appendChild(commentItem);
            });
            
            console.log('=== End displaying comments ===');
        }

        // Add text selection handlers for commenting
        function addTextSelectionHandlers() {
            const docContent = document.getElementById('document-content');
            if (!docContent) return;
            
            console.log('Adding text selection handlers');
            
            // Remove existing listeners
            docContent.removeEventListener('mouseup', handleTextSelection);
            docContent.removeEventListener('contextmenu', preventContextMenu);
            
            // Add new listeners
            docContent.addEventListener('mouseup', handleTextSelection);
            docContent.addEventListener('contextmenu', preventContextMenu);
        }
        
        // Handle text selection
        function handleTextSelection(e) {
            setTimeout(() => {
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();
                
                console.log('Text selected:', selectedText);
                
                if (!selection.isCollapsed && selectedText.length > 0) {
                    const range = selection.getRangeAt(0);
                    const docContent = document.getElementById('document-content');
                    
                    // Check if selection is within the document content
                    if (!docContent.contains(range.commonAncestorContainer)) {
                        console.log('Selection not in document content');
                        return;
                    }
                    
                    const rect = range.getBoundingClientRect();
                    const menu = document.getElementById('comment-menu');
                    
                    // Position menu near selection
                    menu.style.left = Math.min(rect.left + window.scrollX, window.innerWidth - 200) + 'px';
                    menu.style.top = (rect.bottom + window.scrollY + 5) + 'px';
                    menu.classList.add('show');
                    
                    // Store the range for later use
                    currentCommentRange = range.cloneRange();
                    
                    console.log('Comment menu shown at:', menu.style.left, menu.style.top);
                } else {
                    // Hide menu if no selection
                    document.getElementById('comment-menu').classList.remove('show');
                }
            }, 10);
        }
        
        // Prevent context menu on right click in document
        function preventContextMenu(e) {
            if (e.target.closest('#document-content')) {
                e.preventDefault();
            }
        }
        
        // Handle comment option selection
        function handleCommentOption(type) {
            console.log('=== handleCommentOption called ===');
            console.log('Type:', type);
            console.log('currentCommentRange:', currentCommentRange);
            
            const menu = document.getElementById('comment-menu');
            if (menu) {
                menu.classList.remove('show');
                console.log('Menu hidden');
            }
            
            if (!currentCommentRange) {
                console.error('No comment range available');
                alert('Error: No text selection found. Please select text first.');
                return;
            }
            
            currentCommentType = type;
            console.log('Comment type set to:', currentCommentType);
            
            try {
                if (type === 'approved') {
                    // For approved comments, add immediately
                    console.log('Adding approved comment immediately');
                    addComment(type, 'Approved', currentCommentRange);
                } else {
                    // For questions and clarifications, show dialog
                    console.log('Showing dialog for', type);
                    showCommentDialog(type);
                }
            } catch (error) {
                console.error('Error in handleCommentOption:', error);
                alert('Error processing comment: ' + error.message);
            }
            
            // Clear text selection
            window.getSelection().removeAllRanges();
            console.log('=== handleCommentOption complete ===');
        }

        // Add click handlers for footnote references
        function addFootnoteClickHandlers() {
            // Handle comment footnote references (colored circles)
            document.querySelectorAll('.footnote-ref').forEach(ref => {
                ref.addEventListener('click', (e) => {
                    e.preventDefault();
                    const commentNumber = parseInt(ref.dataset.commentNumber);
                    highlightCommentInPanel(commentNumber);
                });
            });
            
            // Handle regular footnote links (underlined)
            document.querySelectorAll('.footnote-link').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const footnoteNumber = parseInt(link.dataset.footnoteNumber);
                    const footnoteElement = document.getElementById(`footnote-${footnoteNumber}`);
                    if (footnoteElement) {
                        footnoteElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        // Add temporary highlight
                        footnoteElement.style.background = 'rgba(0, 102, 204, 0.1)';
                        setTimeout(() => {
                            footnoteElement.style.background = '';
                        }, 2000);
                    }
                });
            });
            
            // Handle back links from footnotes to original position
            document.querySelectorAll('.footnote-back').forEach(backLink => {
                backLink.addEventListener('click', (e) => {
                    e.preventDefault();
                    const footnoteNumber = parseInt(backLink.dataset.footnoteNumber);
                    const footnoteRef = document.getElementById(`footnote-ref-${footnoteNumber}`);
                    if (footnoteRef) {
                        footnoteRef.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        // Add temporary highlight to the reference
                        footnoteRef.style.background = 'rgba(0, 102, 204, 0.2)';
                        footnoteRef.style.borderRadius = '3px';
                        footnoteRef.style.padding = '1px 3px';
                        setTimeout(() => {
                            footnoteRef.style.background = '';
                            footnoteRef.style.borderRadius = '';
                            footnoteRef.style.padding = '';
                        }, 2000);
                    }
                });
            });
        }

        // Highlight comment in document
        function highlightCommentInDocument(commentNumber) {
            // Remove existing highlights
            document.querySelectorAll('.footnote-ref').forEach(ref => {
                ref.classList.remove('active');
            });
            
            // Highlight the specific footnote reference
            const ref = document.querySelector(`[data-comment-number="${commentNumber}"]`);
            if (ref) {
                ref.classList.add('active');
                ref.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        // Highlight comment in panel
        function highlightCommentInPanel(commentNumber) {
            // Remove existing highlights
            document.querySelectorAll('.comment-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Highlight the specific comment
            const commentItem = document.getElementById(`comment-${commentNumber}`);
            if (commentItem) {
                commentItem.classList.add('active');
                commentItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        // Add new comment (called from dialog)
        async function addComment(type, text, range) {
            console.log('addComment called with:', { type, text, range: range ? range.toString() : 'null' });
            
            if (!text) {
                alert('Please enter comment text');
                return;
            }
            if (!currentDocument) {
                alert('Please select a document first');
                return;
            }
            if (!range) {
                alert('No text selection found');
                return;
            }
            
            const selectedText = range.toString().trim();
            if (!selectedText) {
                alert('No text was selected');
                return;
            }
            
            // Strip quote block
            let cleanText = text;
            const doubleNewline = text.indexOf('\n\n');
            if (doubleNewline !== -1) {
                cleanText = text.substring(doubleNewline + 2);
            }
            cleanText = cleanText.replace(/\n+/g, ' ').replace(/:/g, '\\:').trim();
            
            let cleanSelected = selectedText.replace(/\n+/g, ' ').replace(/:/g, '\\:');
            
            const newComment = {
                number: nextCommentNumber,
                type: type,
                text: cleanText,
                author: userEmail,
                timestamp: Date.now(),
                ref: `^${nextCommentNumber}`,
                selectedText: cleanSelected,
                isComment: true
            };
            
            console.log('Creating comment:', newComment);
            
            const statusEl = document.getElementById('cache-info');
            const oldStatus = statusEl.textContent;
            statusEl.textContent = 'Saving...';
            statusEl.style.color = '#ffc107';
            
            const saveSuccess = await saveCommentToGitHub(newComment);
            
            if (saveSuccess === false) {
                statusEl.textContent = 'Save failed!';
                statusEl.style.color = '#dc3545';
                alert('Failed to save comment to GitHub. Please try again.');
                return false;
            }
            
            // Success path
            statusEl.textContent = 'Saved!';
            statusEl.style.color = '#28a745';
            setTimeout(() => {
                statusEl.textContent = oldStatus;
                statusEl.style.color = '';
            }, 2000);
            
            insertFootnoteAtRange(range, nextCommentNumber, type);
            currentComments.push(newComment);
            currentComments.sort((a, b) => a.number - b.number);
            nextCommentNumber++;
            
            displayComments();
            addFootnoteClickHandlers();
            
            setTimeout(() => {
                loadDocument(currentDocument);
            }, 500);
            
            window.getSelection().removeAllRanges();
            currentCommentRange = null;
            
            return true;
        }

        // Insert footnote reference at specific range with better positioning
        function insertFootnoteAtRange(range, number, type) {
            console.log('=== insertFootnoteAtRange FIXED version ===');
            console.log('Range details:', {
                startContainer: range.startContainer,
                endContainer: range.endContainer,
                startOffset: range.startOffset,
                endOffset: range.endOffset,
                toString: range.toString()
            });
            
            try {
                // Create footnote reference element
                const footnoteRef = document.createElement('a');
                footnoteRef.href = `#comment-${number}`;
                footnoteRef.className = `footnote-ref ${type}`;
                footnoteRef.dataset.commentNumber = number;
                footnoteRef.textContent = number;
                
                // IMPROVED: Handle insertion more reliably
                
                // Method 1: Try to insert after the end of selection
                if (range.endContainer.nodeType === Node.TEXT_NODE) {
                    // We're ending in a text node - split it and insert between
                    const textNode = range.endContainer;
                    const offset = range.endOffset;
                    
                    console.log('Inserting in text node at offset:', offset);
                    
                    // Split the text node at the end position
                    const afterText = textNode.splitText(offset);
                    
                    // Insert the footnote reference between the split nodes
                    textNode.parentNode.insertBefore(footnoteRef, afterText);
                    
                    console.log('Successfully inserted footnote reference in text node');
                    
                } else {
                    // We're ending in an element node - insert as child
                    console.log('Inserting in element node');
                    
                    if (range.endOffset < range.endContainer.childNodes.length) {
                        // Insert before the child at endOffset
                        range.endContainer.insertBefore(footnoteRef, range.endContainer.childNodes[range.endOffset]);
                    } else {
                        // Append as last child
                        range.endContainer.appendChild(footnoteRef);
                    }
                    
                    console.log('Successfully inserted footnote reference in element node');
                }
                
            } catch (error) {
                console.error('Error in insertFootnoteAtRange:', error);
                console.log('Fallback: trying simple range insertion...');
                
                // Fallback method
                try {
                    range.collapse(false); // Move to end of selection
                    range.insertNode(footnoteRef);
                    console.log('Fallback insertion successful');
                } catch (fallbackError) {
                    console.error('Even fallback insertion failed:', fallbackError);
                    alert('Failed to insert footnote reference. The comment was still saved to GitHub.');
                }
            }
            
            console.log('=== End insertFootnoteAtRange ===');
        }

        // Save comment to GitHub via API
        async function saveCommentToGitHub(comment) {
            try {
                const footnoteDefinition = `[^${comment.number}]: ${comment.type}:${comment.text}:${comment.author}:${comment.timestamp}:${comment.selectedText}`;
                
                console.log('Saving comment to GitHub:', footnoteDefinition);
                
                const response = await fetch('/api/save-comment', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        docId: currentDocument.id,
                        comment: footnoteDefinition,
                        footnoteRef: `[^${comment.number}]`,
                        selectedText: comment.selectedText,
                        type: 'footnote',
                        action: 'add'
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.text();
                    console.error('Failed to save comment to GitHub:', response.status, errorData);
                    alert('Failed to save comment to GitHub. It will be lost when you refresh.');
                    return false; // Indicate save failure
                }
                
                const result = await response.json();
                console.log('Comment saved to GitHub successfully:', result);
                
                return true; // Indicate save success
                
            } catch (error) {
                console.error('Error saving comment to GitHub:', error);
                console.log('API endpoint not available - comment will be lost on refresh.');
                return false; // Indicate save failure
            }
        }

        // Edit comment
        function editComment(commentNumber) {
            const comment = currentComments.find(c => c.number === commentNumber);
            if (!comment) return;
            
            // Show dialog with existing values
            currentCommentType = comment.type;
            showCommentDialog(comment.type, comment.text, true, commentNumber);
        }

        // Update existing comment
        async function updateComment(commentNumber, newText) {
            const comment = currentComments.find(c => c.number === commentNumber);
            if (!comment) return;
            
            if (!newText.trim()) {
                alert('Please enter comment text');
                return;
            }
            
            const oldComment = {...comment};
            comment.text = newText.trim();
            comment.timestamp = Date.now();
            
            // Update footnote reference styling (type doesn't change in edit)
            const ref = document.querySelector(`[data-comment-number="${commentNumber}"]`);
            if (ref) {
                ref.className = `footnote-ref ${comment.type}`;
            }
            
            // Save to GitHub
            const updateSuccess = await updateCommentInGitHub(oldComment, comment);
            
            // Refresh display only if update was successful
            if (updateSuccess !== false) {
                displayComments();
                setTimeout(() => {
                    loadDocument(currentDocument);
                }, 500);
                return true;
            } else {
                // Revert changes if update failed
                comment.text = oldComment.text;
                comment.timestamp = oldComment.timestamp;
                return false;
            }
        }

        // Update comment in GitHub
        async function updateCommentInGitHub(oldComment, newComment) {
            try {
                const oldFootnoteDefinition = `[^${oldComment.number}]: ${oldComment.type}:${oldComment.text}:${oldComment.author}:${oldComment.timestamp}`;
                const newFootnoteDefinition = `[^${newComment.number}]: ${newComment.type}:${newComment.text}:${newComment.author}:${newComment.timestamp}`;
                
                console.log('Updating comment in GitHub:', { old: oldFootnoteDefinition, new: newFootnoteDefinition });
                
                const response = await fetch('/api/save-comment', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        docId: currentDocument.id,
                        oldComment: oldFootnoteDefinition,
                        comment: newFootnoteDefinition,
                        type: 'footnote',
                        action: 'update'
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.text();
                    console.error('Failed to update comment in GitHub:', response.status, errorData);
                    alert('Failed to update comment in GitHub.');
                    return false;
                }
                
                const result = await response.json();
                console.log('Comment updated in GitHub successfully:', result);
                
                return true;
                
            } catch (error) {
                console.error('Error updating comment in GitHub:', error);
                return false;
            }
        }

        // Delete comment
        async function deleteComment(commentNumber) {
            if (!confirm('Are you sure you want to delete this comment?')) return;
            
            const comment = currentComments.find(c => c.number === commentNumber);
            if (!comment) return;
            
            // Save to GitHub first
            const deleteSuccess = await deleteCommentFromGitHub(comment);
            
            if (deleteSuccess !== false) {
                // Remove from array only if GitHub delete was successful
                currentComments = currentComments.filter(c => c.number !== commentNumber);
                
                // Remove footnote reference from document
                const ref = document.querySelector(`[data-comment-number="${commentNumber}"]`);
                if (ref) {
                    ref.remove();
                }
                
                // Refresh display
                displayComments();
                
                // Force document reload to show changes
                setTimeout(() => {
                    loadDocument(currentDocument);
                }, 500);
            }
        }

        // Delete comment from GitHub
        async function deleteCommentFromGitHub(comment) {
            try {
                const footnoteDefinition = `[^${comment.number}]: ${comment.type}:${comment.text}:${comment.author}:${comment.timestamp}`;
                
                console.log('Deleting comment from GitHub:', footnoteDefinition);
                
                const response = await fetch('/api/save-comment', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        docId: currentDocument.id,
                        comment: footnoteDefinition,
                        type: 'footnote',
                        action: 'delete'
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.text();
                    console.error('Failed to delete comment from GitHub:', response.status, errorData);
                    alert('Failed to delete comment from GitHub.');
                    return false;
                }
                
                const result = await response.json();
                console.log('Comment deleted from GitHub successfully:', result);
                
                return true;
                
            } catch (error) {
                console.error('Error deleting comment from GitHub:', error);
                return false;
            }
        }
        
        // Show comment dialog
        function showCommentDialog(type, existingText = '', isEdit = false, editCommentNumber = null) {
            console.log('Showing comment dialog for:', type, 'isEdit:', isEdit);
            
            const dialog = document.getElementById('comment-dialog');
            const title = document.getElementById('comment-dialog-title');
            const label = document.getElementById('comment-dialog-label');
            const textarea = document.getElementById('comment-dialog-text');
            
            if (type === 'question') {
                title.textContent = isEdit ? 'Edit Question' : 'Ask Question';
                label.textContent = 'Question text:';
                textarea.placeholder = 'What would you like to clarify or ask about this section?';
            } else if (type === 'clarification') {
                title.textContent = isEdit ? 'Edit Clarification' : 'Request Clarification';
                label.textContent = 'Clarification needed:';
                textarea.placeholder = 'What needs to be clarified or expanded in this section?';
            }
            
            // Pre-fill with selected text in quotes (if new comment)
            if (!isEdit && currentCommentRange) {
                const selectedText = currentCommentRange.toString().trim();
                if (selectedText) {
                    textarea.value = `> "${selectedText}"\n\n${existingText}`;
                } else {
                    textarea.value = existingText;
                }
            } else {
                textarea.value = existingText;
            }
            
            // Position dialog 150px above selected text
            if (currentCommentRange && !isEdit) {
                try {
                    const rect = currentCommentRange.getBoundingClientRect();
                    const dialogWidth = 400; // From CSS min-width
                    
                    // Position 150px above selection
                    let top = rect.top + window.scrollY - 150;
                    let left = rect.left + window.scrollX + (rect.width / 2) - (dialogWidth / 2);
                    
                    // Bounds checking
                    if (top < 10) top = 10; // Don't go above viewport
                    if (left < 10) left = 10; // Don't go off left edge
                    if (left + dialogWidth > window.innerWidth - 10) {
                        left = window.innerWidth - dialogWidth - 10; // Don't go off right edge
                    }
                    
                    dialog.style.top = top + 'px';
                    dialog.style.left = left + 'px';
                    dialog.style.transform = 'none'; // Remove centering transform
                    
                    console.log('Positioned dialog at:', { top, left });
                } catch (error) {
                    console.warn('Could not position dialog relative to selection, using center:', error);
                    // Fallback to center positioning
                    dialog.style.top = '50%';
                    dialog.style.left = '50%';
                    dialog.style.transform = 'translate(-50%, -50%)';
                }
            } else {
                // For edits or when no selection, center on screen
                dialog.style.top = '50%';
                dialog.style.left = '50%';
                dialog.style.transform = 'translate(-50%, -50%)';
            }
            
            dialog.style.display = 'block';
            
            // Store edit info on dialog element
            dialog.isEdit = isEdit;
            dialog.editCommentNumber = editCommentNumber;
            
            // Focus and select text
            setTimeout(() => {
                textarea.focus();
                if (existingText) {
                    textarea.select();
                }
            }, 100);
            
            console.log('Comment dialog shown');
        }
        
        // Hide comment dialog
        function hideCommentDialog() {
            console.log('Hiding comment dialog');
            const dialog = document.getElementById('comment-dialog');
            dialog.style.display = 'none';
            document.getElementById('comment-dialog-text').value = '';
            
            // Reset positioning
            dialog.style.top = '';
            dialog.style.left = '';
            dialog.style.transform = '';
            
            // Clear state
            currentCommentType = '';
            if (!dialog.isEdit) {
                currentCommentRange = null;
            }
            
            // Clear edit info
            dialog.isEdit = false;
            dialog.editCommentNumber = null;
        }
        
        // Submit comment from dialog
        // Make it async and handle save result
        async function submitComment() {
            console.log('Submitting comment');
            
            const dialog = document.getElementById('comment-dialog');
            const textarea = document.getElementById('comment-dialog-text');
            const text = textarea.value.trim();
            
            if (!text) {
                alert('Please enter comment text');
                return;
            }
            
            // Disable submit button during save
            const submitBtn = dialog.querySelector('button[onclick="submitComment()"]');
            const originalText = submitBtn.textContent;
            submitBtn.disabled = true;
            submitBtn.textContent = 'Saving...';
            
            let success = false;
            
            if (dialog.isEdit && dialog.editCommentNumber) {
                console.log('Updating existing comment:', dialog.editCommentNumber);
                success = await updateComment(dialog.editCommentNumber, text);
            } else {
                console.log('Adding new comment with range:', currentCommentRange);
                if (currentCommentRange && currentCommentType) {
                    success = await addComment(currentCommentType, text, currentCommentRange);
                } else {
                    console.error('Missing comment range or type');
                    alert('Error: Missing selection or comment type');
                    submitBtn.disabled = false;
                    submitBtn.textContent = originalText;
                    return;
                }
            }
            
            // Re-enable button
            submitBtn.disabled = false;
            submitBtn.textContent = originalText;
            
            // Only hide dialog if save succeeded
            if (success !== false) {
                hideCommentDialog();
            } else {
                // Show error in dialog
                alert('Failed to save comment. Please try again or copy your text before closing.');
            }
        }
        
        // Modal functions
        function showOverview() {
            document.getElementById('overview-modal').classList.add('show');
        }

        function hideOverview() {
            document.getElementById('overview-modal').classList.remove('show');
        }
        
        // Hide comment menu on click outside
        document.addEventListener('click', (e) => {
            const menu = document.getElementById('comment-menu');
            if (!menu.contains(e.target)) {
                menu.classList.remove('show');
            }
        });

        document.addEventListener('DOMContentLoaded', async () => {
            console.log('DOM fully loaded');
            await init();  // This calls buildLeftPanel -> loadDocuments -> buildDocumentTree after elements exist
        });
    </script>
</body>
</html>
