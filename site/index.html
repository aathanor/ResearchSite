<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pattern Constellations - Footnote Comments</title>
    <style>
        /* Import Lato font */
        @import url('https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,300;0,400;0,700;0,900;1,300;1,400;1,700;1,900&display=swap');

        /* Set Lato as the base font for everything */
        * {
            font-family: 'Lato', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
       
        body {
            font-family: 'Lato', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            color: #333333;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        /* Header */
        .header {
            background: #f8f9fa;
            border-bottom: 2px solid #dee2e6;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
       
        .header h1 {
            font-size: 16px;
            color: #495057;
        }
       
        .header-actions {
            display: flex;
            gap: 14px;
            align-items: center;
        }
        
        .header-info {
            font-size: 12px;
            color: #6c757d;
        }
       
        .btn-overview {
            padding: 8px 16px;
            background: #0066cc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
       
        .btn-overview:hover {
            background: #0052a3;
        }
       
        /* Main layout */
        .main-container {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
       
        /* Left panel - Documents */
        .left-panel {
            width: 23%;
            background: #f8f9fa;
            border-right: 1px solid #dee2e6;
            overflow-y: auto;
            padding: 15px;
        }
       
        .lens-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
            border-bottom: 1px solid #dee2e6;
        }
       
        .lens-tab {
            padding: 8px 12px;
            background: transparent;
            border: none;
            cursor: pointer;
            color: #6c757d;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }
       
        .lens-tab.active {
            color: #0066cc;
            border-bottom-color: #0066cc;
        }
       
        .doc-category {
            margin-bottom: 20px;
        }
       
        .doc-category h3 {
            font-size: 12px;
            text-transform: uppercase;
            color: #6c757d;
            margin-bottom: 8px;
            font-weight: 600;
        }
       
        .document-item {
            background: white;
            padding: 10px;
            margin-bottom: 5px;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid transparent;
            transition: all 0.2s;
        }
       
        .document-item:hover {
            border-color: #0066cc;
        }
       
        .document-item.active {
            background: #e7f3ff;
            border-color: #0066cc;
            font-size: 14px;
            color: black;
            line-height: 1.4;
        }

        .error-message {
            color: #dc3545;
            text-align: center;
            padding: 20px;
            font-style: italic;
        }
       
        /* Center - Main content */
        .center-panel {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            background: white;
            position: relative;
        }
        
        /* Document Typography */
        .document-content {
            max-width: 700px;
            margin: 0 auto;
            font-family: 'Lato', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', sans-serif;
            font-size: 16px;
            line-height: 1.3;
            color: #333;
        }

        .document-content h1 {
            font-size: 2em;
            font-weight: 600;
            margin: 2rem 0 1.5rem 0;
            line-height: 1.2;
            color: #1a1a1a;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 0.5rem;
        }

        .document-content h2 {
            font-size: 1.5em;
            font-weight: 600;
            margin: 2rem 0 1rem 0;
            line-height: 1.3;
            color: #2c3e50;
        }

        .document-content h3 {
            font-size: 1.3em;
            font-weight: 600;
            margin: 1.5rem 0 0.8rem 0;
            line-height: 1.4;
            color: #34495e;
        }

        .document-content p {
            margin: 0 0 1.2rem 0;
        }

        .document-content ul, .document-content ol {
            margin: 0 0 1.2rem 0;
            padding-left: 2rem;
        }

        .document-content li {
            margin-bottom: 0.5rem;
            line-height: 1.7;
        }

        .document-content strong {
            font-weight: 600;
            color: #1a1a1a;
        }

        .document-content em {
            font-style: italic;
        }

        /* Footnote references in text */
        .footnote-ref {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            font-size: 11px;
            font-weight: bold;
            color: white;
            text-decoration: none;
            margin: 0 2px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            top: -2px;
        }
        
        .footnote-ref.question {
            background-color: #dc3545;
        }
        
        .footnote-ref.clarification {
            background-color: #ffc107;
            color: #856404;
        }
        
        .footnote-ref.approved {
            background-color: #28a745;
        }
        
        .footnote-ref:hover {
            transform: scale(1.2);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .footnote-ref.active {
            transform: scale(1.3);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }
        
        /* Regular footnote links */
        .footnote-link {
            color: #0066cc;
            text-decoration: underline;
            font-size: 0.9em;
            cursor: pointer;
            position: relative;
            top: -2px;
        }
        
        .footnote-link:hover {
            color: #0052a3;
            text-decoration: none;
        }
        
        /* Footnotes section styling */
        .document-content hr {
            margin: 2rem 0;
            border: none;
            border-top: 1px solid #dee2e6;
        }
        
        .document-content p[id^="footnote-"] {
            font-size: 0.9em;
            line-height: 1.6;
            margin: 0.5rem 0;
            padding: 0.5rem;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        
        /* Footnote back links */
        .footnote-back {
            color: #6c757d;
            text-decoration: none;
            font-size: 0.9em;
            margin-left: 0.5em;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            transition: all 0.2s;
            display: inline-block;
        }
        
        .footnote-back:hover {
            color: #0066cc;
            background: rgba(0, 102, 204, 0.1);
            transform: translateY(-1px);
        }
        
        .footnote-back:active {
            transform: translateY(0);
        }
        
        /* Right panel - Comments */
        .right-panel {
            width: 25%;
            background: #f8f9fa;
            border-left: 1px solid #dee2e6;
            display: flex;
            flex-direction: column;
        }
       
        .comments-header {
            padding: 15px;
            background: white;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
       
        .comments-header h3 {
            font-size: 14px;
            font-weight: 600;
            color: #495057;
        }
       
        .comments-list {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }
        
        .comment-item {
            background: white;
            border-radius: 8px;
            margin-bottom: 15px;
            padding: 15px;
            border: 1px solid #e9ecef;
            transition: all 0.2s;
        }
        
        .comment-item:hover {
            border-color: #0066cc;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .comment-item.active {
            background: #e7f3ff;
            border-color: #0066cc;
        }
        
        .comment-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .comment-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            font-size: 12px;
            font-weight: bold;
            color: white;
        }
        
        .comment-number.question {
            background-color: #dc3545;
        }
        
        .comment-number.clarification {
            background-color: #ffc107;
            color: #856404;
        }
        
        .comment-number.approved {
            background-color: #28a745;
        }
        
        .comment-type {
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 500;
        }
        
        .comment-type.question {
            background: #f8d7da;
            color: #721c24;
        }
        
        .comment-type.clarification {
            background: #fff3cd;
            color: #856404;
        }
        
        .comment-type.approved {
            background: #d4edda;
            color: #155724;
        }
        
        .comment-content {
            font-size: 14px;
            line-height: 1.5;
            margin-bottom: 10px;
        }
        
        .comment-meta {
            font-size: 11px;
            color: #6c757d;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .comment-actions {
            display: flex;
            gap: 8px;
        }
        
        .comment-action {
            padding: 2px 6px;
            font-size: 10px;
            border: 1px solid #dee2e6;
            background: white;
            color: #6c757d;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .comment-action:hover {
            background: #f8f9fa;
            color: #495057;
        }
        
        /* Overview Modal */
        .overview-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
        }
       
        .overview-modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }
       
        .overview-content {
            background: white;
            border-radius: 8px;
            width: 90%;
            height: 80%;
            padding: 30px;
            position: relative;
            overflow: auto;
        }
       
        .overview-close {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 24px;
            cursor: pointer;
            color: #6c757d;
        }
       
        .overview-graph {
            display: flex;
            flex-direction: column;
            gap: 30px;
            margin-top: 20px;
        }
       
        .overview-section {
            border-left: 3px solid #0066cc;
            padding-left: 20px;
        }
       
        .overview-section h3 {
            color: #0066cc;
            margin-bottom: 10px;
        }
       
        .overview-items {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
       
        .overview-item {
            padding: 8px 15px;
            background: #f8f9fa;
            border-radius: 4px;
            font-size: 13px;
            border: 1px solid #dee2e6;
        }
       
        .overview-item.stable {
            background: #d4edda;
            border-color: #28a745;
        }
       
        .overview-item.developing {
            background: #cce5ff;
            border-color: #0066cc;
        }
       
        .overview-item.draft {
            background: #fff3cd;
            border-color: #ffc107;
        }
        
        /* Comment Menu - Pop-up after text selection */
        .comment-menu {
            position: absolute;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 4px;
            display: none;
            z-index: 1000;
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
            min-width: 160px;
            animation: fadeIn 0.15s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }
       
        .comment-menu.show {
            display: block;
        }
       
        .comment-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.15s;
            font-size: 13px;
            color: #495057;
            margin: 1px 0;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
       
        .comment-option:hover {
            background: #f8f9fa;
            color: #212529;
        }
        
        .comment-option:active {
            background: #e9ecef;
        }
       
        .comment-option-icon {
            font-size: 16px;
            width: 20px;
            text-align: center;
            flex-shrink: 0;
        }
       
        .comment-option-text {
            flex: 1;
            font-weight: 500;
        }
        
        /* Selected text highlighting */
        #document-content ::selection {
            background-color: rgba(0, 102, 204, 0.2);
        }
        
        #document-content::-moz-selection {
            background-color: rgba(0, 102, 204, 0.2);
        }
        
        /* Loading state */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6c757d;
            font-style: italic;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <h1>Pattern Constellations Research</h1>
        <div class="header-actions">
            <span id="user-info" class="header-info">Loading...</span>
            <span id="cache-info" class="header-info">Ready</span>
            <button class="btn-overview" onclick="showOverview()">Project Overview</button>
        </div>
    </div>
   
    <!-- Comment Menu - Pop-up after text selection -->
    <div class="comment-menu" id="comment-menu">
        <div class="comment-option" data-type="question" onclick="handleCommentOption('question')">
            <span class="comment-option-icon">?</span>
            <span class="comment-option-text">Ask question</span>
        </div>
        <div class="comment-option" data-type="clarification" onclick="handleCommentOption('clarification')">
            <span class="comment-option-icon">!</span>
            <span class="comment-option-text">Needs clarification</span>
        </div>
        <div class="comment-option" data-type="approved" onclick="handleCommentOption('approved')">
            <span class="comment-option-icon">✓</span>
            <span class="comment-option-text">Approved / Keep</span>
        </div>
    </div>
   
    <!-- Comment Dialog -->
    <div id="comment-dialog" style="display: none; position: absolute; 
         background: white; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; z-index: 3000; 
         box-shadow: 0 8px 32px rgba(0,0,0,0.12); min-width: 400px;">
        <h3 id="comment-dialog-title" style="margin: 0 0 15px 0; color: #212529;">Comment</h3>
        <label id="comment-dialog-label" for="comment-dialog-text" style="display: block; margin-bottom: 8px; font-weight: 500; color: #495057;"></label>
        <textarea id="comment-dialog-text" 
                  style="width: 100%; min-height: 80px; margin-top: 0; padding: 10px; border: 1px solid #dee2e6; 
                         border-radius: 4px; font-family: inherit; resize: vertical; font-size: 14px;"
                  onkeydown="if(event.key==='Enter' && (event.ctrlKey || event.metaKey)) submitComment()"></textarea>
        <div style="margin-top: 15px; text-align: right;">
            <button onclick="hideCommentDialog()" 
                    style="margin-right: 10px; padding: 8px 16px; border: 1px solid #dee2e6; background: white; 
                           border-radius: 4px; cursor: pointer; color: #6c757d;">Cancel</button>
            <button onclick="submitComment()" 
                    style="padding: 8px 16px; background: #0066cc; color: white; border: none; border-radius: 4px; 
                           cursor: pointer; font-weight: 500;">Submit</button>
        </div>
        <div style="margin-top: 8px; font-size: 12px; color: #6c757d; text-align: right;">
            Press Ctrl+Enter to submit
        </div>
    </div>
   
    <!-- Main container -->
    <div class="main-container">
        <!-- Left Panel - Documents -->
        <div class="left-panel">
            <div class="lens-tabs">
                <button class="lens-tab active" data-lens="all">All</button>
                <button class="lens-tab" data-lens="philosophy">Philosophy</button>
                <button class="lens-tab" data-lens="cognition">Cognition</button>
                <button class="lens-tab" data-lens="cs-math">CS/Math</button>
            </div>
            <!-- Categories will be added dynamically -->
        </div>
       
        <!-- Center - Main content -->
        <div class="center-panel" id="center-panel">
            <div style="max-width: 700px;">
                <div style="text-align: center; padding: 60px; color: #6c757d;">
                    <h2 style="color: #495057; margin-bottom: 10px;">Select a document to begin</h2>
                    <p>Choose a document from the left panel</p>
                </div>
            </div>
        </div>
       
        <!-- Right Panel - Comments -->
        <div class="right-panel">
            <div class="comments-header">
                <h3>Comments</h3>
            </div>
            <div class="comments-list" id="comments-list">
                <div class="loading">No document selected</div>
            </div>
        </div>
    </div>
   
    <!-- Overview Modal -->
    <div class="overview-modal" id="overview-modal">
        <div class="overview-content">
            <span class="overview-close" onclick="hideOverview()">&times;</span>
            <h2>Project Overview - Pattern Recognition Identity</h2>
           
            <div class="overview-graph">
                <div class="overview-section">
                    <h3>Core Theory</h3>
                    <div class="overview-items">
                        <div class="overview-item developing">PRI Main Thesis</div>
                        <div class="overview-item developing">Pattern-Recognition Unity</div>
                        <div class="overview-item draft">Consciousness as Reflexive PR</div>
                    </div>
                </div>
               
                <div class="overview-section">
                    <h3>Problem Dissolutions</h3>
                    <div class="overview-items">
                        <div class="overview-item stable">Hard Problem</div>
                        <div class="overview-item developing">Symbol Grounding</div>
                        <div class="overview-item draft">Quantum Measurement</div>
                        <div class="overview-item draft">Causation Problem</div>
                    </div>
                </div>
               
                <div class="overview-section">
                    <h3>Empirical Evidence</h3>
                    <div class="overview-items">
                        <div class="overview-item developing">Semantic Embeddings</div>
                        <div class="overview-item developing">Rod-Cap Structure</div>
                        <div class="overview-item draft">LLM Analysis</div>
                    </div>
                </div>
               
                <div class="overview-section">
                    <h3>Connections</h3>
                    <div class="overview-items">
                        <div class="overview-item stable">Eastern Philosophy</div>
                        <div class="overview-item developing">Transformer Architecture</div>
                        <div class="overview-item draft">Hopfield Networks</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let currentDocument = null;
        let currentComments = [];
        let nextCommentNumber = 1;
        let userEmail = 'anonymous';
        let isInitialized = false;
        let currentCommentRange = null;
        let currentCommentType = '';

        let globalData = null;
        let currentLens = 'All';

        // Initialize the application
        async function init() {
            if (isInitialized) return;
            isInitialized = true;
            
            try {
                await fetchUserEmail();
                await buildLeftPanel();
                
                // Add lens tab functionality
                document.querySelectorAll('.lens-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        document.querySelectorAll('.lens-tab').forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');
                        
                        const lens = tab.dataset.lens;
                        document.querySelectorAll('.document-item').forEach(doc => {
                            const docLenses = doc.dataset.lenses ? doc.dataset.lenses.split(' ') : [];
                            doc.style.display = (lens === 'all' || docLenses.includes(lens)) ? 'block' : 'none';
                        });
                    });
                });
                
            } catch (error) {
                console.error('Error during initialization:', error);
            }
        }

        // Load documents from GitHub/JSON
        // In your site's JavaScript (likely in index.html <script> or js/app.js):
        // Replace the static fetch with dynamic API call
        async function loadDocuments() {
            try {
                const response = await fetch('/api/list-documents');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                globalData = await response.json();
                console.log('Loaded data:', globalData);
                console.log('Raw documents data:', globalData.documents);
                buildDocumentTree();
            } catch (error) {
                console.error('Failed to load documents:', error);
                const treeDiv = document.getElementById('document-tree');
                if (treeDiv) treeDiv.innerHTML = '<p>No documents found - check console for details</p>';
            }
        }

        function buildDocumentTree() {
            const treeDiv = document.getElementById('document-tree');
            if (!treeDiv) {
                console.error('Element #document-tree not found');
                return;
            }
            treeDiv.innerHTML = '';
            if (!globalData || !globalData.tree || Object.keys(globalData.tree).length === 0) {
                treeDiv.innerHTML = '<p>No documents available</p>';
                return;
            }

            // Normalize lens to array for filter
            const filteredDocs = Object.fromEntries(
                Object.entries(globalData.documents).filter(([, doc]) => {
                    let docLens = doc.lens || [];
                    if (typeof docLens === 'string') docLens = [docLens];
                    if (!Array.isArray(docLens)) docLens = [];
                    return currentLens === 'All' || docLens.some(l => l.toLowerCase() === currentLens.toLowerCase());
                })
            );

            if (Object.keys(filteredDocs).length === 0) {
                treeDiv.innerHTML = '<p>No documents for selected lens</p>';
                return;
            }

            // Build filtered tree (recursive inclusion if has docs or children with docs)
            const filteredTree = {};
            const addNode = (nodeId) => {
                if (filteredTree[nodeId]) return;
                const node = globalData.tree[nodeId];
                if (!node) return;
                const filteredNodeDocs = node.documents.filter(id => filteredDocs[id]);
                let hasContent = filteredNodeDocs.length > 0;
                node.children.forEach(childId => addNode(childId));
                hasContent = hasContent || node.children.some(childId => filteredTree[childId]);
                if (hasContent) {
                filteredTree[nodeId] = { ...node, documents: filteredNodeDocs };
                }
            };
            Object.keys(globalData.tree).forEach(addNode); // Build from all to include dependencies

            // Find roots
            const roots = Object.values(filteredTree).filter(node => !node.parent || !filteredTree[node.parent]);

            if (roots.length === 0) {
                treeDiv.innerHTML = '<p>No root nodes found</p>';
                return;
            }

            // Build UL recursively
            function buildUl(nodeId) {
                const node = filteredTree[nodeId];
                if (!node) return null;
                const ul = document.createElement('ul');
                const nodeLi = document.createElement('li');
                nodeLi.className = 'node-title';
                nodeLi.textContent = node.id.replace(/[-_]/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
                ul.appendChild(nodeLi);
                node.children.forEach(childId => {
                const childUl = buildUl(childId);
                if (childUl) ul.appendChild(childUl);
                });
                node.documents.forEach(docId => {
                const doc = filteredDocs[docId];
                if (doc) {
                    const docLi = document.createElement('li');
                    docLi.className = 'document-item';
                    const a = document.createElement('a');
                    a.href = `#${doc.id.replace('.md', '')}`;
                    a.textContent = doc.title || doc.id.replace('.md', '').replace(/[-_]/g, ' ');
                    a.addEventListener('click', e => {
                    e.preventDefault();
                    loadDocumentContent(doc.id);
                    });
                    docLi.appendChild(a);
                    ul.appendChild(docLi);
                }
                });
                return ul;
            }

            roots.sort((a, b) => a.id.localeCompare(b.id)).forEach(root => {
                const ul = buildUl(root.id);
                if (ul) treeDiv.appendChild(ul);
            });
            }

        // Call loadDocuments() on page load
        document.addEventListener('DOMContentLoaded', loadDocuments);

        // Fetch user email
        async function fetchUserEmail() {
            console.log('=== Fetching user email ===');
            
            try {
                console.log('Trying /api/user...');
                const res = await fetch('/api/user');
                console.log('Response status:', res.status);
                
                if (res.ok) {
                    const data = await res.json();
                    console.log('User data received:', data);
                    userEmail = data.email || data.user?.email || data.userEmail || 'anonymous';
                    console.log('Set userEmail to:', userEmail);
                } else {
                    console.warn('/api/user failed with status:', res.status);
                    throw new Error(`API returned ${res.status}`);
                }
            } catch (error) {
                console.warn('Primary user fetch failed:', error.message);
                userEmail = 'anonymous';
            }
            
            console.log('Final userEmail:', userEmail);
            
            // Update UI
            const userInfoElement = document.getElementById('user-info');
            if (userInfoElement) {
                if (userEmail === 'anonymous') {
                    userInfoElement.textContent = 'Anonymous';
                    userInfoElement.style.color = '#dc3545';
                    userInfoElement.title = 'Authentication failed - comments will be saved as anonymous';
                } else {
                    userInfoElement.textContent = userEmail;
                    userInfoElement.style.color = '#28a745';
                    userInfoElement.title = 'Authenticated user';
                }
            }
            
            console.log('=== End user email fetch ===');
        }

        // Add/ensure lens event listeners
        document.querySelectorAll('#lens-selector button').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('#lens-selector button').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            currentLens = btn.textContent.trim();
            buildDocumentTree();
        });
        });
        
        // Set default lens
        const firstLensBtn = document.querySelector('#lens-selector button');
        if (firstLensBtn) firstLensBtn.classList.add('active');
        currentLens = firstLensBtn ? firstLensBtn.textContent.trim() : 'All';
            
        // Add lens event listeners (safe now)
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('#lens-selector button').forEach(btn => {
                btn.addEventListener('click', async () => {  // Add async if needed for awaits inside
                document.querySelectorAll('#lens-selector button').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentLens = btn.textContent.trim();
                await loadDocuments();  // Or buildDocumentTree() if data is cached
                });
            });
            // Set default active button
            const firstBtn = document.querySelector('#lens-selector button');
            if (firstBtn) firstBtn.classList.add('active');
        });

        document.addEventListener('DOMContentLoaded', async () => {
            console.log('DOM fully loaded');
            await init();  // This calls buildLeftPanel -> loadDocuments -> buildDocumentTree after elements exist
        });

        // On load
        document.addEventListener('DOMContentLoaded', () => {
        loadDocuments(); 
        document.querySelector('#lens-selector button:first-child')?.classList.add('active');
        });
        // Build left panel with documents from GitHub
        async function buildLeftPanel() {
            const leftPanel = document.querySelector('.left-panel');
            const treeDiv = document.getElementById('document-tree');
            if (!treeDiv) {
                console.error('Element #document-tree not found');
                return;
            }
            leftPanel.querySelectorAll('.doc-category, .error-message').forEach(el => el.remove());
            treeDiv.innerHTML = ''; // Clear tree specifically
            try {
                const docsData = await loadDocuments();
                console.log('Raw documents data:', docsData);
                if (!docsData || !docsData.documents || !docsData.tree) {
                const errorMsg = document.createElement('div');
                errorMsg.className = 'error-message';
                errorMsg.textContent = 'No documents found - check console for details';
                treeDiv.appendChild(errorMsg);
                return;
                }
                // Handle documents and tree
                const documents = docsData.documents;
                const tree = docsData.tree;
                console.log('Processed documents:', documents);
                if (Object.keys(documents).length === 0) {
                const errorMsg = document.createElement('div');
                errorMsg.className = 'error-message';
                errorMsg.textContent = 'No documents available';
                treeDiv.appendChild(errorMsg);
                return;
                }
                // Filter by currentLens
                const filteredDocs = Object.fromEntries(
                Object.entries(documents).filter(([, doc]) => {
                    let docLens = doc.lens || [];
                    if (typeof docLens === 'string') docLens = [docLens];
                    if (!Array.isArray(docLens)) docLens = [];
                    return currentLens === 'All' || docLens.some(l => l.toLowerCase() === currentLens.toLowerCase());
                })
                );
                if (Object.keys(filteredDocs).length === 0) {
                const errorMsg = document.createElement('div');
                errorMsg.className = 'error-message';
                errorMsg.textContent = 'No documents for selected lens';
                treeDiv.appendChild(errorMsg);
                return;
                }
                // Build filtered tree
                const filteredTree = {};
                Object.values(tree).forEach(node => {
                const filteredNodeDocs = node.documents.filter(id => filteredDocs[id]);
                if (filteredNodeDocs.length > 0 || node.children.some(childId => filteredTree[childId])) {
                    filteredTree[node.id] = { ...node, documents: filteredNodeDocs };
                }
                });
                // Find roots
                const roots = Object.values(filteredTree).filter(node => !node.parent || !filteredTree[node.parent]);
                if (roots.length === 0) {
                const errorMsg = document.createElement('div');
                errorMsg.className = 'error-message';
                errorMsg.textContent = 'No root nodes found';
                treeDiv.appendChild(errorMsg);
                return;
                }
                // Recursive build function for nested structure
                function buildNode(nodeId) {
                const node = filteredTree[nodeId];
                if (!node) return null;
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'doc-category';
                const h3 = document.createElement('h3');
                h3.textContent = node.id.replace(/[-_]/g, ' ').toUpperCase();
                categoryDiv.appendChild(h3);
                // Add children nodes recursively
                node.children.forEach(childId => {
                    const childNode = buildNode(childId);
                    if (childNode) categoryDiv.appendChild(childNode);
                });
                // Add documents
                node.documents.forEach(docId => {
                    const doc = filteredDocs[docId];
                    if (doc) {
                    const item = document.createElement('div');
                    item.className = 'document-item';
                    item.dataset.id = doc.id;
                    const lenses = doc.lens || [];
                    item.dataset.lenses = Array.isArray(lenses) ? lenses.join(' ') : '';
                    const title = doc.title || doc.id.replace('.md', '').replace(/[-_]/g, ' ');
                    const status = doc.status || 'draft';
                    item.innerHTML = `
                        <div>${title}</div>
                        <span style="font-size: 11px; color: #6c757d;">• ${status}</span>
                    `;
                    item.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('Document clicked:', doc);
                        document.querySelectorAll('.document-item').forEach(i => i.classList.remove('active'));
                        item.classList.add('active');
                        item.docData = doc;
                        loadDocument(doc);
                    });
                    categoryDiv.appendChild(item);
                    }
                });
                return categoryDiv;
                }
                // Append roots
                roots.sort((a, b) => a.id.localeCompare(b.id)).forEach(root => {
                const nodeDiv = buildNode(root.id);
                if (nodeDiv) treeDiv.appendChild(nodeDiv);
                });
            } catch (error) {
                console.error('Error building left panel:', error);
                const errorMsg = document.createElement('div');
                errorMsg.className = 'error-message';
                errorMsg.innerHTML = `Error loading documents<br><small style="font-size:10px;">${error.message}</small>`;
                treeDiv.appendChild(errorMsg);
            }
        }

        // Load document content - no cache, always from GitHub
        async function loadDocument(doc) {
            currentDocument = doc;
            
            try {
                console.log('=== Loading document from GitHub ===');
                console.log('Loading document:', doc);
                
                const filename = doc.filename || doc.id || `${doc.id}.md`;
                console.log('Fetching fresh content from GitHub for:', filename);
                
                // Always fetch from GitHub, no cache
                let text = await fetchContentDirectlyFromGitHub(filename);
                
                if (!text) {
                    throw new Error(`Could not fetch ${filename} from GitHub`);
                }
                
                console.log('GitHub content loaded, length:', text.length);
                
                // Check for and fix encoding issues
                if (text.indexOf('\u00C3') !== -1 || text.indexOf('\u2019') !== -1) {
                    console.log('Fixing encoding issues...');
                    text = fixEncodingIssues(text);
                }
                
                // Parse markdown and extract footnotes
                const { content, footnotes } = parseMarkdownWithFootnotes(text);
                currentComments = footnotes;
                nextCommentNumber = Math.max(...footnotes.map(f => f.number), 0) + 1;
                
                // Convert to HTML with footnote references
                const htmlContent = markdownToHtml(content);
                
                // Create footnotes section for regular footnotes
                const regularFootnotes = footnotes.filter(f => !f.isComment);
                let footnotesSection = '';
                
                if (regularFootnotes.length > 0) {
                    footnotesSection = '<hr style="margin: 2rem 0; border: none; border-top: 1px solid #dee2e6;"><h3>Footnotes</h3>';
                    regularFootnotes.forEach(footnote => {
                        footnotesSection += `
                            <p id="footnote-${footnote.number}">
                                <strong>${footnote.number}.</strong> ${footnote.text} 
                                <a href="#" class="footnote-back" data-footnote-number="${footnote.number}" title="Return to text">&larr;</a>
                            </p>`;
                    });
                }
                
                // Display content
                document.getElementById('center-panel').innerHTML = `
                    <article class="document-content" id="document-content">
                        ${htmlContent}
                        ${footnotesSection}
                    </article>
                `;
                
                // Display comments
                displayComments();
                
                // Add click handlers for footnote references
                addFootnoteClickHandlers();
                
                // Add text selection handlers for comments
                addTextSelectionHandlers();
                
                // Update status indicator
                const cacheInfoElement = document.getElementById('cache-info');
                if (cacheInfoElement) {
                    cacheInfoElement.textContent = `GitHub: ${new Date().toLocaleTimeString()}`;
                    cacheInfoElement.style.color = '#28a745';
                    cacheInfoElement.title = 'Content loaded fresh from GitHub';
                }
                
                console.log('=== Document loaded successfully from GitHub ===');
                
            } catch (e) {
                console.error('Error loading document from GitHub:', e);
                document.getElementById('center-panel').innerHTML = `
                    <div class="document-content">
                        <h2>Error loading document</h2>
                        <p style="color: #dc3545;">${e.message}</p>
                    </div>
                `;
                
                const cacheInfoElement = document.getElementById('cache-info');
                if (cacheInfoElement) {
                    cacheInfoElement.textContent = `Error: ${new Date().toLocaleTimeString()}`;
                    cacheInfoElement.style.color = '#dc3545';
                    cacheInfoElement.title = 'Failed to load from GitHub: ' + e.message;
                }
            }
        }

        // Fetch content directly from GitHub using new get-content endpoint
        async function fetchContentDirectlyFromGitHub(filename) {
            try {
                console.log('Fetching from GitHub via get-content API for:', filename);
                
                const response = await fetch(`/api/get-content?filename=${encodeURIComponent(filename)}`, {
                    method: 'GET',
                    headers: {
                        'Cache-Control': 'no-cache'
                    }
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.success && result.content) {
                        console.log('Successfully fetched from GitHub via get-content API');
                        console.log('Content length:', result.content.length);
                        return result.content;
                    } else {
                        console.error('API returned success=false or no content:', result);
                        return null;
                    }
                } else {
                    const errorData = await response.text();
                    console.error('Get-content API failed:', response.status, errorData);
                    return null;
                }
                
            } catch (error) {
                console.error('Error fetching from get-content API:', error);
                return null;
            }
        }

        // Fix encoding issues
        function fixEncodingIssues(text) {
            // Common encoding issue fixes using hex escape sequences
            text = text.replace(/\u00C3/g, '');
            text = text.replace(/\u2014/g, '-'); 
            text = text.replace(/\u201C/g, '"');
            text = text.replace(/\u201D/g, '"');
            text = text.replace(/\u2019/g, "'");
            return text;
        }

        // Helper function to validate that content is markdown, not HTML
        function isMarkdownContent(content) {
            // Quick checks to determine if content is markdown vs HTML
            const trimmedContent = content.trim();
            
            // If it starts with HTML doctype or html tags, it's HTML
            if (trimmedContent.startsWith('<!DOCTYPE html') || 
                trimmedContent.startsWith('<html') || 
                trimmedContent.startsWith('<HTML')) {
                return false;
            }
            
            // If it has a lot of HTML tags relative to content length, it's probably HTML
            const htmlTagRegex = /<[^>]+>/g;
            const htmlTags = trimmedContent.match(htmlTagRegex);
            const htmlTagRatio = htmlTags ? htmlTags.length / (trimmedContent.length / 100) : 0;
            
            if (htmlTagRatio > 5) { // More than 5 HTML tags per 100 characters indicates HTML
                return false;
            }
            
            // If it contains typical HTML structure elements, it's HTML
            if (trimmedContent.includes('<head>') || 
                trimmedContent.includes('<body>') || 
                trimmedContent.includes('<script>')) {
                return false;
            }
            
            // If it starts with markdown frontmatter or contains markdown elements, it's markdown
            if (trimmedContent.startsWith('---') || 
                /^#+\s/.test(trimmedContent) ||  // Headers
                /^\* /.test(trimmedContent) ||   // Bullet lists
                /^\d+\. /.test(trimmedContent) || // Numbered lists
                trimmedContent.includes('[^') || // Footnote references
                trimmedContent.includes('](')) {  // Links
                return true;
            }
            
            // If it's just plain text without much HTML, consider it markdown
            if (htmlTagRatio < 1) {
                return true;
            }
            
            return false;
        }

        // Parse markdown and extract footnotes
        function parseMarkdownWithFootnotes(content) {
            const footnoteRefs = [];
            const footnoteDefinitions = {};
            
            console.log('=== Parsing footnotes from content ===');
            console.log('Content length:', content.length);
            
            // FIRST: Clean up any corrupted JavaScript template literals that may have been saved to the file
            console.log('Cleaning up corrupted template literals...');
            content = content.replace(/\[\^\$\{[^}]+\}\]/g, ''); // Remove [^${...}] patterns
            content = content.replace(/\$\{[^}]+\}/g, ''); // Remove ${...} patterns
            content = content.replace(/\[\^n\]/g, ''); // Remove [^n] patterns  
            content = content.replace(/\[\^\\\\\]/g, ''); // Remove [^\\] patterns
            
            // Extract footnote definitions [^n]: content
            const definitionRegex = /^\[(\^[^\]]+)\]:\s*(.+?)(?=\n\[|\n\n|\n$|$)/gms;
            let match;
            const matches = [];
            
            while ((match = definitionRegex.exec(content)) !== null) {
                // Skip corrupted entries that contain template literals
                if (match[1].includes('${') || match[2].includes('${')) {
                    console.log('Skipping corrupted footnote:', match[0]);
                    continue;
                }
                
                matches.push({
                    fullMatch: match[0],
                    ref: match[1],
                    definition: match[2].trim()
                });
            }
            
            console.log('Found footnote matches:', matches);
            
            matches.forEach(({ fullMatch, ref, definition }) => {
                console.log('Processing footnote:', { ref, definition });
                
                // Try to parse as comment footnote (type:text:author:timestamp)
                const parts = definition.split(':');
                console.log('Definition parts:', parts);
                
                if (parts.length >= 4 && ['question', 'clarification', 'approved'].includes(parts[0].trim())) {
                    // This is a comment footnote
                    const type = parts[0].trim();
                    const text = parts[1].trim();
                    const author = parts[2].trim();
                    const timestamp = parseInt(parts[3].trim());
                    
                    console.log('Parsed as comment footnote:', { type, text, author, timestamp });
                    
                    footnoteDefinitions[ref] = {
                        ref: ref,
                        number: parseInt(ref.replace('^', '')),
                        type: type,
                        text: text,
                        author: author,
                        timestamp: timestamp,
                        isComment: true
                    };
                } else {
                    // This is a regular footnote
                    console.log('Parsed as regular footnote');
                    
                    footnoteDefinitions[ref] = {
                        ref: ref,
                        number: parseInt(ref.replace('^', '')),
                        type: 'regular',
                        text: definition,
                        author: '',
                        timestamp: 0,
                        isComment: false
                    };
                }
                
                // Remove from content
                content = content.replace(fullMatch, '').trim();
            });
            
            // Convert footnote definitions to array
            const footnotes = Object.values(footnoteDefinitions).sort((a, b) => a.number - b.number);
            
            console.log('Final parsed footnotes:', footnotes);
            console.log('Comment footnotes:', footnotes.filter(f => f.isComment));
            console.log('Regular footnotes:', footnotes.filter(f => !f.isComment));
            console.log('=== End footnote parsing ===');
            
            return { content, footnotes };
        }

        // Convert markdown to HTML with footnote handling
        function markdownToHtml(markdown) {
            console.log('=== Converting markdown to HTML ===');
            console.log('Input markdown length:', markdown.length);
            console.log('First 200 chars of markdown:', markdown.substring(0, 200));
            console.log('currentComments at rendering time:', currentComments);
            
            let html = markdown;
            
            // Remove frontmatter
            html = html.replace(/^---[\s\S]*?---\n/, '');
            
            // Headers
            html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
            html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
            html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');
            
            // Bold and italic
            html = html.replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>');
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
            html = html.replace(/__(.*?)__/g, '<strong>$1</strong>');
            html = html.replace(/_(.*?)_/g, '<em>$1</em>');
            
            // Lists
            html = html.replace(/^\* (.+)$/gim, '<li>$1</li>');
            html = html.replace(/^- (.+)$/gim, '<li>$1</li>');
            html = html.replace(/^\d+\. (.+)$/gim, '<li>$1</li>');
            
            // Footnote references [^n] - but skip corrupted ones
            html = html.replace(/\[(\^[^\]]+)\]/g, (match, ref) => {
                // Skip corrupted template literal references
                if (ref.includes('${') || ref.includes('n') || ref.includes('\\')) {
                    console.log('Skipping corrupted footnote reference:', match);
                    return '';
                }
                
                const number = parseInt(ref.replace('^', ''));
                if (isNaN(number)) {
                    console.log('Skipping non-numeric footnote reference:', match);
                    return '';
                }
                
                const footnote = currentComments.find(f => f.number === number);
                
                console.log('Processing footnote reference:', { ref, number, footnote });
                
                if (footnote && footnote.isComment) {
                    // Comment footnote - colored circle
                    const type = footnote.type;
                    console.log('Rendering as comment footnote:', type);
                    return `<a href="#comment-${number}" class="footnote-ref ${type}" data-comment-number="${number}">${number}</a>`;
                } else {
                    // Regular footnote - normal underlined link
                    console.log('Rendering as regular footnote');
                    return `<a href="#footnote-${number}" class="footnote-link" id="footnote-ref-${number}" data-footnote-number="${number}">${number}</a>`;
                }
            });
            
            // Paragraphs
            html = html.replace(/\n\n/g, '</p><p>');
            html = '<p>' + html + '</p>';
            
            // Clean up empty paragraphs and fix header/list formatting
            html = html.replace(/<p><\/p>/g, '');
            html = html.replace(/<p>(<h[1-6]>)/g, '$1');
            html = html.replace(/(<\/h[1-6]>)<\/p>/g, '$1');
            html = html.replace(/<p>(<li>)/g, '<ul>$1');
            html = html.replace(/(<\/li>)<\/p>/g, '$1</ul>');
            
            console.log('Final HTML length:', html.length);
            console.log('First 300 chars of HTML:', html.substring(0, 300));
            console.log('=== End markdown to HTML conversion ===');
            return html;
        }

        // Display comments in right panel (only comment footnotes)
        function displayComments() {
            console.log('=== Displaying comments ===');
            console.log('All currentComments:', currentComments);
            
            const commentsList = document.getElementById('comments-list');
            commentsList.innerHTML = '';
            
            // Filter to only show comment footnotes, not regular footnotes
            const commentFootnotes = currentComments.filter(comment => comment.isComment);
            console.log('Filtered comment footnotes:', commentFootnotes);
            
            if (commentFootnotes.length === 0) {
                console.log('No comment footnotes found, showing empty message');
                commentsList.innerHTML = '<div style="text-align: center; color: #6c757d; padding: 20px;">No comments yet</div>';
                return;
            }
            
            commentFootnotes.forEach(comment => {
                console.log('Displaying comment:', comment);
                
                const commentItem = document.createElement('div');
                commentItem.className = 'comment-item';
                commentItem.id = `comment-${comment.number}`;
                
                const typeDisplay = {
                    'question': 'Question',
                    'clarification': 'Clarification', 
                    'approved': 'Approved'
                };
                
                commentItem.innerHTML = `
                    <div class="comment-header">
                        <div class="comment-number ${comment.type}">${comment.number}</div>
                        <div class="comment-type ${comment.type}">${typeDisplay[comment.type] || comment.type}</div>
                    </div>
                    <div class="comment-content">${comment.text}</div>
                    <div class="comment-meta">
                        <span>By ${comment.author} - ${new Date(comment.timestamp).toLocaleDateString()}</span>
                        <div class="comment-actions">
                            <button class="comment-action" onclick="editComment(${comment.number})">Edit</button>
                            <button class="comment-action" onclick="deleteComment(${comment.number})">Delete</button>
                        </div>
                    </div>
                `;
                
                // Add click handler to highlight in document
                commentItem.addEventListener('click', () => {
                    highlightCommentInDocument(comment.number);
                });
                
                commentsList.appendChild(commentItem);
            });
            
            console.log('=== End displaying comments ===');
        }

        // Add text selection handlers for commenting
        function addTextSelectionHandlers() {
            const docContent = document.getElementById('document-content');
            if (!docContent) return;
            
            console.log('Adding text selection handlers');
            
            // Remove existing listeners
            docContent.removeEventListener('mouseup', handleTextSelection);
            docContent.removeEventListener('contextmenu', preventContextMenu);
            
            // Add new listeners
            docContent.addEventListener('mouseup', handleTextSelection);
            docContent.addEventListener('contextmenu', preventContextMenu);
        }
        
        // Handle text selection
        function handleTextSelection(e) {
            setTimeout(() => {
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();
                
                console.log('Text selected:', selectedText);
                
                if (!selection.isCollapsed && selectedText.length > 0) {
                    const range = selection.getRangeAt(0);
                    const docContent = document.getElementById('document-content');
                    
                    // Check if selection is within the document content
                    if (!docContent.contains(range.commonAncestorContainer)) {
                        console.log('Selection not in document content');
                        return;
                    }
                    
                    const rect = range.getBoundingClientRect();
                    const menu = document.getElementById('comment-menu');
                    
                    // Position menu near selection
                    menu.style.left = Math.min(rect.left + window.scrollX, window.innerWidth - 200) + 'px';
                    menu.style.top = (rect.bottom + window.scrollY + 5) + 'px';
                    menu.classList.add('show');
                    
                    // Store the range for later use
                    currentCommentRange = range.cloneRange();
                    
                    console.log('Comment menu shown at:', menu.style.left, menu.style.top);
                } else {
                    // Hide menu if no selection
                    document.getElementById('comment-menu').classList.remove('show');
                }
            }, 10);
        }
        
        // Prevent context menu on right click in document
        function preventContextMenu(e) {
            if (e.target.closest('#document-content')) {
                e.preventDefault();
            }
        }
        
        // Handle comment option selection
        function handleCommentOption(type) {
            console.log('=== handleCommentOption called ===');
            console.log('Type:', type);
            console.log('currentCommentRange:', currentCommentRange);
            
            const menu = document.getElementById('comment-menu');
            if (menu) {
                menu.classList.remove('show');
                console.log('Menu hidden');
            }
            
            if (!currentCommentRange) {
                console.error('No comment range available');
                alert('Error: No text selection found. Please select text first.');
                return;
            }
            
            currentCommentType = type;
            console.log('Comment type set to:', currentCommentType);
            
            try {
                if (type === 'approved') {
                    // For approved comments, add immediately
                    console.log('Adding approved comment immediately');
                    addComment(type, 'Approved', currentCommentRange);
                } else {
                    // For questions and clarifications, show dialog
                    console.log('Showing dialog for', type);
                    showCommentDialog(type);
                }
            } catch (error) {
                console.error('Error in handleCommentOption:', error);
                alert('Error processing comment: ' + error.message);
            }
            
            // Clear text selection
            window.getSelection().removeAllRanges();
            console.log('=== handleCommentOption complete ===');
        }

        // Add click handlers for footnote references
        function addFootnoteClickHandlers() {
            // Handle comment footnote references (colored circles)
            document.querySelectorAll('.footnote-ref').forEach(ref => {
                ref.addEventListener('click', (e) => {
                    e.preventDefault();
                    const commentNumber = parseInt(ref.dataset.commentNumber);
                    highlightCommentInPanel(commentNumber);
                });
            });
            
            // Handle regular footnote links (underlined)
            document.querySelectorAll('.footnote-link').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const footnoteNumber = parseInt(link.dataset.footnoteNumber);
                    const footnoteElement = document.getElementById(`footnote-${footnoteNumber}`);
                    if (footnoteElement) {
                        footnoteElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        // Add temporary highlight
                        footnoteElement.style.background = 'rgba(0, 102, 204, 0.1)';
                        setTimeout(() => {
                            footnoteElement.style.background = '';
                        }, 2000);
                    }
                });
            });
            
            // Handle back links from footnotes to original position
            document.querySelectorAll('.footnote-back').forEach(backLink => {
                backLink.addEventListener('click', (e) => {
                    e.preventDefault();
                    const footnoteNumber = parseInt(backLink.dataset.footnoteNumber);
                    const footnoteRef = document.getElementById(`footnote-ref-${footnoteNumber}`);
                    if (footnoteRef) {
                        footnoteRef.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        // Add temporary highlight to the reference
                        footnoteRef.style.background = 'rgba(0, 102, 204, 0.2)';
                        footnoteRef.style.borderRadius = '3px';
                        footnoteRef.style.padding = '1px 3px';
                        setTimeout(() => {
                            footnoteRef.style.background = '';
                            footnoteRef.style.borderRadius = '';
                            footnoteRef.style.padding = '';
                        }, 2000);
                    }
                });
            });
        }

        // Highlight comment in document
        function highlightCommentInDocument(commentNumber) {
            // Remove existing highlights
            document.querySelectorAll('.footnote-ref').forEach(ref => {
                ref.classList.remove('active');
            });
            
            // Highlight the specific footnote reference
            const ref = document.querySelector(`[data-comment-number="${commentNumber}"]`);
            if (ref) {
                ref.classList.add('active');
                ref.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        // Highlight comment in panel
        function highlightCommentInPanel(commentNumber) {
            // Remove existing highlights
            document.querySelectorAll('.comment-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Highlight the specific comment
            const commentItem = document.getElementById(`comment-${commentNumber}`);
            if (commentItem) {
                commentItem.classList.add('active');
                commentItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        // Add new comment (called from dialog)
        async function addComment(type, text, range) {
            console.log('addComment called with:', { type, text, range: range ? range.toString() : 'null' });
            
            if (!text) {
                alert('Please enter comment text');
                return;
            }
            
            if (!currentDocument) {
                alert('Please select a document first');
                return;
            }
            
            if (!range) {
                alert('No text selection found');
                return;
            }
            
            // Get the selected text for context
            const selectedText = range.toString().trim();
            console.log('Selected text for comment:', selectedText);
            
            if (!selectedText) {
                alert('No text was selected');
                return;
            }
            
            // Create new comment
            const newComment = {
                number: nextCommentNumber,
                type: type,
                text: text,
                author: userEmail,
                timestamp: Date.now(),
                ref: `^${nextCommentNumber}`,
                selectedText: selectedText,
                isComment: true  // Mark as comment footnote
            };
            
            console.log('Creating comment:', newComment);
            
            // Insert footnote reference at selection in the DOM (visual feedback)
            insertFootnoteAtRange(range, nextCommentNumber, type);
            
            // Add to current comments array
            currentComments.push(newComment);
            currentComments.sort((a, b) => a.number - b.number);
            
            // Save to GitHub with selected text context
            const saveSuccess = await saveCommentToGitHub(newComment);
            
            // Only increment and update UI if save was successful
            if (saveSuccess !== false) {
                // Increment counter for next comment
                nextCommentNumber++;
                
                // Refresh display
                displayComments();
                addFootnoteClickHandlers();
                
                // FIXED: Force document reload to show changes immediately
                setTimeout(() => {
                    loadDocument(currentDocument);
                }, 500);
            } else {
                // Remove the comment from array if save failed
                currentComments = currentComments.filter(c => c.number !== newComment.number);
                
                // Remove the footnote reference from DOM if save failed
                const addedRef = document.querySelector(`[data-comment-number="${newComment.number}"]`);
                if (addedRef) {
                    addedRef.remove();
                }
            }
            
            // Clear selection and range
            window.getSelection().removeAllRanges();
            currentCommentRange = null;
            
            console.log('Comment add process completed');
        }

        // Insert footnote reference at specific range with better positioning
        function insertFootnoteAtRange(range, number, type) {
            console.log('=== insertFootnoteAtRange FIXED version ===');
            console.log('Range details:', {
                startContainer: range.startContainer,
                endContainer: range.endContainer,
                startOffset: range.startOffset,
                endOffset: range.endOffset,
                toString: range.toString()
            });
            
            try {
                // Create footnote reference element
                const footnoteRef = document.createElement('a');
                footnoteRef.href = `#comment-${number}`;
                footnoteRef.className = `footnote-ref ${type}`;
                footnoteRef.dataset.commentNumber = number;
                footnoteRef.textContent = number;
                
                // IMPROVED: Handle insertion more reliably
                
                // Method 1: Try to insert after the end of selection
                if (range.endContainer.nodeType === Node.TEXT_NODE) {
                    // We're ending in a text node - split it and insert between
                    const textNode = range.endContainer;
                    const offset = range.endOffset;
                    
                    console.log('Inserting in text node at offset:', offset);
                    
                    // Split the text node at the end position
                    const afterText = textNode.splitText(offset);
                    
                    // Insert the footnote reference between the split nodes
                    textNode.parentNode.insertBefore(footnoteRef, afterText);
                    
                    console.log('Successfully inserted footnote reference in text node');
                    
                } else {
                    // We're ending in an element node - insert as child
                    console.log('Inserting in element node');
                    
                    if (range.endOffset < range.endContainer.childNodes.length) {
                        // Insert before the child at endOffset
                        range.endContainer.insertBefore(footnoteRef, range.endContainer.childNodes[range.endOffset]);
                    } else {
                        // Append as last child
                        range.endContainer.appendChild(footnoteRef);
                    }
                    
                    console.log('Successfully inserted footnote reference in element node');
                }
                
            } catch (error) {
                console.error('Error in insertFootnoteAtRange:', error);
                console.log('Fallback: trying simple range insertion...');
                
                // Fallback method
                try {
                    range.collapse(false); // Move to end of selection
                    range.insertNode(footnoteRef);
                    console.log('Fallback insertion successful');
                } catch (fallbackError) {
                    console.error('Even fallback insertion failed:', fallbackError);
                    alert('Failed to insert footnote reference. The comment was still saved to GitHub.');
                }
            }
            
            console.log('=== End insertFootnoteAtRange ===');
        }

        // Save comment to GitHub via API
        async function saveCommentToGitHub(comment) {
            try {
                const footnoteDefinition = `[^${comment.number}]: ${comment.type}:${comment.text}:${comment.author}:${comment.timestamp}`;
                
                console.log('Saving comment to GitHub:', footnoteDefinition);
                
                const response = await fetch('/api/save-comment', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        docId: currentDocument.id,
                        comment: footnoteDefinition,
                        footnoteRef: `[^${comment.number}]`,
                        selectedText: comment.selectedText,
                        type: 'footnote',
                        action: 'add'
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.text();
                    console.error('Failed to save comment to GitHub:', response.status, errorData);
                    alert('Failed to save comment to GitHub. It will be lost when you refresh.');
                    return false; // Indicate save failure
                }
                
                const result = await response.json();
                console.log('Comment saved to GitHub successfully:', result);
                
                return true; // Indicate save success
                
            } catch (error) {
                console.error('Error saving comment to GitHub:', error);
                console.log('API endpoint not available - comment will be lost on refresh.');
                return false; // Indicate save failure
            }
        }

        // Edit comment
        function editComment(commentNumber) {
            const comment = currentComments.find(c => c.number === commentNumber);
            if (!comment) return;
            
            // Show dialog with existing values
            currentCommentType = comment.type;
            showCommentDialog(comment.type, comment.text, true, commentNumber);
        }

        // Update existing comment
        async function updateComment(commentNumber, newText) {
            const comment = currentComments.find(c => c.number === commentNumber);
            if (!comment) return;
            
            if (!newText.trim()) {
                alert('Please enter comment text');
                return;
            }
            
            const oldComment = {...comment};
            comment.text = newText.trim();
            comment.timestamp = Date.now();
            
            // Update footnote reference styling (type doesn't change in edit)
            const ref = document.querySelector(`[data-comment-number="${commentNumber}"]`);
            if (ref) {
                ref.className = `footnote-ref ${comment.type}`;
            }
            
            // Save to GitHub
            const updateSuccess = await updateCommentInGitHub(oldComment, comment);
            
            // Refresh display only if update was successful
            if (updateSuccess !== false) {
                displayComments();
                setTimeout(() => {
                    loadDocument(currentDocument);
                }, 500);
            } else {
                // Revert changes if update failed
                comment.text = oldComment.text;
                comment.timestamp = oldComment.timestamp;
            }
        }

        // Update comment in GitHub
        async function updateCommentInGitHub(oldComment, newComment) {
            try {
                const oldFootnoteDefinition = `[^${oldComment.number}]: ${oldComment.type}:${oldComment.text}:${oldComment.author}:${oldComment.timestamp}`;
                const newFootnoteDefinition = `[^${newComment.number}]: ${newComment.type}:${newComment.text}:${newComment.author}:${newComment.timestamp}`;
                
                console.log('Updating comment in GitHub:', { old: oldFootnoteDefinition, new: newFootnoteDefinition });
                
                const response = await fetch('/api/save-comment', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        docId: currentDocument.id,
                        oldComment: oldFootnoteDefinition,
                        comment: newFootnoteDefinition,
                        type: 'footnote',
                        action: 'update'
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.text();
                    console.error('Failed to update comment in GitHub:', response.status, errorData);
                    alert('Failed to update comment in GitHub.');
                    return false;
                }
                
                const result = await response.json();
                console.log('Comment updated in GitHub successfully:', result);
                
                return true;
                
            } catch (error) {
                console.error('Error updating comment in GitHub:', error);
                return false;
            }
        }

        // Delete comment
        async function deleteComment(commentNumber) {
            if (!confirm('Are you sure you want to delete this comment?')) return;
            
            const comment = currentComments.find(c => c.number === commentNumber);
            if (!comment) return;
            
            // Save to GitHub first
            const deleteSuccess = await deleteCommentFromGitHub(comment);
            
            if (deleteSuccess !== false) {
                // Remove from array only if GitHub delete was successful
                currentComments = currentComments.filter(c => c.number !== commentNumber);
                
                // Remove footnote reference from document
                const ref = document.querySelector(`[data-comment-number="${commentNumber}"]`);
                if (ref) {
                    ref.remove();
                }
                
                // Refresh display
                displayComments();
                
                // Force document reload to show changes
                setTimeout(() => {
                    loadDocument(currentDocument);
                }, 500);
            }
        }

        // Delete comment from GitHub
        async function deleteCommentFromGitHub(comment) {
            try {
                const footnoteDefinition = `[^${comment.number}]: ${comment.type}:${comment.text}:${comment.author}:${comment.timestamp}`;
                
                console.log('Deleting comment from GitHub:', footnoteDefinition);
                
                const response = await fetch('/api/save-comment', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        docId: currentDocument.id,
                        comment: footnoteDefinition,
                        type: 'footnote',
                        action: 'delete'
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.text();
                    console.error('Failed to delete comment from GitHub:', response.status, errorData);
                    alert('Failed to delete comment from GitHub.');
                    return false;
                }
                
                const result = await response.json();
                console.log('Comment deleted from GitHub successfully:', result);
                
                return true;
                
            } catch (error) {
                console.error('Error deleting comment from GitHub:', error);
                return false;
            }
        }
        
        // Show comment dialog
        function showCommentDialog(type, existingText = '', isEdit = false, editCommentNumber = null) {
            console.log('Showing comment dialog for:', type, 'isEdit:', isEdit);
            
            const dialog = document.getElementById('comment-dialog');
            const title = document.getElementById('comment-dialog-title');
            const label = document.getElementById('comment-dialog-label');
            const textarea = document.getElementById('comment-dialog-text');
            
            if (type === 'question') {
                title.textContent = isEdit ? 'Edit Question' : 'Ask Question';
                label.textContent = 'Question text:';
                textarea.placeholder = 'What would you like to clarify or ask about this section?';
            } else if (type === 'clarification') {
                title.textContent = isEdit ? 'Edit Clarification' : 'Request Clarification';
                label.textContent = 'Clarification needed:';
                textarea.placeholder = 'What needs to be clarified or expanded in this section?';
            }
            
            textarea.value = existingText;
            
            // Position dialog 150px above selected text
            if (currentCommentRange && !isEdit) {
                try {
                    const rect = currentCommentRange.getBoundingClientRect();
                    const dialogWidth = 400; // From CSS min-width
                    
                    // Position 150px above selection
                    let top = rect.top + window.scrollY - 150;
                    let left = rect.left + window.scrollX + (rect.width / 2) - (dialogWidth / 2);
                    
                    // Bounds checking
                    if (top < 10) top = 10; // Don't go above viewport
                    if (left < 10) left = 10; // Don't go off left edge
                    if (left + dialogWidth > window.innerWidth - 10) {
                        left = window.innerWidth - dialogWidth - 10; // Don't go off right edge
                    }
                    
                    dialog.style.top = top + 'px';
                    dialog.style.left = left + 'px';
                    dialog.style.transform = 'none'; // Remove centering transform
                    
                    console.log('Positioned dialog at:', { top, left });
                } catch (error) {
                    console.warn('Could not position dialog relative to selection, using center:', error);
                    // Fallback to center positioning
                    dialog.style.top = '50%';
                    dialog.style.left = '50%';
                    dialog.style.transform = 'translate(-50%, -50%)';
                }
            } else {
                // For edits or when no selection, center on screen
                dialog.style.top = '50%';
                dialog.style.left = '50%';
                dialog.style.transform = 'translate(-50%, -50%)';
            }
            
            dialog.style.display = 'block';
            
            // Store edit info on dialog element
            dialog.isEdit = isEdit;
            dialog.editCommentNumber = editCommentNumber;
            
            // Focus and select text
            setTimeout(() => {
                textarea.focus();
                if (existingText) {
                    textarea.select();
                }
            }, 100);
            
            console.log('Comment dialog shown');
        }
        
        // Hide comment dialog
        function hideCommentDialog() {
            console.log('Hiding comment dialog');
            const dialog = document.getElementById('comment-dialog');
            dialog.style.display = 'none';
            document.getElementById('comment-dialog-text').value = '';
            
            // Reset positioning
            dialog.style.top = '';
            dialog.style.left = '';
            dialog.style.transform = '';
            
            // Clear state
            currentCommentType = '';
            if (!dialog.isEdit) {
                currentCommentRange = null;
            }
            
            // Clear edit info
            dialog.isEdit = false;
            dialog.editCommentNumber = null;
        }
        
        // Submit comment from dialog
        function submitComment() {
            console.log('Submitting comment');
            
            const dialog = document.getElementById('comment-dialog');
            const textarea = document.getElementById('comment-dialog-text');
            const text = textarea.value.trim();
            
            if (!text) {
                alert('Please enter comment text');
                return;
            }
            
            if (dialog.isEdit && dialog.editCommentNumber) {
                // Update existing comment
                console.log('Updating existing comment:', dialog.editCommentNumber);
                updateComment(dialog.editCommentNumber, text);
            } else {
                // Add new comment
                console.log('Adding new comment with range:', currentCommentRange);
                if (currentCommentRange && currentCommentType) {
                    addComment(currentCommentType, text, currentCommentRange);
                } else {
                    console.error('Missing comment range or type');
                    alert('Error: Missing selection or comment type');
                    return;
                }
            }
            
            hideCommentDialog();
        }
        
        // Modal functions
        function showOverview() {
            document.getElementById('overview-modal').classList.add('show');
        }

        function hideOverview() {
            document.getElementById('overview-modal').classList.remove('show');
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', init);
        
        // Hide comment menu on click outside
        document.addEventListener('click', (e) => {
            const menu = document.getElementById('comment-menu');
            if (!menu.contains(e.target)) {
                menu.classList.remove('show');
            }
        });
    </script>
</body>
</html>