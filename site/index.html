<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pattern Constellations</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
       
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            color: #333333;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        /* Document Typography */
        .document-content {
            max-width: 700px;
            margin: 0 auto;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', sans-serif;
            font-size: 17px;
            line-height: 1.7;
            color: #333;
        }

        .document-content h1 {
            font-size: 2.2em;
            font-weight: 700;
            margin: 2rem 0 1.5rem 0;
            line-height: 1.2;
            color: #1a1a1a;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 0.5rem;
        }

        .document-content h2 {
            font-size: 1.7em;
            font-weight: 600;
            margin: 2rem 0 1rem 0;
            line-height: 1.3;
            color: #2c3e50;
        }

        .document-content h3 {
            font-size: 1.3em;
            font-weight: 600;
            margin: 1.5rem 0 0.8rem 0;
            line-height: 1.4;
            color: #34495e;
        }

        .document-content p {
            margin: 0 0 1.2rem 0;
            text-align: justify;
            hyphens: auto;
        }

        .document-content ul, .document-content ol {
            margin: 0 0 1.2rem 0;
            padding-left: 2rem;
        }

        .document-content li {
            margin-bottom: 0.5rem;
            line-height: 1.7;
        }

        .document-content strong {
            font-weight: 600;
            color: #1a1a1a;
        }

        .document-content em {
            font-style: italic;
        }

        /* Better readability on screens */
        @media screen and (min-width: 768px) {
            .document-content {
                font-size: 18px;
                line-height: 1.8;
            }
        }

        /* Selection and interaction */
        .document-content .commentable {
            cursor: text;
            transition: background-color 0.2s;
        }

        .document-content .commentable:hover {
            background-color: rgba(0, 102, 204, 0.03);
        }

        /* Code blocks if you have any */
        .document-content code {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
            font-size: 0.9em;
            padding: 0.2em 0.4em;
            background: #f4f4f4;
            border-radius: 3px;
        }

        /* Improve comment markers */
        .comment-marker {
            background: rgba(255, 235, 59, 0.2);
            padding: 0 3px;
            border-radius: 3px;
            margin: 0 2px;
        }
        .comment-marker {
            position: relative;
            display: inline;
            background-color: rgba(255, 0, 0, 0.3); /* Default color, will be overridden by JS */
            margin-left: 5px;
            cursor: pointer;
        }

        .comment-tooltip {
            position: absolute;
            bottom: 100%;
            left: 0;
            z-index: 1000;
            background: #fffeef;
            border: 1px solid #e9e9e9;
            border-radius: 4px;
            padding: 8px;
            white-space: nowrap;
            pointer-events: auto;
            font-size: 14px;
            display: none;
        }

        .comment-marker:hover .comment-tooltip {
            display: block;
        }
       
        /* Header */
        .header {
            background: #f8f9fa;
            border-bottom: 2px solid #dee2e6;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
       
        .header h1 {
            font-size: 18px;
            color: #495057;
        }
       
        .header-actions {
            display: flex;
            gap: 15px;
        }
       
        .btn-overview {
            padding: 8px 16px;
            background: #0066cc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
       
        .btn-overview:hover {
            background: #0052a3;
        }
       
        /* Main layout */
        .main-container {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
       
        /* Left panel - Documents */
        .left-panel {
            width: 20%;
            background: #f8f9fa;
            border-right: 1px solid #dee2e6;
            overflow-y: auto;
            padding: 15px;
        }
       
        .lens-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
            border-bottom: 1px solid #dee2e6;
        }
       
        .lens-tab {
            padding: 8px 12px;
            background: transparent;
            border: none;
            cursor: pointer;
            color: #6c757d;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }
       
        .lens-tab.active {
            color: #0066cc;
            border-bottom-color: #0066cc;
        }
       
        .doc-category {
            margin-bottom: 20px;
        }
       
        .doc-category h3 {
            font-size: 12px;
            text-transform: uppercase;
            color: #6c757d;
            margin-bottom: 8px;
            font-weight: 600;
        }
       
        .document-item {
            background: white;
            padding: 10px;
            margin-bottom: 5px;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid transparent;
            transition: all 0.2s;
        }
       
        .document-item:hover {
            border-color: #0066cc;
        }
       
        .document-item.active {
            background: #e7f3ff;
            border-color: #0066cc;
        }

        .error-message {
            color: #dc3545;
            text-align: center;
            padding: 20px;
            font-style: italic;
        }
       
        /* Center - Main content */
        .center-panel {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            background: white;
            position: relative;
        }
       
        /* Right panel - Messages */
        .right-panel {
            width: 25%;
            background: #f8f9fa;
            border-left: 1px solid #dee2e6;
            display: flex;
            flex-direction: column;
        }
       
        .messages-header {
            padding: 15px;
            background: white;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
       
        .messages-header h3 {
            font-size: 14px;
            font-weight: 600;
            color: #495057;
        }
       
        .new-thread-btn {
            padding: 6px 12px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
       
        .topic-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 10px 15px;
            border-bottom: 1px solid #dee2e6;
        }
       
        .topic-pill {
            padding: 4px 10px;
            background: #f0f0f0;
            color: #666;
            border-radius: 12px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
       
        .topic-pill.active {
            background: #0066cc;
            color: white;
        }
       
        .messages-list {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }
       
        .message-thread {
            background: white;
            border-radius: 8px;
            margin-bottom: 10px;
            padding: 12px;
            cursor: pointer;
            border: 1px solid #e9ecef;
            transition: all 0.2s;
        }
       
        .message-thread:hover {
            border-color: #0066cc;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
       
        .message-thread.active {
            background: #e7f3ff;
            border-color: #0066cc;
        }
       
        .message-pills {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }
       
        .pill {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
        }
       
        .pill-subject {
            background: #e7f3ff;
            color: #0066cc;
        }
       
        .pill-topic {
            background: #f0f0f0;
            color: #666;
        }
       
        .pill-date {
            background: #fff3cd;
            color: #856404;
        }
       
        .pill-new {
            background: #dc3545;
            color: white;
        }
       
        .message-preview {
            font-size: 13px;
            color: #6c757d;
            margin-top: 5px;
        }
       
        .message-replies {
            font-size: 11px;
            color: #28a745;
            margin-top: 5px;
            font-weight: 500;
        }
       
        /* Thread view styles */
        .thread-messages {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
       
        .thread-message {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #dee2e6;
        }
       
        .reply-form {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
       
        .reply-form textarea {
            padding: 8px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            resize: vertical;
            min-height: 60px;
        }
       
        .reply-form button {
            align-self: flex-start;
            padding: 6px 12px;
            background: #0066cc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
       
        /* Comment Menu - VERTICAL */
        .comment-menu {
            position: absolute;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 8px;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            min-width: 180px;
        }
       
        .comment-menu.show {
            display: block;
        }
       
        .comment-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.2s;
            font-size: 14px;
            color: #495057;
        }
       
        .comment-option:hover {
            background: #f8f9fa;
        }
       
        .comment-option-icon {
            font-size: 18px;
            width: 24px;
            text-align: center;
        }
       
        .comment-option-text {
            flex: 1;
        }
       
        /* Overview Modal */
        .overview-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
        }
       
        .overview-modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }
       
        .overview-content {
            background: white;
            border-radius: 8px;
            width: 90%;
            height: 80%;
            padding: 30px;
            position: relative;
            overflow: auto;
        }
       
        .overview-close {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 24px;
            cursor: pointer;
            color: #6c757d;
        }
       
        .overview-graph {
            display: flex;
            flex-direction: column;
            gap: 30px;
            margin-top: 20px;
        }
       
        .overview-section {
            border-left: 3px solid #0066cc;
            padding-left: 20px;
        }
       
        .overview-section h3 {
            color: #0066cc;
            margin-bottom: 10px;
        }
       
        .overview-items {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
       
        .overview-item {
            padding: 8px 15px;
            background: #f8f9fa;
            border-radius: 4px;
            font-size: 13px;
            border: 1px solid #dee2e6;
        }
       
        .overview-item.stable {
            background: #d4edda;
            border-color: #28a745;
        }
       
        .overview-item.developing {
            background: #cce5ff;
            border-color: #0066cc;
        }
       
        .overview-item.draft {
            background: #fff3cd;
            border-color: #ffc107;
        }
       
        /* New thread form */
        .new-thread-form {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            z-index: 3000;
            display: none;
            width: 400px;
        }
       
        .new-thread-form.show {
            display: block;
        }
       
        .form-group {
            margin-bottom: 15px;
        }
       
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            color: #495057;
        }
       
        .form-group input, .form-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-size: 14px;
        }
       
        .form-group textarea {
            resize: vertical;
            min-height: 100px;
        }
       
        .form-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
       
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
       
        .btn-primary {
            background: #0066cc;
            color: white;
        }
       
        .btn-secondary {
            background: #6c757d;
            color: white;
        }

       
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <h1>Pattern Constellations Research</h1>
        <div class="header-actions">
            <button class="btn-overview" onclick="showOverview()">📊 Project Overview</button>
        </div>
    </div>
   
    <!-- Main container -->
    <div class="main-container">
        <!-- Left Panel - Documents -->
        <div class="left-panel">
            <div class="lens-tabs">
                <button class="lens-tab active" data-lens="all">All</button>
                <button class="lens-tab" data-lens="philosophy">Philosophy</button>
                <button class="lens-tab" data-lens="cognition">Cognition</button>
                <button class="lens-tab" data-lens="cs-math">CS/Math</button>
            </div>
            <!-- Categories will be added dynamically -->
        </div>
       
        <!-- Center - Main content -->
        <div class="center-panel" id="center-panel">
            <div style="max-width: 700px;">
                <div style="text-align: center; padding: 60px; color: #6c757d;">
                    <h2 style="color: #495057; margin-bottom: 10px;">Select a document to begin</h2>
                    <p>Choose a document from the left panel</p>
                </div>
            </div>
        </div>
       
        <!-- Right Panel - Messages -->
        <div class="right-panel">
            <div class="messages-header">
                <h3>Messages</h3>
                <button class="new-thread-btn" onclick="showNewThreadForm()">+ New Thread</button>
            </div>
            <div class="topic-filters" id="topic-filters">
                <!-- Pills will be added here dynamically -->
            </div>
            <div class="messages-list" id="messages-list">
                <!-- Threads will be added dynamically -->
            </div>
        </div>
    </div>
   
    <!-- Comment Menu - VERTICAL with TEXT -->
    <div class="comment-menu" id="comment-menu">
        <div class="comment-option" data-type="question">
            <span class="comment-option-icon">❓</span>
            <span class="comment-option-text">Ask question</span>
        </div>
        <div class="comment-option" data-type="clarification">
            <span class="comment-option-icon">❗</span>
            <span class="comment-option-text">Needs clarification</span>
        </div>
        <div class="comment-option" data-type="approved">
            <span class="comment-option-icon">✅</span>
            <span class="comment-option-text">Approved / Keep</span>
        </div>
    </div>
   
    <!-- Overview Modal -->
    <div class="overview-modal" id="overview-modal">
        <div class="overview-content">
            <span class="overview-close" onclick="hideOverview()">×</span>
            <h2>Project Overview - Pattern Recognition Identity</h2>
           
            <div class="overview-graph">
                <div class="overview-section">
                    <h3>🎯 Core Theory</h3>
                    <div class="overview-items">
                        <div class="overview-item developing">PRI Main Thesis</div>
                        <div class="overview-item developing">Pattern-Recognition Unity</div>
                        <div class="overview-item draft">Consciousness as Reflexive PR</div>
                    </div>
                </div>
               
                <div class="overview-section">
                    <h3>💡 Problem Dissolutions</h3>
                    <div class="overview-items">
                        <div class="overview-item stable">Hard Problem</div>
                        <div class="overview-item developing">Symbol Grounding</div>
                        <div class="overview-item draft">Quantum Measurement</div>
                        <div class="overview-item draft">Causation Problem</div>
                    </div>
                </div>
               
                <div class="overview-section">
                    <h3>📊 Empirical Evidence</h3>
                    <div class="overview-items">
                        <div class="overview-item developing">Semantic Embeddings</div>
                        <div class="overview-item developing">Rod-Cap Structure</div>
                        <div class="overview-item draft">LLM Analysis</div>
                    </div>
                </div>
               
                <div class="overview-section">
                    <h3>🔗 Connections</h3>
                    <div class="overview-items">
                        <div class="overview-item stable">Eastern Philosophy</div>
                        <div class="overview-item developing">Transformer Architecture</div>
                        <div class="overview-item draft">Hopfield Networks</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
   
    <!-- New Thread Form -->
    <div class="new-thread-form" id="new-thread-form">
        <h3 style="margin-bottom: 20px;">New Discussion</h3>
        <div class="form-group">
            <label>Subject</label>
            <input type="text" id="thread-subject" placeholder="Brief topic...">
        </div>
        <div class="form-group">
            <label>Topic Category</label>
            <input type="text" id="thread-topic" placeholder="e.g., Core Theory, Evidence, Questions...">
        </div>
        <div class="form-group">
            <label>Message</label>
            <textarea id="thread-message" placeholder="Your thoughts..."></textarea>
        </div>
        <div class="form-actions">
            <button class="btn btn-secondary" onclick="hideNewThreadForm()">Cancel</button>
            <button class="btn btn-primary" onclick="createThread()">Create Thread</button>
        </div>
    </div>

    <!-- Comment Dialog -->
    <div id="comment-dialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
         background: white; border: 1px solid #dee2e6; border-radius: 4px; padding: 20px; z-index: 3000;">
        <h3 id="comment-dialog-title">Comment</h3>
        <label id="comment-dialog-label" for="comment-dialog-text"></label>
        <textarea id="comment-dialog-text" style="width: 100%; min-height: 80px; margin-top: 10px;"></textarea>
        <div style="margin-top: 10px; text-align: right;">
            <button onclick="hideCommentDialog()" style="margin-right: 10px;">Cancel</button>
            <button onclick="submitComment()">Submit</button>
        </div>
    </div>
   
    <script>
        // User email (in real deployment, fetch from API)
        let userEmail = 'you@example.com';

        let currentCommentRange = null;  // store the selection range when showing dialog
        let currentCommentType = '';     // store type of comment (question, clarification, approved)
        let currentEditingInfo = null;   // track if a comment is being edited
        let isInitialized = false;       // prevent duplicate initialization
        
        async function fetchUserEmail() {
            try {
                const res = await fetch('/api/user');
                const data = await res.json();
                userEmail = data.email || 'anonymous';
            } catch {
                userEmail = 'anonymous';
            }
        }

        // Thread data with better timestamp management
        const threads = {
            'Eastern Philosophy Connection': {
                topic: 'Core Theory',
                timestamp: Date.now() - 86400000 * 2,
                lastActivity: Date.now() - 7200000,
                messages: [
                    {text: "I've been thinking about how PRI relates to Buddhist dependent origination. The recursive self-recognition aspect seems to mirror the Buddhist understanding of consciousness as a process rather than a thing.", timestamp: Date.now() - 86400000 * 2, user: 'supervisor@example.com'},
                    {text: 'That\'s a compelling connection. The madhyamaka analysis of dependent origination might provide insights into how pattern recognition avoids the infinite regress problem.', timestamp: Date.now() - 7200000, user: 'you@example.com'},
                    {text: 'Exactly. And the yogācāra school\'s analysis of consciousness (vijñāna) as transformative recognition could be directly relevant to our recursive model.', timestamp: Date.now() - 3600000, user: 'supervisor@example.com'},
                    {text: 'We should explore whether ālaya-vijñāna (store consciousness) maps onto the pattern constellation structure we\'re proposing.', timestamp: Date.now() - 1800000, user: 'you@example.com'}
                ]
            },
            'Symbol Grounding Dissolution': {
                topic: 'Problems',
                timestamp: Date.now() - 86400000 * 3,
                lastActivity: Date.now() - 86400000,
                messages: [
                    {text: "The dissolution seems compelling but I'm not sure about the linguistic aspects. How does pattern recognition ground arbitrary symbols like words?", timestamp: Date.now() - 86400000 * 3, user: 'you@example.com'},
                    {text: 'The key insight is that symbols don\'t need external grounding - they ground through recognition patterns that connect them to embodied recognition systems.', timestamp: Date.now() - 86400000 * 2, user: 'supervisor@example.com'},
                    {text: 'But what about truly abstract concepts that seem divorced from embodied experience?', timestamp: Date.now() - 86400000 * 2, user: 'you@example.com'},
                    {text: 'Even abstract concepts emerge from pattern recognition operating on other patterns. Mathematical concepts, for instance, recognize structural patterns that can exist independently of specific instantiations.', timestamp: Date.now() - 86400000, user: 'supervisor@example.com'},
                    {text: 'So abstraction is pattern recognition operating on increasingly general pattern types rather than specific content?', timestamp: Date.now() - 86400000, user: 'you@example.com'}
                ]
            },
            'Meeting Notes': {
                topic: 'Admin',
                timestamp: Date.now() - 86400000 * 7,
                lastActivity: Date.now() - 86400000 * 6,
                messages: [
                    {text: "Summary of our discussion about the empirical evidence section. We agreed to focus on three main areas: semantic embeddings, transformer architectures, and predictive processing research.", timestamp: Date.now() - 86400000 * 7, user: 'supervisor@example.com'},
                    {text: 'I\'ll start working on the semantic embeddings analysis this week.', timestamp: Date.now() - 86400000 * 6, user: 'you@example.com'}
                ]
            }
        };

        // LocalStorage keys
        const COMMENTS_KEY = 'doc_comments';
        const READ_STATUS_KEY = 'thread_read_status_' + userEmail.replace('@', '_').replace('.', '_');

        // Document metadata
        const categoryMap = {
            "core": "Core Theory",
            "evidence": "Evidence",
            "references": "References"
        };
        
        const statusColors = {
            "developing": "#28a745",
            "draft": "#ffc107", 
            "stable": "#0066cc"
        };
        
        // Utility functions
        function slugify(str) {
            return str.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
        }

        function parseFrontmatter(text) {
            if (!text.startsWith('---')) return {meta: {}, content: text};
            const end = text.indexOf('---', 3);
            if (end === -1) return {meta: {}, content: text};
            const yamlText = text.substring(3, end).trim();
            const meta = {};
            yamlText.split('\n').forEach(line => {
                const colon = line.indexOf(':');
                if (colon > 0) {
                    const key = line.substring(0, colon).trim();
                    let val = line.substring(colon + 1).trim();
                    if (val.startsWith('[')) {
                        try {
                            val = JSON.parse(val.replace(/'/g, '"'));
                        } catch {
                            val = val.replace(/[\[\]"]/g, '').split(',').map(s => s.trim());
                        }
                    } else if (val.startsWith('"')) {
                        val = val.replace(/"/g, '');
                    }
                    meta[key] = val;
                }
            });
            const content = text.substring(end + 3).trim();
            return {meta, content};
        }

        // Comment management
        function getStoredComments() {
            const stored = localStorage.getItem(COMMENTS_KEY);
            return stored ? JSON.parse(stored) : {};
        }

        function saveComments(comments) {
            localStorage.setItem(COMMENTS_KEY, JSON.stringify(comments));
        }

        // Read status management
        function getReadStatus() {
            const stored = localStorage.getItem(READ_STATUS_KEY);
            return stored ? JSON.parse(stored) : {};
        }

        function saveReadStatus(status) {
            localStorage.setItem(READ_STATUS_KEY, JSON.stringify(status));
        }

        function markThreadAsRead(subject) {
            const status = getReadStatus();
            status[subject] = Date.now();
            saveReadStatus(status);
            
            // Remove NEW pill immediately
            const threadElem = [...document.querySelectorAll('.message-thread')].find(t => 
                t.querySelector('.pill-subject')?.textContent === subject
            );
            if (threadElem) {
                const newPill = threadElem.querySelector('.pill-new');
                if (newPill) {
                    newPill.remove();
                }
            }
        }

        function isThreadNew(subject) {
            const threadData = threads[subject];
            if (!threadData) return false;
            
            const readStatus = getReadStatus();
            const lastReadTime = readStatus[subject] || 0;
            const lastActivity = threadData.lastActivity || threadData.timestamp;
            
            return lastActivity > lastReadTime;
        }

        // Load documents from manifest
        async function loadDocuments() {
            try {
                const res = await fetch('/content/manifest.json');
                if (!res.ok) throw new Error('Manifest fetch failed');
                return await res.json();
            } catch (err) {
                console.error('Error loading documents:', err);
                return [];
            }
        }

        // Build left panel - FIXED to prevent duplicates
        async function buildLeftPanel() {
            const leftPanel = document.querySelector('.left-panel');
            
            // Clear only the document categories, not the lens tabs
            leftPanel.querySelectorAll('.doc-category, .error-message').forEach(el => el.remove());

            try {
                const docsArray = await loadDocuments();
                
                if (docsArray.length === 0) {
                    const errorMsg = document.createElement('div');
                    errorMsg.className = 'error-message';
                    errorMsg.textContent = 'No documents found';
                    leftPanel.appendChild(errorMsg);
                    return;
                }
                
                // Deduplicate by ID
                const uniqueDocs = {};
                docsArray.forEach(doc => {
                    if (!uniqueDocs[doc.id]) {
                        uniqueDocs[doc.id] = doc;
                    }
                });
                
                // Group by category
                const categories = {};
                Object.values(uniqueDocs).forEach(doc => {
                    const cat = doc.frontmatter?.category || 'uncategorized';
                    if (!categories[cat]) categories[cat] = [];
                    categories[cat].push(doc);
                });
                
                // Build UI
                Object.keys(categories).sort().forEach(cat => {
                    const categoryDiv = document.createElement('div');
                    categoryDiv.className = 'doc-category';
                    
                    const h3 = document.createElement('h3');
                    h3.textContent = cat.toUpperCase();
                    categoryDiv.appendChild(h3);
                    
                    const docsDiv = document.createElement('div');
                    
                    categories[cat].forEach(doc => {
                        const item = document.createElement('div');
                        item.className = 'document-item';
                        item.dataset.id = doc.id;
                        item.dataset.lenses = doc.lens ? doc.lens.join(' ') : '';
                        item.innerHTML = `
                            <div>${doc.title || doc.frontmatter?.title || 'Untitled'}</div>
                            <span style="font-size: 11px; color: #6c757d;">● ${doc.status}</span>
                        `;
                        
                        item.addEventListener('click', () => {
                            document.querySelectorAll('.document-item').forEach(i => i.classList.remove('active'));
                            item.classList.add('active');
                            loadDocContent(doc);
                        });
                        
                        docsDiv.appendChild(item);
                    });
                    
                    categoryDiv.appendChild(docsDiv);
                    leftPanel.appendChild(categoryDiv);
                });
                
            } catch (error) {
                console.error('Error building left panel:', error);
                const errorMsg = document.createElement('div');
                errorMsg.className = 'error-message';
                errorMsg.textContent = 'Error loading documents';
                leftPanel.appendChild(errorMsg);
            }
        }

        // Initialize topic filters
        function initTopicFilters() {
            const filters = document.getElementById('topic-filters');
            filters.innerHTML = '';
            
            const allPill = document.createElement('span');
            allPill.className = 'topic-pill active';
            allPill.textContent = 'All';
            allPill.dataset.topic = 'all';
            filters.appendChild(allPill);

            const uniqueTopics = new Set(Object.values(threads).map(t => t.topic));
            uniqueTopics.forEach(topic => {
                const pill = document.createElement('span');
                pill.className = 'topic-pill';
                pill.textContent = topic;
                pill.dataset.topic = topic;
                filters.appendChild(pill);
            });

            // Add click listeners
            filters.querySelectorAll('.topic-pill').forEach(pill => {
                pill.addEventListener('click', () => {
                    filters.querySelectorAll('.topic-pill').forEach(p => p.classList.remove('active'));
                    pill.classList.add('active');
                    const selected = pill.dataset.topic;
                    document.querySelectorAll('.message-thread').forEach(thread => {
                        thread.style.display = (selected === 'all' || thread.dataset.topic === selected) ? 'block' : 'none';
                    });
                });
            });
        }

        // Build thread list
        function buildThreadList() {
            const messagesList = document.getElementById('messages-list');
            messagesList.innerHTML = '';

            Object.keys(threads).forEach(subject => {
                const data = threads[subject];
                const threadElem = document.createElement('div');
                threadElem.className = 'message-thread';
                threadElem.dataset.topic = data.topic;
                
                const repliesCount = data.messages.length - 1;
                const lastActivity = new Date(data.lastActivity || data.timestamp);
                const isNew = isThreadNew(subject);
                
                threadElem.innerHTML = `
                    <div class="message-pills">
                        <span class="pill pill-subject">${subject}</span>
                        <span class="pill pill-topic">${data.topic}</span>
                        <span class="pill pill-date">${new Date(data.timestamp).toLocaleDateString()}</span>
                        ${isNew ? '<span class="pill pill-new">new</span>' : ''}
                    </div>
                    <div class="message-preview">${data.messages[0].text.substring(0, 100)}${data.messages[0].text.length > 100 ? '...' : ''}</div>
                    <div class="message-replies">${repliesCount} repl${repliesCount === 1 ? 'y' : 'ies'} · Last: ${lastActivity.toLocaleString()}</div>
                `;
                
                messagesList.appendChild(threadElem);
            });

            attachThreadListeners();
        }

        // Load document content
        async function loadDocContent(doc) {
            try {
                let text = doc.fullContent || doc.content;
                if (!text) {
                    const res = await fetch(`/content/${doc.id}`);
                    text = await res.text();
                }
                
                // Parse and render comments in the content
                const renderComments = (content) => {
                    const commentRegex = new RegExp('<!--\\s*([?!✓])\\s*(.*?)\\s*\\|\\s*(.*?)\\s*\\|\\s*(\\d+)(?:\\s*\\|\\s*(.*?))?\\s*-->', 'g');
                    
                    let lastIndex = 0;
                    let result = '';
                    let match;
                    
                    while ((match = commentRegex.exec(content)) !== null) {
                        result += content.substring(lastIndex, match.index);
                        
                        const [fullMatch, commentHtml, type, commentText, author, timestamp, highlightedText] = match;
                        
                        const commentElement = document.createElement('span');
                        commentElement.className = 'comment-marker';
                        commentElement.dataset.commentId = timestamp;
                        commentElement.dataset.originalText = highlightedText || commentText;
                        
                        if (type === '?') {
                            commentElement.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
                        } else if (type === '!') {
                            commentElement.style.backgroundColor = 'rgba(255, 255, 0, 0.3)';
                        } else if (type === '✓') {
                            commentElement.style.backgroundColor = 'rgba(0, 255, 0, 0.3)';
                        }
                        
                        if (highlightedText) {
                            commentElement.textContent = highlightedText;
                        } else {
                            commentElement.textContent = commentText || type;
                        }
                        
                        const tooltip = document.createElement('div');
                        tooltip.className = 'comment-tooltip';
                        
                        const dateStr = new Date(parseInt(timestamp)).toLocaleDateString();
                        tooltip.innerHTML = `<button onclick="editComment(${timestamp})" style="margin-right:5px;">Edit</button>
                                            <button onclick="deleteComment(${timestamp})">Delete</button>
                                            <div style="font-size:11px; opacity:0.8;">By ${author} on ${dateStr}</div>
                                            <div>${commentText}</div>`;
                        
                        commentElement.appendChild(tooltip);
                        result += commentElement.outerHTML;
                        lastIndex = match.index + fullMatch.length;
                    }
                    
                    result += content.substring(lastIndex);
                    return result;
                };
                
                // Simple markdown to HTML conversion
                function markdownToHtml(markdown) {
                    let html = markdown;
                    
                    // Headers
                    html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
                    html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
                    html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');
                    
                    // Bold and italic
                    html = html.replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>');
                    html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                    html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
                    
                    // Lists
                    html = html.replace(/^\* (.+)$/gim, '<li>$1</li>');
                    html = html.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');
                    html = html.replace(/^\d+\. (.+)$/gim, '<li>$1</li>');
                    
                    // Paragraphs - wrap lines that aren't already tags
                    const lines = html.split('\n');
                    const processedLines = [];
                    let inParagraph = false;
                    let paragraphIndex = 0;
                    
                    lines.forEach(line => {
                        const trimmed = line.trim();
                        if (!trimmed) {
                            if (inParagraph) {
                                processedLines.push('</p>');
                                inParagraph = false;
                            }
                            processedLines.push('');
                            return;
                        }
                        
                        if (trimmed.startsWith('<h') || trimmed.startsWith('<ul') || 
                            trimmed.startsWith('<li') || trimmed.startsWith('</')) {
                            if (inParagraph) {
                                processedLines.push('</p>');
                                inParagraph = false;
                            }
                            processedLines.push(line);
                        } else {
                            if (!inParagraph) {
                                processedLines.push(`<p class="commentable" data-para-index="${paragraphIndex}">`);
                                inParagraph = true;
                                paragraphIndex++;
                            } else {
                                processedLines.push('<br>');
                            }
                            processedLines.push(line);
                        }
                    });
                    
                    if (inParagraph) {
                        processedLines.push('</p>');
                    }
                    
                    return processedLines.join('\n');
                }
                
                let htmlContent = markdownToHtml(text);
                htmlContent = renderComments(htmlContent);
                
                document.getElementById('center-panel').innerHTML = `
                    <article class="document-content">
                        ${htmlContent}
                    </article>
                `;
                
                restoreComments(doc.id);
                attachCommentListeners();
                
            } catch (e) {
                console.error('Error loading document:', e);
                document.getElementById('center-panel').innerHTML = `
                    <div class="document-content">
                        <h2>Error loading document</h2>
                        <p style="color: #dc3545;">${e.message}</p>
                    </div>
                `;
            }
        }

        // Helper functions
        function getHighlightColor(type) {
            const colors = {
                'question': 'rgba(255, 0, 0, 0.3)',
                'clarification': 'rgba(255, 255, 0, 0.3)',
                'approved': 'rgba(0, 255, 0, 0.3)'
            };
            return colors[type] || 'rgba(0, 0, 255, 0.3)';
        }

        function getCommentIcon(type) {
            const icons = {
                'question': '❓',
                'clarification': '❗',
                'approved': '✅'
            };
            return icons[type] || '💬';
        }

        // Restore comments from storage
        function restoreComments(docId) {
            const comments = getStoredComments()[docId];
            if (!comments) return;
            
            Object.keys(comments).forEach(paraIndex => {
                if (paraIndex === 'general') {
                    comments[paraIndex].forEach(comment => {
                        console.log('General comment found:', comment);
                    });
                    return;
                }
                
                const paragraph = document.querySelector(`[data-para-index="${paraIndex}"]`);
                if (!paragraph) {
                    console.log(`Paragraph ${paraIndex} not found for comments`);
                    return;
                }
                
                comments[paraIndex].forEach(comment => {
                    const existingComment = document.querySelector(`[data-comment-id="${comment.timestamp}"]`);
                    if (existingComment) return;
                    
                    const commentSpan = document.createElement('span');
                    commentSpan.className = 'comment-marker';
                    commentSpan.dataset.commentId = comment.timestamp;
                    commentSpan.dataset.originalText = comment.text || '';
                    commentSpan.style.backgroundColor = getHighlightColor(comment.type);
                    
                    const textNode = document.createTextNode(comment.text || '');
                    commentSpan.appendChild(textNode);
                    
                    const tooltip = document.createElement('div');
                    tooltip.className = 'comment-tooltip';
                    
                    const dateStr = new Date(comment.timestamp).toLocaleDateString();
                    tooltip.innerHTML = `<button onclick="editComment(${comment.timestamp})" style="margin-right:5px;">Edit</button>
                                        <button onclick="deleteComment(${comment.timestamp})">Delete</button>
                                        <div style="font-size:11px; opacity:0.8;">By ${comment.user} on ${dateStr}</div>`;
                    
                    commentSpan.appendChild(tooltip);
                    paragraph.appendChild(commentSpan);
                    paragraph.appendChild(document.createTextNode(' '));
                });
            });
        }

        // Comment functionality
        function attachCommentListeners() {
            document.querySelectorAll('.commentable').forEach(p => {
                p.style.cursor = 'text';
                p.addEventListener('contextmenu', (e) => { e.preventDefault(); });
                p.removeEventListener('mouseup', commentableMouseUpHandler);
                p.addEventListener('mouseup', commentableMouseUpHandler);
            });
        }

        function commentableMouseUpHandler(e) {
            setTimeout(() => {
                const selection = window.getSelection();
                if (!selection.isCollapsed && selection.toString().trim().length > 0) {
                    const range = selection.getRangeAt(0);
                    if (!this.contains(range.commonAncestorContainer)) return;
                    const rect = range.getBoundingClientRect();
                    const menu = document.getElementById('comment-menu');
                    menu.style.left = (rect.left + window.scrollX) + 'px';
                    menu.style.top = (rect.bottom + window.scrollY) + 'px';
                    menu.classList.add('show');
                    menu.selectionRange = range;
                }
            }, 0);
        }

        function initializeCommentSystem() {
            attachCommentListeners();
        }

        // Load thread content
        function loadThreadContent(subject) {
            const data = threads[subject];
            if (!data) return;

            let html = `
                <div style="max-width: 700px;">
                    <h2>${subject}</h2>
                    <div class="thread-messages">
            `;
            
            data.messages.forEach(msg => {
                const dateStr = new Date(msg.timestamp).toLocaleString();
                const isCurrentUser = msg.user === userEmail;
                html += `
                    <div class="thread-message" style="${isCurrentUser ? 'margin-left: 20px; background: #e7f3ff;' : ''}">
                        <p>${msg.text}</p>
                        <small style="color: #6c757d;">By ${msg.user} at ${dateStr}</small>
                    </div>
                `;
            });
            
            html += `
                    </div>
                    <div class="reply-form">
                        <textarea id="reply-text" placeholder="Add a reply..."></textarea>
                        <button onclick="addReply('${subject}')">Reply</button>
                    </div>
                </div>
            `;
            
            const center = document.getElementById('center-panel');
            center.innerHTML = html;
        }

        // Add reply
        function addReply(subject) {
            const textarea = document.getElementById('reply-text');
            const text = textarea.value.trim();
            if (!text) return;

            const now = Date.now();
            const data = threads[subject];
            
            data.messages.push({
                text: text,
                timestamp: now,
                user: userEmail
            });
            
            data.lastActivity = now;
            textarea.value = '';
            
            loadThreadContent(subject);
            buildThreadList();
        }

        // Lens tab switching
        document.querySelectorAll('.lens-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.lens-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                const lens = tab.dataset.lens;
                document.querySelectorAll('.document-item').forEach(doc => {
                    const lenses = doc.dataset.lenses.split(' ');
                    doc.style.display = (lens === 'all' || lenses.includes(lens)) ? 'block' : 'none';
                });
            });
        });

        // Comment option handling
        document.querySelectorAll('.comment-option').forEach(option => {
            option.addEventListener('click', (e) => {
                e.stopPropagation();
                const type = option.dataset.type; 
                const menu = document.getElementById('comment-menu');
                const range = menu.selectionRange;
                if (!range) return;
                
                let highlightColor = '';
                if (type === 'question') { 
                    highlightColor = 'rgba(255, 0, 0, 0.3)';
                    currentCommentType = 'question';
                    showCommentDialog('question');
                    currentCommentRange = range;
                    menu.classList.remove('show');
                    window.getSelection().removeAllRanges();
                    return;
                } else if (type === 'clarification') {
                    highlightColor = 'rgba(255, 255, 0, 0.3)';
                    currentCommentType = 'clarification';
                    showCommentDialog('clarification');
                    currentCommentRange = range;
                    menu.classList.remove('show');
                    window.getSelection().removeAllRanges();
                    return;
                } else if (type === 'approved') {
                    highlightColor = 'rgba(0, 255, 0, 0.3)';
                    currentCommentType = 'approved';
                    addHighlight(range, highlightColor, '', currentCommentType);
                }
                menu.classList.remove('show');
                window.getSelection().removeAllRanges();
            });
        });

        function addHighlight(range, highlightColor, commentText, type) {
            const now = Date.now();
            const commentSpan = document.createElement('span');
            commentSpan.className = 'comment-marker';
            commentSpan.dataset.commentId = now;
            commentSpan.style.backgroundColor = highlightColor;
            commentSpan.style.marginLeft = '5px';
            commentSpan.style.cursor = 'pointer';
            
            const extractedContent = range.extractContents();
            const originalText = extractedContent.textContent;
            commentSpan.dataset.originalText = originalText;
            
            const startContainer = range.startContainer;
            const startOffset = range.startOffset;
            const endOffset = range.endOffset;
            
            const paragraph = startContainer.parentElement.closest('.commentable');
            const paragraphText = paragraph.textContent;
            
            const textBefore = paragraphText.substring(0, startOffset);
            const textAfter = paragraphText.substring(endOffset);
            
            commentSpan.appendChild(extractedContent);
            range.insertNode(commentSpan);
            
            const tooltip = document.createElement('div');
            tooltip.className = 'comment-tooltip';
            
            const dateStr = new Date(now).toLocaleDateString();
            
            let tooltipContent = '';
            if (commentText) {
                tooltipContent += `<div>${commentText}</div>`;
            }
            tooltipContent += `<div style="font-size:11px; opacity:0.8;">By ${userEmail} on ${dateStr}</div>`;
            tooltipContent += `<div style="margin-top:5px; font-size:10px;">
                                <button onclick="editComment(${now})" style="margin-right:5px;">Edit</button>
                                <button onclick="deleteComment(${now})">Delete</button>
                            </div>`;
            tooltip.innerHTML = tooltipContent;
            
            commentSpan.appendChild(tooltip);
            
            const currentDocItem = document.querySelector('.document-item.active');
            if (!currentDocItem) {
                console.error('No active document found');
                return;
            }
            
            const docId = currentDocItem.dataset.id;
            const p = commentSpan.closest('.commentable');
            
            if (!p) {
                console.error('Comment target paragraph not found');
                const comments = getStoredComments();
                comments[docId] = comments[docId] || {};
                comments[docId]['general'] = comments[docId]['general'] || [];
                comments[docId]['general'].push({
                    text: commentText,
                    user: userEmail,
                    timestamp: now,
                    type: type,
                    highlightedText: originalText,
                    contextBefore: textBefore,
                    contextAfter: textAfter
                });
                saveComments(comments);
                return;
            }
            
            const paraIndex = p.dataset.paraIndex;
            const comments = getStoredComments();
            comments[docId] = comments[docId] || {};
            comments[docId][paraIndex] = comments[docId][paraIndex] || [];
            comments[docId][paraIndex].push({
                text: commentText,
                user: userEmail,
                timestamp: now,
                type: type,
                highlightedText: originalText,
                contextBefore: textBefore,
                contextAfter: textAfter
            });
            saveComments(comments);
            
            saveCommentToMarkdown(docId, paraIndex, type === 'question' ? '?' : type === 'clarification' ? '!' : '✓', 
                                commentText, userEmail, now, originalText, textBefore, textAfter);
        }

        function showCommentDialog(type) {
            const dialog = document.getElementById('comment-dialog');
            const title = document.getElementById('comment-dialog-title');
            const label = document.getElementById('comment-dialog-label');
            const textarea = document.getElementById('comment-dialog-text');

            if (type === 'question') {
                title.textContent = 'Ask Question';
                label.textContent = 'Question text:';
                textarea.placeholder = 'What would you like to clarify or ask about this section?';
            } else if (type === 'clarification') {
                title.textContent = 'Request Clarification';
                label.textContent = 'Clarification needed:';
                textarea.placeholder = 'What needs to be clarified or expanded in this section?';
            }

            textarea.value = '';
            dialog.classList.add('show');
            dialog.style.display = 'block';
            textarea.focus();
        }

        function hideCommentDialog() {
            const dialog = document.getElementById('comment-dialog');
            dialog.classList.remove('show');
            dialog.style.display = 'none';
            currentCommentType = '';
        }

        function submitComment() {
            const textarea = document.getElementById('comment-dialog-text');
            const newText = textarea.value.trim();
            
            if (currentEditingInfo) {
                if (!newText) {
                    alert('Please enter comment text');
                    return;
                }
                // Handle editing logic here
                currentEditingInfo = null;
                hideCommentDialog();
                return;
            }
            
            if ((currentCommentType === 'question' || currentCommentType === 'clarification') && !newText) {
                alert('Please enter comment text');
                return;
            }
            
            let highlightColor = '';
            if (currentCommentType === 'question') highlightColor = 'rgba(255, 0, 0, 0.3)';
            else if (currentCommentType === 'clarification') highlightColor = 'rgba(255, 255, 0, 0.3)';
            else if (currentCommentType === 'approved') highlightColor = 'rgba(0, 255, 0, 0.3)';
            
            if (currentCommentRange) {
                addHighlight(currentCommentRange, highlightColor, newText, currentCommentType);
            } else {
                console.error("No selection range available.");
            }
            hideCommentDialog();
            currentCommentRange = null;
            currentCommentType = '';
        }

        function editComment(commentTimestamp) {
            // Implementation for editing comments
        }

        async function deleteComment(commentTimestamp) {
            const commentElement = document.querySelector(`[data-comment-id="${commentTimestamp}"]`);
            
            if (!commentElement) {
                console.error('Comment element not found in DOM');
                return;
            }
            
            const originalText = commentElement.dataset.originalText || 
                                Array.from(commentElement.childNodes)
                                    .filter(node => node.nodeType === Node.TEXT_NODE || 
                                                    (node.nodeType === Node.ELEMENT_NODE && 
                                                    !node.classList.contains('comment-tooltip')))
                                    .map(node => node.textContent)
                                    .join('');
            
            const textNode = document.createTextNode(originalText);
            commentElement.parentNode.replaceChild(textNode, commentElement);
            
            // Remove from storage
            const currentDocItem = document.querySelector('.document-item.active');
            if (currentDocItem) {
                const docId = currentDocItem.dataset.id;
                const comments = getStoredComments();
                
                if (comments[docId]) {
                    for (const paraIndex in comments[docId]) {
                        const commentsArr = comments[docId][paraIndex];
                        for (let i = 0; i < commentsArr.length; i++) {
                            if (commentsArr[i].timestamp == commentTimestamp) {
                                commentsArr.splice(i, 1);
                                if (commentsArr.length === 0) {
                                    delete comments[docId][paraIndex];
                                }
                                saveComments(comments);
                                return;
                            }
                        }
                    }
                }
            }
        }

        async function saveCommentToMarkdown(docId, paraIndex, prefix, text, user, timestamp, highlightedText, contextBefore, contextAfter) {
            const mdComment = text ? 
                `<!-- ${prefix} ${text} | ${user} | ${timestamp} | ${highlightedText} | ${contextBefore} | ${contextAfter} -->` :
                `<!-- ${prefix} | ${user} | ${timestamp} | ${highlightedText} | ${contextBefore} | ${contextAfter} -->`;
            
            try {
                const response = await fetch('/api/save-comment', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        docId,
                        paraIndex, 
                        comment: mdComment,
                        highlightedText,
                        contextBefore,
                        contextAfter
                    })
                });
                
                if (!response.ok) {
                    console.error('Failed to save comment to markdown');
                }
            } catch (error) {
                console.error('Error saving comment to markdown:', error);
            }
        }

        function attachThreadListeners() {
            document.querySelectorAll('.message-thread').forEach(thread => {
                thread.addEventListener('click', () => {
                    document.querySelectorAll('.document-item, .message-thread').forEach(i => i.classList.remove('active'));
                    thread.classList.add('active');
                    
                    const subject = thread.querySelector('.pill-subject').textContent;
                    loadThreadContent(subject);
                    markThreadAsRead(subject);
                });
            });
        }

        // Modal functions
        function showOverview() {
            document.getElementById('overview-modal').classList.add('show');
        }

        function hideOverview() {
            document.getElementById('overview-modal').classList.remove('show');
        }

        // Thread form functions
        function showNewThreadForm() {
            document.getElementById('new-thread-form').classList.add('show');
        }

        function hideNewThreadForm() {
            document.getElementById('new-thread-form').classList.remove('show');
            document.getElementById('thread-subject').value = '';
            document.getElementById('thread-topic').value = '';
            document.getElementById('thread-message').value = '';
        }

        function createThread() {
            const subject = document.getElementById('thread-subject').value.trim();
            const topic = document.getElementById('thread-topic').value.trim();
            const message = document.getElementById('thread-message').value.trim();
            
            if (!subject || !topic || !message) {
                alert('Please fill in all fields');
                return;
            }

            const now = Date.now();

            threads[subject] = {
                topic: topic,
                timestamp: now,
                lastActivity: now,
                messages: [{
                    text: message,
                    timestamp: now,
                    user: userEmail
                }]
            };

            markThreadAsRead(subject);
            buildThreadList();
            initTopicFilters();
            hideNewThreadForm();
        }

        // Hide comment menu on click outside
        document.addEventListener('click', () => {
            document.getElementById('comment-menu').classList.remove('show');
        });

        // Initialize everything - SINGLE INIT FUNCTION
        async function init() {
            if (isInitialized) return; // Prevent duplicate initialization
            isInitialized = true;
            
            try {
                await fetchUserEmail();
                await buildLeftPanel();
                initTopicFilters();
                buildThreadList();
                initializeCommentSystem();
                
                // Add lens tab event listeners
                document.querySelectorAll('.lens-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        document.querySelectorAll('.lens-tab').forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');
                        const lens = tab.dataset.lens;
                        document.querySelectorAll('.document-item').forEach(doc => {
                            const lenses = doc.dataset.lenses.split(' ');
                            doc.style.display = (lens === 'all' || lenses.includes(lens)) ? 'block' : 'none';
                        });
                    });
                });
                
            } catch (error) {
                console.error('Error during initialization:', error);
            }
        }

        // Start the application only after DOM is fully loaded
        document.addEventListener('DOMContentLoaded', init);

        // Add comment marker click handling
        document.addEventListener('click', function(e) {
            const marker = e.target.closest('.comment-marker');
            if (marker) {
                const tooltip = marker.querySelector('.comment-tooltip');
                if (tooltip) {
                    tooltip.style.display = (tooltip.style.display === "block") ? "none" : "block";
                    e.stopPropagation();
                }
            }
        });
    </script>
</body>
</html>